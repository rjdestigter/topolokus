{"version":3,"sources":["logo.svg","modules/core/types.ts","modules/core/utils/mapMouseEventToCoords.ts","modules/core/add/events.ts","modules/core/draw/marker.ts","modules/core/draw/polygon.ts","modules/core/draw/line.ts","modules/core/draw/resetStyles.ts","modules/core/draw/index.ts","modules/core/add/reducer.ts","modules/core/utils/isPolygon.ts","modules/core/reducers.ts","modules/core/observables.ts","modules/core/utils/index.ts","modules/core/selectors.ts","modules/core/utils/isNotNr.ts","modules/core/add/observables.ts","modules/core/index.ts","apps/map/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","StateType","EventTypes","AddEventTypes","evt","offsetX","offsetY","ctx","x","y","context","beginPath","arc","Math","PI","fillStyle","fill","stroke","closePath","marker","polygon","forEach","ring","hx","hy","t","moveTo","lineTo","point","points","strokeStyle","lineWidth","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","api","finalMarker","defaultMarker","defaultPolygon","line","defaultLine","resetStyles","addPolygon","type","AddPolygon","state","event","value","Noop","newPolygon","fromNoopToAddPolygon","AddPointToNewPolygon","addPointToNewPolygon","payload","SubmitNewPolygon","length","polygons","submitNewPolygon","CancelNewPolygon","cancelNewPolygon","addReducer","mapFirst","map","stateUpdates$","Subject","stateChanges$","pipe","filter","state$","events$","eventTypes$","fromEventType","eventType","dispatchedEventType","keyPressCode$","fromEvent","document","keyCode","tap","k","console","warn","ofKeyCode","pressedKeyCode","Array","isArray","includes","enterKey$","cancelKey$","emptyArray","pointsS","f","previousA","previousB","a","memoize","polygonsS","reduce","acc","push","addPolygonEvent$","makeDispatchSubmitNewPolygon","dispatch","of","action","makeDispatchCancelNewPolygon","cancelOrSubmitEvent$","addPolygonState$","merge","concat","take","isNotNr","hasOwnProperty","makeSubmitNewPolygon$","makeCancelNewPolygon","makeAddPointToPolygon","onMouseClick$","takeUntil","makeAddPolygonProgram","withCanvas","canvas","getContext","pencil","pencil_","next","mapPointToSnap","pointSnap","pointsDb","within","KDBush","updatePointsDb$","c","n","square","reverse","mousePosition","hovering","history","setState","nextState","e","mapMouseEventToCoords","updateStateWithMousePosition$","reduceActions$","transition","groupCollapsed","log","groupEnd","draw$","clearRect","width","height","subscription","repeat","subscribe","getState","getHistory","done","unsubscribe","load","Error","position","position2","Map","props","center","zoom","TileLayer","url","attribution","Circle","radius","Popup","Pane","name","children","Canvas","useLeaflet","React","useEffect","canvasLayer","pane","padding","addTo","Object","assign","window","_container","onZoomOrMove","dragging","disable","addEventListener","removeEventListener","removeLayer","getCenter","lat","lng","App","className","src","logo","alt","id","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9cc7d3b0.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import { AddState } from './add/types'\n\n// Aliases\nexport type Pixel = number\nexport type Coord = number\n\nexport type Point = [Pixel, Pixel, Coord, Coord] | [Pixel, Pixel]\nexport type Line = Point[]\nexport type Polygon = Line[]\n\nexport enum StateType {\n    Noop = 'Noop',\n    AddPolygon = 'AddPolygon',\n}\n\n// State\nexport interface SharedState {\n    readonly polygons: Polygon[]\n    readonly mousePosition: [Pixel, Pixel]\n    readonly hovering: boolean\n}\n\nexport interface NoopState extends SharedState {\n    readonly value: StateType.Noop\n}\n\nexport type State = NoopState | AddState\n\n// Actions\nexport enum EventTypes {\n    SelectPolygon = 'SelectPolygon',\n    EditPolygon = 'EditPolygon',\n    RemovePolygon = 'RemovePolygon',\n}\n","export default (evt: MouseEvent): [number, number] => [evt.offsetX, evt.offsetY]\n","import { Point } from '../types'\n\n/**\n * Event type descriptors for the \"Add Polygon\" process\n */\nexport enum AddEventTypes {\n    AddPolygon = 'AddPolygon',\n    AddPointToNewPolygon = 'AddPointToNewPolygon',\n    SubmitNewPolygon = 'SubmitNewPolygon',\n    CancelNewPolygon = 'CancelNewPolygon',\n}\n\n/**\n * Event dispatched when the user wants to add a new polygon.\n */\nexport type AddPolygonEvent = {\n    type: AddEventTypes.AddPolygon\n}\n\n/**\n * Event dispatched when the user clicks on the canvas to add a new point to the polygon they are creating.\n */\nexport type AddPointToNewPolygonEvent = {\n    type: AddEventTypes.AddPointToNewPolygon\n    payload: Point\n}\n\n/**\n * Event dispatched when the user has finished creating a new polygon.\n */\nexport type SubmitNewPolygonEvent = {\n    type: AddEventTypes.SubmitNewPolygon\n}\n\n/**\n * Event dispatched when the user wants to cancel creating a new polygon.\n */\nexport type CancelNewPolygonEvent = {\n    type: AddEventTypes.CancelNewPolygon\n}\n\n/**\n * All possible events for the \"Add poloygon\" process\n */\nexport type AddEvent =\n    | AddPolygonEvent\n    | AddPointToNewPolygonEvent\n    | SubmitNewPolygonEvent\n    | CancelNewPolygonEvent\n\n/**\n * Event creator instructing the program the user wants to create a new polygon.\n */\nexport const addPolygon = (): AddPolygonEvent => ({ type: AddEventTypes.AddPolygon })\n\n/**\n * Event creator instructing the program to add a new point to the new polygon.\n */\nexport const addPointToNewPolygon = (point: Point): AddPointToNewPolygonEvent => ({\n    type: AddEventTypes.AddPointToNewPolygon,\n    payload: point,\n})\n\n/**\n * Event creator instructing the program the user has finished creating a new polygon.\n */\nexport const submitNewPolygon = (): SubmitNewPolygonEvent => ({\n    type: AddEventTypes.SubmitNewPolygon,\n})\n\n/**\n * Event creator instructing the program the user wants to cancel creating a new polygon.\n */\nexport const cancelNewPolygon = (): CancelNewPolygonEvent => ({\n    type: AddEventTypes.CancelNewPolygon,\n})\n","import { Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => ([x, y]: Point, context = ctx) => {\n    context.beginPath()\n    context.arc(x, y, 5, 0, 2 * Math.PI)\n    context.fillStyle = '#fff'\n    context.fill()\n    context.stroke()\n    context.closePath()\n}\n","import { Polygon, Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: Point, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (polygon: Polygon, context = ctx) => {\n    context.beginPath()\n\n    polygon.forEach(ring => {\n        const [[hx, hy], ...t] = ring\n\n        context.moveTo(hx, hy)\n\n        t.forEach(([x, y]) => {\n            context.lineTo(x, y)\n        })\n        context.closePath()\n    })\n\n    context.fillStyle = 'Cyan'\n\n    context.fill()\n\n    context.stroke()\n\n    polygon.forEach(ring => ring.forEach(point => marker(point, context)))\n}\n","import { Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: Point, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (points: Point[], context = ctx) => {\n    context.beginPath()\n\n    const [[hx, hy], ...t] = points\n\n    context.moveTo(hx, hy)\n\n    t.forEach(([x, y]) => {\n        context.lineTo(x, y)\n    })\n\n    context.stroke()\n\n    points.forEach(point => marker(point, context))\n}\n","export default (ctx: CanvasRenderingContext2D) => {\n    ctx.fillStyle = '#ffffff'\n    ctx.strokeStyle = '#000000'\n    ctx.lineWidth = 1\n    ctx.shadowBlur = 0\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'\n}\n","import defaultMarker from './marker'\nimport defaultPolygon from './polygon'\nimport defaultLine from './line'\nimport resetStyles from './resetStyles'\n\ninterface Api {\n    marker: typeof defaultMarker\n    polygon: typeof defaultPolygon\n    line: typeof defaultLine\n}\n\nexport default (api: Partial<Api> = {}) => (ctx: CanvasRenderingContext2D) => {\n    const finalMarker = (api.marker || defaultMarker)(ctx)\n    const finalPolygon = (api.polygon || defaultPolygon)(finalMarker)(ctx)\n    const finalLine = (api.line || defaultLine)(finalMarker)(ctx)\n\n    return {\n        marker: finalMarker,\n        polygon: finalPolygon,\n        line: finalLine,\n        resetStyles,\n    }\n}\n","import { State, NoopState, StateType, Polygon, Point } from '../types'\n\nimport { AddState } from './types'\nimport { AddEventTypes } from './events'\nimport { Event } from '../events'\n\nimport isPolygon from '../utils/isPolygon'\n\n/**\n * Transitions state to the beginning o the \"Add polygon\" process\n */\nexport const fromNoopToAddPolygon = (state: NoopState): AddState => {\n    return {\n        ...state,\n        value: StateType.AddPolygon,\n        newPolygon: [],\n    }\n}\n\n/**\n * Adds a point to the new poloygon the user is creating.\n */\nexport const addPointToNewPolygon = (state: AddState, point: Point): AddState => {\n    return {\n        ...state,\n        value: StateType.AddPolygon,\n        newPolygon: [...state.newPolygon, point],\n    }\n}\n\n/**\n * Transitions state to include the new polygon and return to base state.\n */\nexport const submitNewPolygon = (state: AddState, polygon: Polygon): NoopState => {\n    return {\n        ...state,\n        value: StateType.Noop,\n        polygons: [...state.polygons, polygon],\n    }\n}\n\n/**\n * Transitions back to base state without a new polygon.\n */\nexport const cancelNewPolygon = (state: AddState): NoopState => {\n    return {\n        ...state,\n        value: StateType.Noop,\n    }\n}\n\n/**\n * Handles incoming events and transitions state accordingly.\n */\nexport default (state: State, event: Event): State => {\n    // Transition to \"AddPolygon\" state\n    if (event.type === AddEventTypes.AddPolygon && state.value === StateType.Noop) {\n        return fromNoopToAddPolygon(state)\n    }\n\n    // Add point to new polygon currently being drawn\n    else if (\n        event.type === AddEventTypes.AddPointToNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return addPointToNewPolygon(state, event.payload)\n    }\n\n    // Finish drawing new polygon\n    else if (\n        event.type === AddEventTypes.SubmitNewPolygon &&\n        state.value === StateType.AddPolygon &&\n        isPolygon(state.newPolygon)\n    ) {\n        return submitNewPolygon(state, [state.newPolygon])\n    }\n\n    // Cancel drawing a new polygon\n    else if (\n        event.type === AddEventTypes.CancelNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return cancelNewPolygon(state)\n    }\n\n    return state\n}\n","import { Point, Line } from '../types'\n\nexport default (points?: Point[]): points is Line => points != null && points.length > 2\n","import { State } from './types'\nimport { Event } from './events'\nimport addReducer from './add/reducer'\n\nexport default (state: State, event: Event): State => addReducer(state, event)\n","import { Subject, fromEvent } from 'rxjs'\nimport { map, filter, tap } from 'rxjs/operators'\n\nimport { State } from './types'\nimport { Event, EventType } from './events'\n\nimport { first } from './utils'\n\n/** Maps an observable of a tuple to an observable of the first element in the tuple */\nexport const mapFirst = map(first)\n\n/**\n * Observable streaming current and previous state\n */\nexport const stateUpdates$ = new Subject<[State, State]>()\n\n/**\n * Filters state updates by checking if state has actually changed\n */\nexport const stateChanges$ = stateUpdates$.pipe(filter(([c, p]) => c !== p))\n\n/**\n * Maps state changes to actual state\n */\nexport const state$ = stateChanges$.pipe(mapFirst)\n\n/** Emits `state.polygons` any time it changes */\nexport const polygons$ = state$.pipe(map(state => state.polygons))\n\n/**\n *\n */\nexport const events$ = new Subject<Event>()\n\n/**\n *\n */\nexport const eventTypes$ = events$.pipe(map(event => event.type))\n\n/**\n *\n */\nexport const fromEventType = <T extends EventType>(eventType: T) =>\n    eventTypes$.pipe(\n        filter(\n            (dispatchedEventType): dispatchedEventType is T => eventType === dispatchedEventType,\n        ),\n    )\n\n/**\n *\n */\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress') // .pipe(tap(console.info))\n\n/**\n *\n */\nexport const keyPressCode$ = keyPress$.pipe(\n    map(evt => evt.keyCode),\n    tap(k => console.warn(k)),\n)\n\n/**\n *\n */\nexport const ofKeyCode = (keyCode: number | number[]) =>\n    keyPressCode$.pipe(\n        filter(pressedKeyCode =>\n            Array.isArray(keyCode) ? keyCode.includes(pressedKeyCode) : pressedKeyCode === keyCode,\n        ),\n    )\n\n/**\n *\n */\nexport const enterKey$ = ofKeyCode(13)\n\n/**\n *\n */\nexport const cancelKey$ = ofKeyCode(99)\n","/** Returns the first element of a tuple */\nexport const first = <A, B>(t: [A, B]): A => t[0]\n\nexport const memoize = <A, B>(f: (a: A) => B) => {\n    let previousA: A | undefined\n    let previousB: B | undefined\n\n    return (a: A): B => {\n        if (a !== previousA) {\n            previousA = a\n            previousB = f(a)\n        }\n\n        return previousB as B\n    }\n}\n","import { State, Point, StateType } from './types'\nimport { memoize } from './utils'\n\nconst emptyArray: any[] = []\n\nexport const polygonsS = (state: State) => state.polygons\n\nexport const newPolygonS = (state: State): Point[] => {\n    if (state.value === StateType.AddPolygon) {\n        return state.newPolygon\n    }\n\n    return emptyArray\n}\n\nexport const pointsS = memoize((state: State): Point[] =>\n    polygonsS(state).reduce(\n        (acc, polygon) => {\n            polygon.forEach(line => {\n                line.forEach(point => {\n                    acc.push(point)\n                })\n            })\n\n            return acc\n        },\n        emptyArray as Point[],\n    ),\n)\n","export default <T>(value: number | T): value is T => typeof value !== 'number'\n","import { Observable, concat, merge, of } from 'rxjs'\nimport { take, tap, takeUntil, filter } from 'rxjs/operators'\n\nimport { AddState } from './types'\nimport { fromEventType, cancelKey$, enterKey$, ofKeyCode } from '../observables'\nimport {\n    AddEventTypes,\n    addPointToNewPolygon,\n    submitNewPolygon,\n    cancelNewPolygon,\n    SubmitNewPolygonEvent,\n    addPolygon,\n} from './events'\nimport { Point } from '../types'\nimport { Event } from '../events'\nimport isNotNr from '../utils/isNotNr'\n\n/** Type describing the function that passes an event to the events$ [[Subject]] */\ntype Dispatch = (event: Event) => void\n\n/** Observable for event of type  AddPolygon */\nexport const addPolygonEvent$ = fromEventType(AddEventTypes.AddPolygon)\n\n/** Observable for event of type  AddPointToNewPolygon */\nexport const addPointToNewPolygonEvent$ = fromEventType(AddEventTypes.AddPointToNewPolygon)\n\n/** Observable for event of type  SubmitNewPolygon */\nexport const submitNewPolygonEvent$ = fromEventType(AddEventTypes.SubmitNewPolygon)\n\n/** Observable for event of type  CancelNewPolygon */\nexport const cancelNewPolygonEvent$ = fromEventType(AddEventTypes.CancelNewPolygon)\n\n/**\n * Creates an observable of a single dispatch SubmitNewPolygon event.\n */\nconst makeDispatchSubmitNewPolygon = (dispatch: Dispatch) =>\n    of(submitNewPolygon()).pipe(tap(action => dispatch(action)))\n\n/**\n * Creates an observable of a single dispatch CancelNewPolygon event.\n */\nconst makeDispatchCancelNewPolygon = (dispatch: Dispatch) =>\n    of(cancelNewPolygon()).pipe(tap(action => dispatch(action)))\n\n/**\n * Creates an observable that will dispatch the CancelNewPolygon event when\n * the user pressed the key (c) to cancel the \"Add poloygon\" operation.\n */\nconst makeCancelNewPolygon = (addPolygonState$: Observable<AddState>, dispatch: Dispatch) =>\n    concat(cancelKey$.pipe(take(1)), makeDispatchCancelNewPolygon(dispatch)).pipe(\n        // Filter out the key presses and only emit the CancelNewPolygonEvent event.\n        filter(isNotNr),\n    )\n\n/**\n * Given an observable that streams state updates to [[AddState]] this function creates\n * an observable that will dispatch the SubmitNewPolygon event when the user presses\n * the entery key if the number of points in the polygon is larger than 2.\n */\nconst makeSubmitNewPolygon$ = (addPolygonState$: Observable<AddState>, dispatch: Dispatch) =>\n    concat(\n        // Await state changes until the new polygon is enough points\n        // to become a valid polygon.\n        // TODO: When the user undoes adding points and reverts to 2 points\n        addPolygonState$.pipe(\n            filter(state => state.newPolygon.length > 2),\n            take(1),\n        ),\n        enterKey$.pipe(take(1)),\n        makeDispatchSubmitNewPolygon(dispatch),\n    ).pipe(\n        // Filter out the key presses and state changes so that this stream\n        // ends up only emitting the SubmitNewPolygonEvent event.\n        filter(isNotNr),\n        filter(\n            (value): value is SubmitNewPolygonEvent =>\n                isNotNr(value) && value.hasOwnProperty('type'),\n        ),\n    )\n\n/** Observable for event of type CancelNewPolygon or SubmitNewPolygon */\nconst cancelOrSubmitEvent$ = (addPolygonState$: Observable<AddState>, dispatch: Dispatch) =>\n    merge(\n        makeSubmitNewPolygon$(addPolygonState$, dispatch),\n        makeCancelNewPolygon(addPolygonState$, dispatch),\n    )\n\n/**\n * Creates a program that will add a point to [[AddState]]'s `.newPolygon`\n * on every mosue click until the cancel or submit events are dispatched.\n */\nexport const makeAddPointToPolygon = (\n    onMouseClick$: Observable<Point>,\n    addPolygonState$: Observable<AddState>,\n    dispatch: (event: Event) => void,\n) =>\n    onMouseClick$.pipe(\n        tap(point => dispatch(addPointToNewPolygon(point))),\n        takeUntil(cancelOrSubmitEvent$(addPolygonState$, dispatch)),\n    )\n\n/**\n * Creates a program for adding new polygons.\n */\nexport const makeAddPolygonProgram = (\n    onMouseClick$: Observable<Point>,\n    addPolygonState$: Observable<AddState>,\n    dispatch: (event: Event) => void,\n) =>\n    concat(\n        merge(\n            concat(\n                // Await pressing key \"a\" or \"A\"\n                ofKeyCode([65, 97]).pipe(take(1)),\n                // Dispatch \"AddPolygon\" event\n                of(addPolygon()).pipe(tap(dispatch)),\n            ).pipe(filter(isNotNr)),\n            addPolygonEvent$,\n        ).pipe(take(1)),\n        makeAddPointToPolygon(onMouseClick$, addPolygonState$, dispatch),\n    )\n\nexport default makeAddPolygonProgram\n","import { fromEvent, merge } from 'rxjs'\nimport { map, tap, repeat, filter } from 'rxjs/operators'\n\nimport KDBush from 'kdbush'\n\nimport { StateType, State, Point, Polygon } from './types'\nimport mapMouseEventToCoords from './utils/mapMouseEventToCoords'\nimport pencil_ from './draw'\nimport { Event } from './events'\nimport transition from './reducers'\nimport { stateUpdates$, events$, mapFirst, state$, stateChanges$ } from './observables'\nimport { pointsS } from './selectors'\n\nimport { AddState } from './add/types'\nimport { addPolygon } from './add/events'\nimport makeAddPolygonProgram from './add/observables'\n\nexport function withCanvas(canvas: HTMLCanvasElement) {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx != null) {\n        const pencil = pencil_()(ctx)\n\n        const dispatch = (event: Event) => events$.next(event)\n\n        const mapPointToSnap = ([x, y]: [number, number]): [number, number] => {\n            const pointSnap = pointsS(state)[pointsDb.within(x, y, 10)[0]]\n\n            return pointSnap ? [pointSnap[0], pointSnap[1]] : [x, y]\n        }\n\n        let pointsDb: KDBush.KDBush<Point> =\n            // @ts-ignore\n            new KDBush([])\n\n        const updatePointsDb$ = stateChanges$.pipe(\n            filter(([c, n]) => c.polygons !== n.polygons),\n            mapFirst,\n            map(pointsS),\n            tap(points => {\n                // @ts-ignore\n                pointsDb = new KDBush(points)\n            }),\n        )\n\n        const square: Polygon = [\n            [[100, 100], [300, 100], [300, 300], [100, 300]],\n            // @ts-ignore\n            [[150, 150], [250, 150], [250, 250], [150, 250]].reverse(),\n        ]\n\n        let state: State = {\n            mousePosition: [0, 0],\n            value: StateType.Noop,\n            polygons: [square],\n            hovering: false,\n        }\n\n        const history: State[] = []\n\n        const setState = (nextState: State) => {\n            history.push(state)\n            state = nextState\n            stateUpdates$.next([state, history[history.length - 1] || state])\n        }\n\n        const onMouseClick$ = fromEvent<MouseEvent>(canvas, 'click').pipe(\n            map(e => mapMouseEventToCoords(e)),\n        )\n\n        const onMouseMoveObservable = fromEvent<MouseEvent>(canvas, 'mousemove').pipe(\n            map(e => mapMouseEventToCoords(e)),\n        )\n\n        const updateStateWithMousePosition$ = onMouseMoveObservable.pipe(\n            map(mapPointToSnap),\n            tap(mousePosition => {\n                setState({\n                    ...state,\n                    mousePosition: mousePosition as [number, number],\n                })\n            }),\n        )\n\n        // const logStateChange$ = stateUpdates$.pipe(tap(console.log))\n\n        const reduceActions$ = events$.pipe(\n            tap(event => {\n                const nextState = transition(state, event)\n                console.groupCollapsed(event.type)\n                console.log(event)\n                console.log(state)\n                console.groupEnd()\n                setState(nextState)\n            }),\n        )\n\n        const addPolygonState$ = state$.pipe(\n            filter((state): state is AddState => state.value === StateType.AddPolygon),\n        )\n\n        const draw$ = state$.pipe(\n            tap(state => {\n                pencil.resetStyles(ctx)\n\n                // Clear the canvas\n                ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n                // Draw existing polygons in state\n                state.polygons.forEach(polygon => {\n                    pencil.polygon(polygon)\n                    pencil.resetStyles(ctx)\n                })\n\n                // Draw potential new polygon\n                if (state.value === StateType.AddPolygon) {\n                    if (state.newPolygon.length > 1) {\n                        pencil.polygon([[...state.newPolygon, state.mousePosition]])\n                        pencil.resetStyles(ctx)\n                    } else if (state.newPolygon.length === 1) {\n                        pencil.line([...state.newPolygon, state.mousePosition])\n                        pencil.resetStyles(ctx)\n                    }\n                }\n            }),\n        )\n\n        const subscription = merge(\n            reduceActions$,\n            updateStateWithMousePosition$,\n            // logStateChange$,\n            updatePointsDb$,\n            makeAddPolygonProgram(\n                onMouseClick$.pipe(map(mapPointToSnap)),\n                addPolygonState$,\n                dispatch,\n            ).pipe(repeat()),\n            draw$,\n        ).subscribe()\n\n        return {\n            getState: () => state,\n            getHistory: () => history,\n            // subscribe: (cb: () => void) => {\n            //     stateUpdates$.subscribe(cb)\n            // },\n            done: () => {\n                subscription.unsubscribe()\n            },\n            api: {\n                addPolygon: () => dispatch(addPolygon()),\n                load: (polygons: Polygon[]) =>\n                    setState({\n                        ...state,\n                        polygons: [...state.polygons, ...polygons],\n                    }),\n            },\n        }\n    }\n\n    throw new Error('Canvas 2D Rendering Context Not Available')\n}\n\nexport default withCanvas\n","import React from 'react'\nimport { Map as ReactLeafletMap, Popup, TileLayer, useLeaflet, Pane, Circle } from 'react-leaflet'\n\nimport '../../leaflet/leaflet.css'\nimport { canvas } from 'leaflet'\n\nimport { withCanvas } from '../../modules/core'\n\nconst position: [number, number] = [51.9085, 5.0509] // [51.505, -0.09]\nconst position2: [number, number] = [51.885, 5.0509] // [51.505, -0.09]\n\nconst Map: React.FC = (props: { children?: React.ReactNode }) => (\n    <ReactLeafletMap center={position} zoom={13}>\n        <TileLayer\n            url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n            attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n        />\n        <Circle center={position2} radius={1000}>\n            <Popup>\n                A pretty CSS3 popup.\n                <br />\n                Easily customizable.\n            </Popup>\n        </Circle>\n        <Pane name=\"canvas\">\n            {props.children}\n            <div>xyt</div>\n        </Pane>\n    </ReactLeafletMap>\n)\n\nconst createCanvasLayer = (pane?: string) => canvas({ padding: 0, pane })\n\n// type CanvasLayer = undefined | ReturnType<typeof createCanvasLayer>\n\n/* const toLngLat = (map: LeafletMap) => ([x, y]: number[]): number[] => {\n    const point = map.containerPointToLatLng([x, y])\n    return [point.lng, point.lat]\n}\n\nconst fromLngLat = (map: LeafletMap) => ([lng, lat]: number[]): number[] => {\n    const point = map.latLngToContainerPoint([lat, lng])\n    return [point.x, point.y]\n}\n */\nconst Canvas = () => {\n    const context = useLeaflet()\n\n    React.useEffect(() => {\n        if (context.map != null) {\n            const map = context.map\n            const canvasLayer = createCanvasLayer(context.pane)\n            // const mouseCanvasLayer = createCanvasLayer(context.pane)\n            canvasLayer.addTo(context.map)\n            // mouseCanvasLayer.addTo(context.map)\n            // const layer = circle(position, { renderer: canvasLayer, radius: 1000 })\n            // layer.addTo(context.map)\n\n            Object.assign(window, { canvasLayer })\n\n            const elCanvas: HTMLCanvasElement = (canvasLayer as any)._container\n            // const elMouseCanvasLayer: HTMLCanvasElement = (mouseCanvasLayer as any)._container\n\n            const api = withCanvas(elCanvas)\n            const onZoomOrMove = () => {}\n\n            map.dragging.disable()\n            Object.assign(window, { api })\n\n            map.addEventListener('zoom move', onZoomOrMove)\n\n            return () => {\n                map.removeEventListener('zoom move', onZoomOrMove)\n                map.removeLayer(canvasLayer)\n                // map.removeLayer(mouseCanvasLayer)\n                api.done()\n            }\n        }\n    }, [\n        context.map,\n        context.map && context.map.getCenter().lat,\n        context.map && context.map.getCenter().lng,\n    ])\n\n    return null\n}\n\nexport default () => {\n    return (\n        <Map>\n            <Canvas />\n        </Map>\n    )\n}\n","import React from 'react'\nimport logo from './logo.svg'\nimport './App.css'\n\nimport Map from './apps/map'\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\" />\n            </header>\n            <div id=\"map\">\n                <Map />\n            </div>\n        </div>\n    )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}