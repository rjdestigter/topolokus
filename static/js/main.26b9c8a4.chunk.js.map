{"version":3,"sources":["modules/core/types.ts","modules/leaflet/src/utils.ts","modules/core/utils/assert.ts","modules/core/utils/array.ts","modules/core/utils/tuple.ts","modules/core/utils/function.ts","modules/core/utils/transform.ts","modules/core/observables.ts","modules/core/add/events.ts","modules/core/utils/console.ts","modules/core/rbush.ts","modules/core/pencils/marker.ts","modules/core/pencils/polygon.ts","modules/core/pencils/line.ts","modules/core/pencils/resetStyles.ts","modules/core/pencils/cursor.ts","modules/core/pencils/eraser.ts","modules/core/pencils/index.ts","modules/core/selectors.ts","modules/core/add/observables.ts","modules/core/add/pencil.ts","modules/core/legacy/utils.ts","modules/core/index.ts","modules/geojson/index.ts","apps/map/index.tsx","modules/leaflet/src/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["ShapeTypes","StateType","EventTypes","SnapType","translateOffsetOfCanvas","canvas","x","y","style","transform","match","map","str","filter","n","isNaN","tx","toLngLat","lng","lat","point","layerPointToLatLng","fromLngLat","latLngToLayerPoint","createCanvasLayer","pane","padding","isInBBox","bbox","minX","minY","maxX","maxY","isPolygonShape","shape","type","Polygon","isPointShape","Point","isLineShape","Line","emptyArray","head","xs","tuple","a","b","first","second","memoize","f","previousA","previousB","value","Array","isArray","length","polygon2bbox","polygon","reduce","acc","Infinity","inRing","ring","ignoreBoundary","isInside","slice","i","j","xi","yi","xj","yj","k","AddEventTypes","mapMouseEventToOffset","evt","offsetX","offsetY","make","log","$","pipe","tap","stream","call","console","warn","RBush","error","info","RbushClass","polygonToItem","index","Object","assign","insertPolygons","tree","state","polygons","items","count","load","searchByBoundingBox","boundingBox","search","searchByPoint","item","options","insidePoly","inHole","booleanPointInPolygon","window","insert","searchPoint","replace","clear","initialPolygons","ctx","context","beginPath","arc","Math","PI","fillStyle","fill","stroke","closePath","colors","marker","forEach","hx","hy","t","moveTo","lineTo","filled","meta","isSelected","isHovering","id","strokeStyle","lineWidth","lineJoin","line","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","data","getContext","save","setTransform","clearRect","width","height","restore","createPencil","api","finalMarker","defaultMarker","finalPolygon","defaultPolygon","finalLine","defaultLine","cursor","defaultCursor","resetStyles","defaultResetStyles","eraser","mapFirst","mapObservableToPropType","prop","obj","makeFromEventType","eventTypes$","eventType","dispatchedEventType","keyPress$","fromEvent","document","keyPressCode$","keyCode","ofKeyCode","pressedKeyCode","includes","enterKey$","cancelKey$","undoKey$","ctrlKey","mapTo","redoKey$","filterPolygonShapes","shapes","filterLineShapes","filterPointShapes","convertPointShapesToListOfPoints","pointShapes","pointShape","convertLineShapesToListOfPoints","lineShapes","flatMap","lineShape","convertPolygonShapesToListOfPoints","polygonShapes","polygonShape","flat","convertPolygonShapesToListOfLines","next","reverse","last","p","push","convertShapesToListOfPoints","convertShapesToListOfLines","convertListOfLinesToLineString","lineDb","turfMultiLineString","x1","y1","addPolygon","AddPolygon","pencil","from","shapes$","mouseMove$","mouseClick$","dispatchEvent","fromEventType","mouseCtx","addPencil","mousePosition","hovering","undefined","click$","move$","allNewPoints$","merge","scan","event","currentPoints","redoPoints","clone","splice","initial","tail","pressedEnter$","SubmitNewPolygon","pressedCancel$","CancelNewPolygon","dispatchSubmitOrCancelOnKeyPress$","ignoreElements","submit$","withLatestFrom","cancel$","submitOrCancel$","race","take","takeWhile","mergeMap","points","of","payload","findLineSnapPosition","lines","distance","find","poly","x2","y2","xx","yy","C","D","lenSq","param","dx","dy","sqrt","pointToLineDistance","xy","dxy","subscribe","convert","mouseCanvas","config","mousePencil","toPoint","to","pointsDb$","BehaviorSubject","KDBush","polyDb$","createPolyBush","lineDb$","events$","Subject","asObservable","dispatch","mapPointToSnapFn$","combineLatest","startWith","pointsDb","pointSnap","within","lineSnap","multiLineString","maybePoint","nearestPointOnLine","geometry","coordinates","sx","sy","None","shareReplay","updatePointsDb$","polyDb","mouseClickOffset$","e","mapOffset","mouseMoveOffset$","translatedMousemMove$","mousePositionSnapped$","px","py","mapPointToSnap","hoverIndex$","some","selected$","concat","takeUntil","endWith","repeat","add$","makeAddPolygonProgram","snap","draw$","hoverIndices","selectedIndex","selectedPolygon","clear$","addShortCutKey$","noop$","core$","switchMap","plop$","share","done","add","Error","rand","floor","random","ring2points","polygon2shape","multiPolygon2shapes","multiPolygon","feature2shapes","feature","geometry2shapes","featureCollection","features","featureCollection2shapes","isMultiPolygon","geometries2shapes","geometries","geometries$","plop","core","getValue","refresh","Canvas","useLeaflet","React","useState","geojson","useEffect","createPane","canvasLayer","mouseCanvasLayer","addTo","elCanvas","_container","elMouseCanvasLayer","translateOffset","plopGeoJSON","addEventListener","unsubscribe","removeEventListener","removeLayer","plopLeaflet","tileLayer","TileLayer","url","attribution","position","Map","center","zoom","Pane","name","App","className","onClick","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.26b9c8a4.chunk.js","sourcesContent":["import { AddState } from './add/types'\n\n/** Type alias for pixels */\nexport type Pixel = number\n\n/** Type alias for x- and y coordinates */\nexport type Coordinate = number\n\n/**\n * An (x, y) coordiante. The first 2 number represent the pixel\n * cordiantes while the optional second set of numbers are the\n * origina coordiantes. For example longitude and lattitude values.\n *\n * The system preservers the original coordiantes to prevent having\n * to convert them back and forth if they aren't changed.\n */\nexport type Point = [Pixel, Pixel, Coordinate, Coordinate]\n\n/**\n * A list of 2- or more [[Point]]s\n *\n * I would've preferred to tyep it [Point, Point, ...Point[]]\n */\nexport type Line = Point[]\n\n/**\n * A list of list of points where the first element in the list\n * is clockwise and the rest of the list counter clockwise\n * representing holes.\n *\n * I would've preferred to type it: [Point, Point, Point, ...Point[]][]\n * since each ring should have at least 3 points.\n */\nexport type Polygon = Line[]\n\nexport enum ShapeTypes {\n    Point = 'Point',\n    Polygon = 'Polygon',\n    Line = 'Line',\n}\n\nexport type PointShape<T> = {\n    type: ShapeTypes.Point\n    shape: Point\n    meta: T\n}\n\nexport type PolygonShape<T> = {\n    type: ShapeTypes.Polygon\n    shape: Polygon\n    meta: T\n}\n\nexport type LineShape<T> = {\n    type: ShapeTypes.Line\n    shape: Line\n    meta: T\n}\n\nexport type Shape<T> = PointShape<T> | PolygonShape<T> | LineShape<T>\n\nexport enum StateType {\n    Noop = 'Noop',\n    AddPolygon = 'AddPolygon',\n}\n\n// State\nexport interface NoopState {\n    readonly value: StateType.Noop\n}\n\nexport type PossibleStates = NoopState | AddState\nexport type State<T> = PossibleStates\n\n// Actions\nexport enum EventTypes {\n    SelectPolygon = 'SelectPolygon',\n    EditPolygon = 'EditPolygon',\n    RemovePolygon = 'RemovePolygon',\n}\n\nexport type FromPoint = (coordinate: number[]) => Point\nexport type ToPoint = (coordinate: Point | [number, number]) => number[]\nexport type ConvertPoint = { from: FromPoint; to: ToPoint }\n\nexport enum SnapType {\n    Point = 'P',\n    Line = 'L',\n    None = 'M',\n}\n\nexport type SnapPoint = { type: SnapType.Point; point: Point }\nexport type SnapLine = { type: SnapType.Line; point: Point; line: [Point, Point]; distance: number }\nexport type SnapNone = { type: SnapType.None; point: Point }\nexport type Snap = SnapPoint | SnapLine | SnapNone\n","import { Map, canvas } from 'leaflet'\n\nimport { Point } from '../../core/types'\n\n/**\n * ```hs\n * translateOffsetOfCanvas :: HTMLCanvasElement -> (number, number) -> (number, number)\n * ```\n * @param canvas The canvas to adjust the coordinate of\n * @returns Coordinates of a canvas adjusted in relation to it's transformation.\n */\nexport const translateOffsetOfCanvas = (canvas: HTMLCanvasElement) => ([x, y]: [number, number]): [\n    number,\n    number,\n] => {\n    const [tx = 0, ty = 0] = (\n        canvas.style.transform.match(/translate3d\\((-?\\d+)px[, ]+(-?\\d+)px[, ]+(-?\\d+)/) || []\n    )\n        .map(str => +str)\n        .filter(n => !isNaN(n))\n\n    return [x + tx, y + ty] as [number, number]\n}\n\n/**\n * toLngLat :: L.Map -> Point -> (numbr, number)\n * @param canvas\n */\nexport const toLngLat = (map: Map) => ([x, y, lng, lat]: Point | [number, number]): [\n    number,\n    number,\n] => {\n    const point = map.layerPointToLatLng([x, y])\n    return [lng || point.lng, lat || point.lat]\n}\n\n/**\n * fromLngLat :: L.Map -> (number, number) -> Point\n * @param canvas\n */\nexport const fromLngLat = (map: Map) => ([lng, lat]: number[]): Point => {\n    const point = map.latLngToLayerPoint([lat, lng + 0])\n    return [point.x, point.y, lng, lat]\n}\n\n/**\n * createCanvasLayer :: String -> L.Canvas\n * @param canvas\n */\nexport const createCanvasLayer = (pane?: string) => canvas({ padding: 0, pane })\n","import { Point, ShapeTypes, Shape, PointShape, PolygonShape, LineShape, Line } from '../types'\n\nexport const hasProp = <K extends string>(prop: K) => <U, T extends { [P in K]: U }>(obj: T) =>\n    obj[prop]\n\ntype BBox = {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n}\n\nexport const isInBBox = (point: Point, bbox: BBox) =>\n    bbox.minX <= point[0] && bbox.minY <= point[1] && bbox.maxX >= point[0] && bbox.maxY >= point[1]\n\n/** Asserts if the given shape is of type [[PolygonShape]] */\nexport const isPolygonShape = <T>(shape: Shape<T>): shape is PolygonShape<T> =>\n    shape.type === ShapeTypes.Polygon\n\n/** Asserts if the given shape is of type [[PointShape]] */\nexport const isPointShape = <T>(shape: Shape<T>): shape is PointShape<T> =>\n    shape.type === ShapeTypes.Point\n\n/** Asserts if the given shape is of type [[LineShape]] */\nexport const isLineShape = <T>(shape: Shape<T>): shape is LineShape<T> =>\n    shape.type === ShapeTypes.Line\n\nexport const isEqual = <A, B extends A>(value: A) => (compare: B) => value === compare\n\nexport const isNotOfTypeNbr = <T>(value: number | T): value is T => typeof value !== 'number'\n\nexport const isPolygon = (points?: Point[]): points is Line => points != null && points.length > 2\n","export const emptyArray: any[] = []\n\n/** Return everything but the last element in an array. */\nexport const initial = <T>(xs: T[]) => {\n    const clone = [...xs]\n    clone.splice(xs.length - 1, 1)\n    return clone\n}\n\n/** Return everything but the first element in array. */\nexport const tail = <T>(xs: T[]) => {\n    const [_, ...t] = xs\n    return t\n}\n\n/** Retrun the first element in an array. */\nexport const head = <T extends any[]>(\n    xs: T,\n): T extends [infer U, ...any[]] ? T[0] : T[0] | undefined => {\n    const [h] = xs\n    return h\n}\n\n/** Time */\nexport const last = <T>(xs: T[]) => {\n    const [l] = [...xs].reverse()\n    return l\n}\n\nexport const isNotEmpty = <T>(array: T[]): array is [T, ...T[]] => array.length > 0\n\nexport const returnEmptyArray = <T>(value: T): T =>\n    Array.isArray(value) && value.length <= 0 ? (emptyArray as any) : value\n","/** Converts value a and b into a tuple */\nexport const tuple = <A, B>(a: A, b: B): [A, B] => [a, b]\n\n/** Returns the first element of a tuple */\nexport const first = <A>([a]: [A, any]): A => a\n\n/** Returns the second element of a tuple */\nexport const second = <B>([, b]: [any, B]): B => b\n\n/** Flipts the tuple */\nexport const flipTuple = <A, B>([a, b]: [A, B]) => tuple(b, a)\n","import { returnEmptyArray } from './array'\n\nexport const memoize = <A, B>(f: (a: A) => B) => {\n    let previousA: A | undefined\n    let previousB: B | undefined\n\n    return (a: A): B => {\n        if (a !== previousA) {\n            previousA = a\n            previousB = f(a)\n        }\n\n        return returnEmptyArray(previousB as B)\n    }\n}\n\n/**\n * ```hs\n * compose :: (b -> c) -> (a -> b) -> c\n * ```\n * Read as \"f\" after \"g\"\n * @typeparam A The first function argument taken.\n * @typeparam B The result type of function `g` and argument for function `f`\n * @typeparam C The result type of function `f`\n * @params f The function to pass the result of function `g` to\n * @params g Function that computes the first result `B`\n * @returns A function that takes `A` and returns `C` by applying output of `g` to `f`\n *\n * Function composition. f after g. g andThen f\n */\nexport const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (a: A) => f(g(a))\n\n/**\n * ```hs\n * flip :: (a -> b -> c) -> (b -> a -> c)\n * ```\n * @param f\n */\nexport const flip = <A, B, C>(f: (a: A, b: B) => C) => (b: B, a: A) => f(a, b)\n\n/**\n * TODO\n * @param f\n */\nexport const curry = <A, B, C>(f: (a: A, b: B) => C) => (a: A) => (b: B) => f(a, b)\n","import { Polygon, Point, Line } from '../types'\nimport { isInBBox } from './assert'\n\nexport const polygon2bbox = (polygon: Polygon) =>\n    polygon[0].reduce(\n        (acc, [x, y]) => {\n            if (x < acc.minX) acc.minX = x\n            if (y < acc.minY) acc.minY = y\n            if (acc.maxX === Infinity || x > acc.maxX) acc.maxX = x\n            if (acc.maxY === Infinity || y > acc.maxY) acc.maxY = y\n            return acc\n        },\n        {\n            minX: Infinity,\n            minY: Infinity,\n            maxX: Infinity,\n            maxY: Infinity,\n        },\n    )\n\n/**\n *\n */\nexport function booleanPointInPolygon(\n    point: Point,\n    polygon: Polygon,\n    options: {\n        ignoreBoundary?: boolean\n    } = {},\n) {\n    const bbox = polygon2bbox(polygon)\n\n    // Quick elimination if point is not inside bbox\n    if (isInBBox(point, bbox) === false) {\n        return false\n    }\n\n    let insidePoly = false\n\n    if (inRing(point, polygon[0], options.ignoreBoundary)) {\n        let inHole = false\n        let k = 1\n        // check for the point in any of the holes\n        while (k < polygon.length && !inHole) {\n            if (inRing(point, polygon[k], !options.ignoreBoundary)) {\n                inHole = true\n            }\n            k++\n        }\n        if (!inHole) {\n            insidePoly = true\n        }\n    }\n\n    return insidePoly\n}\n\nfunction inRing(point: Point, ring: Line, ignoreBoundary?: boolean) {\n    let isInside = false\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1)\n    }\n\n    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        const xi = ring[i][0]\n        const yi = ring[i][1]\n        const xj = ring[j][0]\n        const yj = ring[j][1]\n        const onBoundary =\n            point[1] * (xi - xj) + yi * (xj - point[0]) + yj * (point[0] - xi) === 0 &&\n            (xi - point[0]) * (xj - point[0]) <= 0 &&\n            (yi - point[1]) * (yj - point[1]) <= 0\n        if (onBoundary) {\n            return !ignoreBoundary\n        }\n        const intersect =\n            yi > point[1] !== yj > point[1] &&\n            point[0] < ((xj - xi) * (point[1] - yi)) / (yj - yi) + xi\n        if (intersect) {\n            isInside = !isInside\n        }\n    }\n\n    return isInside\n}\n\nexport const mapMouseEventToOffset = (evt: MouseEvent): [number, number] => [\n    evt.offsetX,\n    evt.offsetY,\n]\n\nexport const mapProp = <K extends string>(prop: K) => <T extends { [P in K]: T[K] }>(obj: T) =>\n    obj[prop]\n","import { fromEvent, Observable } from 'rxjs'\nimport { map, filter, mapTo } from 'rxjs/operators'\n\nimport { Event, EventType } from './events'\n\nimport { mapProp, first } from './utils'\n\nexport const mapFirst = map(first)\n\n/**\n *\n */\nexport const mapObservableToProp = <K extends string>(k: K) => <T extends { [P in K]: T[K] }>(\n    $: Observable<T>,\n): Observable<T[K]> => $.pipe(map(mapProp(k)))\n\nexport const mapObservableToPropType = mapObservableToProp('type')\n\ntype EventTypes = Event['type']\n/**\n *\n */\nexport const makeFromEventType = <E extends EventTypes>(eventTypes$: Observable<E>) => <\n    T extends E\n>(\n    eventType: T,\n) =>\n    eventTypes$.pipe(\n        filter(\n            (dispatchedEventType): dispatchedEventType is T => eventType === dispatchedEventType,\n        ),\n    )\n\n/**\n *\n */\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress')\n/**\n *\n */\nexport const keyPressCode$ = keyPress$.pipe(map(evt => evt.keyCode))\n\n/**\n *\n */\nexport const ofKeyCode = (keyCode: number | number[]) =>\n    keyPressCode$.pipe(\n        filter(pressedKeyCode =>\n            Array.isArray(keyCode) ? keyCode.includes(pressedKeyCode) : pressedKeyCode === keyCode,\n        ),\n    )\n\n/**\n *\n */\nexport const enterKey$ = ofKeyCode(13)\n\n/**\n *\n */\nexport const cancelKey$ = ofKeyCode(99)\n\nexport const undoKey$ = keyPress$\n    .pipe(filter(evt => evt.ctrlKey && [122, 90, 26].includes(evt.keyCode)))\n    .pipe(mapTo('undo' as const))\n\nexport const redoKey$ = keyPress$\n    .pipe(filter(evt => evt.ctrlKey && [121, 89, 25].includes(evt.keyCode)))\n    .pipe(mapTo('redo' as const))\n","import { Point, Polygon } from '../types'\n\n/**\n * Event type descriptors for the \"Add Polygon\" process\n */\nexport enum AddEventTypes {\n    AddPolygon = 'AddPolygon',\n    SubmitNewPolygon = 'SubmitNewPolygon',\n    CancelNewPolygon = 'CancelNewPolygon',\n}\n\n/**\n * Event dispatched when the user wants to add a new polygon.\n */\nexport type AddPolygonEvent = {\n    type: AddEventTypes.AddPolygon\n}\n\n/**\n * Event dispatched when the user has finished creating a new polygon.\n */\nexport type SubmitNewPolygonEvent = {\n    type: AddEventTypes.SubmitNewPolygon\n}\n\n/**\n * Event dispatched when the user wants to cancel creating a new polygon.\n */\nexport type CancelNewPolygonEvent = {\n    type: AddEventTypes.CancelNewPolygon\n}\n\n/**\n * All possible events for the \"Add poloygon\" process\n */\nexport type AddEvent = AddPolygonEvent | SubmitNewPolygonEvent | CancelNewPolygonEvent\n\n/**\n * Event creator instructing the program the user wants to create a new polygon.\n */\nexport const addPolygon = (): AddPolygonEvent => ({ type: AddEventTypes.AddPolygon })\n\n/**\n * Event creator instructing the program the user has finished creating a new polygon.\n */\nexport const submitNewPolygon = (): SubmitNewPolygonEvent => ({\n    type: AddEventTypes.SubmitNewPolygon,\n})\n\n/**\n * Event creator instructing the program the user wants to cancel creating a new polygon.\n */\nexport const cancelNewPolygon = (): CancelNewPolygonEvent => ({\n    type: AddEventTypes.CancelNewPolygon,\n})\n","import { Observable } from 'rxjs'\nimport { tap } from 'rxjs/operators'\n\nconst make = (log: (...args: any[]) => void) => <T>($: Observable<T>) =>\n    $.pipe(\n        tap(stream => {\n            log.call(console, stream)\n        }),\n    )\n\nexport const warn = make(console.warn)\nexport const error = make(console.error)\nexport const log = make(console.log)\nexport const info = make(console.info)\n","import * as _ from 'lodash'\n\n// @ts-ignore\nimport RbushClass from 'rbush/index'\n\nimport { Polygon, Point } from './types'\n\nimport { polygon2bbox, booleanPointInPolygon } from './utils'\n\ntype RBush<T = {}> = new (...args: any) => rbush.RBush<T>\n\nconst RBush: RBush = RbushClass\n\nconst polygonToItem = (polygon: Polygon, index: number) =>\n    Object.assign(polygon2bbox(polygon), { polygon, index })\n\ntype Item = ReturnType<typeof polygonToItem>\ntype Tree = rbush.RBush<Item>\n\nconst insertPolygons = (tree: Tree, state: { count: number }) => (polygons: Polygon[]) => {\n    const items = polygons.map((polygon, index) => {\n        return polygonToItem(polygon, index + state.count + 1)\n    })\n    state.count += polygons.length\n    tree.load(items)\n}\n\nconst insertPolgyon = (tree: rbush.RBush<Item>, state: { count: number }) => (polygon: Polygon) => {\n    state.count += 1\n    tree.insert(polygonToItem(polygon, state.count))\n}\n\nconst searchByBoundingBox = (tree: Tree) => (boundingBox: rbush.BBox) => tree.search(boundingBox) // .map(item => item.polygon)\n\nconst searchByPoint = (tree: Tree) => {\n    const search = searchByBoundingBox(tree)\n\n    return ([x, y, a, b]: Point) => {\n        const items = search({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y,\n        })\n\n        return items.filter(item => booleanPointInPolygon([x, y, a, b], item.polygon))\n    }\n}\n\nexport default (...initialPolygons: Polygon[]) => {\n    const tree: rbush.RBush<Item> = new RBush() as any\n    Object.assign(window, { tree })\n    const state = { count: -1 }\n\n    const insert = insertPolygons(tree, state)\n    const search = searchByBoundingBox(tree)\n    const searchPoint = searchByPoint(tree)\n\n    const replace = (polygons: Polygon[]) => {\n        state.count = -1\n        tree.clear()\n        insert(polygons)\n    }\n    insert(initialPolygons)\n\n    return {\n        insert,\n        search,\n        searchPoint,\n        replace,\n    }\n}\n","import { PointShape } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (point: PointShape<any>, context = ctx) => {\n    context.beginPath()\n    context.arc(point.shape[0], point.shape[1], 5, 0, 2 * Math.PI)\n    context.fillStyle = '#fff'\n    context.fill()\n    context.stroke()\n    context.closePath()\n}\n","import { PointShape, PolygonShape, ShapeTypes } from '../types'\n\nconst colors = [\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n]\n\ntype Meta = { id: number; isHovering?: boolean; isSelected?: boolean }\n\ntype MarkerPencil<T extends Meta> = (point: PointShape<T>, ctx?: CanvasRenderingContext2D) => void\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default <T extends Meta>(marker: MarkerPencil<T>) => (ctx: CanvasRenderingContext2D) => (\n    polygon: PolygonShape<T>,\n    context = ctx,\n) => {\n    //\n    context.beginPath()\n\n    polygon.shape.forEach(ring => {\n        const [[hx, hy], ...t] = ring\n\n        context.moveTo(hx, hy)\n\n        t.forEach(([x, y]) => {\n            context.lineTo(x, y)\n        })\n        context.closePath()\n    })\n\n    const filled = polygon.meta.isSelected || polygon.meta.isHovering\n\n    context.fillStyle =\n        (colors[polygon.meta.id] && colors[polygon.meta.id](filled ? 1 : 0.5)) ||\n        `rgba(255, 255, 255, ${filled ? 1 : 0.5})`\n    context.strokeStyle =\n        (colors[polygon.meta.id] && colors[polygon.meta.id](1)) || `rgba(255, 255, 255, 1)`\n\n    context.lineWidth = 1\n    context.lineJoin = 'round'\n\n    context.fill()\n\n    context.stroke()\n\n    // if (polygon.meta.isSelected)\n    //     polygon.shape.forEach(ring =>\n    //         ring.forEach(point =>\n    //             marker({ shape: point, meta: polygon.meta, type: ShapeTypes.Point }, context),\n    //         ),\n    //     )\n}\n","import { PointShape, LineShape, ShapeTypes } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: PointShape<any>, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (line: LineShape<any>, context = ctx) => {\n    context.beginPath()\n\n    const [[hx, hy], ...t] = line.shape\n\n    context.moveTo(hx, hy)\n\n    t.forEach(([x, y]) => {\n        context.lineTo(x, y)\n    })\n\n    context.stroke()\n\n    line.shape.forEach(point =>\n        marker({ type: ShapeTypes.Point, shape: point, meta: line.meta }, context),\n    )\n}\n","export default (ctx: CanvasRenderingContext2D) => () => {\n    ctx.fillStyle = '#ffffff'\n    ctx.strokeStyle = '#000000'\n    ctx.lineWidth = 1\n    ctx.shadowBlur = 0\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'\n}\n","import { Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (data: {\n    type: 'P' | 'M' | 'L'\n    point: Point\n}) => {\n    const [x, y] = data.point\n    ctx.fillStyle = 'transparent'\n    ctx.lineWidth = 1\n\n    ctx.beginPath()\n    ctx.arc(x, y, 1, 0, 2 * Math.PI)\n    ctx.stroke()\n    ctx.fill()\n    ctx.closePath()\n\n    ctx.lineWidth = 2\n    ctx.strokeStyle =\n        // if\n        data.type === 'P'\n            ? // then\n              'Yellow'\n            : // else if\n            data.type === 'L'\n            ? // then\n              'Cyan'\n            : // else\n              'Black'\n\n    ctx.beginPath()\n    ctx.arc(x, y, 15, 0, 2 * Math.PI)\n    ctx.stroke()\n    ctx.fill()\n    ctx.closePath()\n}\n","export default (canvas: HTMLCanvasElement) => () => {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx) {\n        ctx.save()\n\n        // Use the identity matrix while clearing the canvas\n        ctx.setTransform(1, 0, 0, 1, 0, 0)\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n        ctx.restore()\n    }\n}\n","import defaultMarker from './marker'\nimport defaultPolygon from './polygon'\nimport defaultLine from './line'\nimport defaultResetStyles from './resetStyles'\nimport defaultCursor from './cursor'\nimport eraser from './eraser'\n\ninterface Api {\n    marker: typeof defaultMarker\n    polygon: typeof defaultPolygon\n    line: typeof defaultLine\n    cursor: typeof defaultCursor\n    resetStyles: typeof defaultResetStyles\n}\n\nexport const createPencil = (api: Partial<Api> = {}) => (canvas: HTMLCanvasElement) => {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx) {\n        const finalMarker = (api.marker || defaultMarker)(ctx)\n        const finalPolygon = (api.polygon || defaultPolygon)(finalMarker)(ctx)\n        const finalLine = (api.line || defaultLine)(finalMarker)(ctx)\n        const cursor = (api.cursor || defaultCursor)(ctx)\n        const resetStyles = (api.resetStyles || defaultResetStyles)(ctx)\n\n        return {\n            marker: finalMarker,\n            polygon: finalPolygon,\n            line: finalLine,\n            resetStyles,\n            cursor,\n            eraser: eraser(canvas),\n            api: {\n                marker: defaultMarker,\n                polygon: defaultPolygon(finalMarker),\n                line: defaultLine(finalMarker),\n                resetStyles: defaultResetStyles,\n                cursor: defaultCursor,\n                eraser,\n            },\n        }\n    }\n\n    throw '1'\n}\n\nexport type Pencil = ReturnType<ReturnType<typeof createPencil>>\n\nexport default createPencil\n","import { State, Point, Shape, StateType, PointShape, LineShape, PolygonShape } from './types'\nimport { memoize, isPolygonShape, isPointShape, isLineShape, emptyArray, last } from './utils'\nimport { multiLineString as turfMultiLineString } from '@turf/helpers'\n\n/**\n * From `[Polygon, T] -> [Polygon]\n */\nexport const filterPolygonShapes = memoize(<T>(shapes: Shape<T>[]): PolygonShape<T>[] =>\n    shapes.filter(isPolygonShape),\n)\n\n/** TODO */\nexport const filterLineShapes = memoize(<T>(shapes: Shape<T>[]): LineShape<T>[] =>\n    shapes.filter(isLineShape),\n)\n\n/** TODO */\nexport const filterPointShapes = memoize(<T>(shapes: Shape<T>[]): PointShape<T>[] =>\n    shapes.filter(isPointShape),\n)\n\n/**\n * Redduces a list of [[PointShape]] into a list of points\n */\nexport const convertPointShapesToListOfPoints = memoize(<T>(pointShapes: PointShape<T>[]) =>\n    pointShapes.map(pointShape => pointShape.shape),\n)\nexport const convertLineShapesToListOfPoints = memoize(<T>(lineShapes: LineShape<T>[]) =>\n    lineShapes.flatMap(lineShape => lineShape.shape),\n)\nexport const convertPolygonShapesToListOfPoints = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape => polygonShape.shape.flat()),\n)\nexport const convertPolygonShapesToListOfLines = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape =>\n        polygonShape.shape.flatMap(ring => {\n            const [a, b, ...c] = ring\n            return c.reduce(\n                (acc, next) => {\n                    if (acc.length > 0) {\n                        const [, p] = last(acc)\n                        acc.push([p, next])\n                    }\n                    return acc\n                },\n                [[a, b]] as [Point, Point][],\n            )\n        }),\n    ),\n)\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfPoints = memoize(<T>(shapes: Shape<T>[]): Point[] => [\n    ...convertPointShapesToListOfPoints(filterPointShapes(shapes)),\n    ...convertLineShapesToListOfPoints(filterLineShapes(shapes)),\n    ...convertPolygonShapesToListOfPoints(filterPolygonShapes(shapes)),\n])\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfLines = memoize(<T>(shapes: Shape<T>[]): [Point, Point][] =>\n    convertPolygonShapesToListOfLines(filterPolygonShapes(shapes)),\n)\n\nexport const convertListOfLinesToLineString = memoize((lineDb: [Point, Point][]) =>\n    turfMultiLineString(\n        lineDb.flatMap(([a, b]) => {\n            if (a.length === 4 && b.length === 4) {\n                const [, , x1, y1] = a\n                const [, , x2, y2] = b\n\n                return [[[x1, y1], [x2, y2]]]\n            }\n\n            return []\n        }),\n    ),\n)\n","import { Observable, concat, merge, of, race, combineLatest, Subject } from 'rxjs'\nimport {\n    take,\n    tap,\n    filter,\n    scan,\n    mapTo,\n    takeWhile,\n    map,\n    ignoreElements,\n    withLatestFrom,\n    last,\n    mergeMap,\n} from 'rxjs/operators'\n\nimport { cancelKey$, enterKey$, undoKey$, redoKey$ } from '../observables'\nimport { AddEventTypes, AddEvent } from './events'\nimport { Point, Snap, FromPoint, Shape } from '../types'\nimport { Event } from '../events'\nimport { initial, head, tail, first, tuple, second, isNotEmpty } from '../utils'\nimport { Pencil } from '../pencils'\n\nimport createPencil from './pencil'\n\n/**\n * Creates a program for adding new polygons.\n */\nexport default <T>({\n    pencil,\n    from,\n    shapes$,\n    mouseMove$,\n    mouseClick$,\n    dispatchEvent,\n    fromEventType,\n    mouseCtx,\n}: {\n    pencil: Pencil\n    mouseCtx: CanvasRenderingContext2D\n    from: FromPoint\n    shapes$: Observable<Shape<T>[]>\n    mouseMove$: Observable<Snap>\n    mouseClick$: Observable<Point>\n    dispatchEvent: <E extends Event>($: Observable<E>) => Observable<Event>\n    fromEventType: <E extends AddEvent['type']>(eventType: E) => Observable<E>\n}) => {\n    const addPencil = createPencil(pencil)(mouseCtx)\n\n    const click$ = mouseClick$.pipe(\n        map(point => ({\n            type: 'click' as const,\n            point,\n        })),\n    )\n    const move$ = mouseMove$.pipe(\n        map(point => ({\n            type: 'move' as const,\n            point,\n        })),\n    )\n\n    const allNewPoints$ = merge(\n        click$,\n        move$,\n        undoKey$.pipe(map(type => ({ type }))),\n        redoKey$.pipe(map(type => ({ type }))),\n        shapes$.pipe(mapTo({ type: 'shapes' as const })),\n    ).pipe(\n        scan(\n            ([currentPoints, redoPoints], event) =>\n                // if\n                event.type === 'click'\n                    ? // then\n                      tuple([...currentPoints, event.point], [])\n                    : // else if\n                    event.type === 'undo' && currentPoints.length > 0\n                    ? // then\n                      tuple(initial(currentPoints), [\n                          currentPoints[currentPoints.length - 1],\n                          ...redoPoints,\n                      ])\n                    : // else if\n                    event.type === 'redo' && isNotEmpty(redoPoints)\n                    ? // then\n                      tuple([...currentPoints, head(redoPoints)], tail(redoPoints))\n                    : // else if\n                    event.type === 'shapes'\n                    ? // then\n                      tuple(currentPoints.map(([, , lng, lat]) => from([lng, lat])), [])\n                    : // else\n                      tuple(currentPoints, []),\n            tuple<Point[], Point[]>([], []),\n        ),\n        map(first),\n    )\n\n    const pressedEnter$ = enterKey$.pipe(\n        mapTo({ type: AddEventTypes.SubmitNewPolygon as const }),\n        dispatchEvent,\n    )\n\n    const pressedCancel$ = cancelKey$.pipe(\n        mapTo({ type: AddEventTypes.CancelNewPolygon as const }),\n        dispatchEvent,\n    )\n\n    const dispatchSubmitOrCancelOnKeyPress$ = merge(pressedCancel$, pressedEnter$).pipe(\n        ignoreElements(),\n    )\n\n    const submit$ = fromEventType(AddEventTypes.SubmitNewPolygon).pipe(\n        withLatestFrom(allNewPoints$),\n        filter(stream => second(stream).length > 2),\n        map(first),\n    )\n\n    const cancel$ = fromEventType(AddEventTypes.CancelNewPolygon)\n\n    const submitOrCancel$ = race(submit$, cancel$).pipe(take(1))\n\n    const points$ = merge(\n        dispatchSubmitOrCancelOnKeyPress$,\n        merge(submitOrCancel$, allNewPoints$),\n    ).pipe(\n        withLatestFrom(mouseMove$),\n        tap(([stream, mousePosition]) => {\n            Array.isArray(stream) && addPencil(mousePosition, stream)\n        }),\n        map(first),\n        scan(\n            (acc, next) => (Array.isArray(next) ? tuple(next, acc[1]) : tuple(acc[0], next)),\n            tuple([] as Point[], AddEventTypes.AddPolygon) as [Point[], AddEventTypes],\n        ),\n        takeWhile(([, event]) => event === AddEventTypes.AddPolygon, true),\n        last(),\n        mergeMap(([points, outcome]) =>\n            outcome === AddEventTypes.SubmitNewPolygon\n                ? of({ type: AddEventTypes.SubmitNewPolygon as const, payload: points })\n                : of(void 0).pipe(ignoreElements()),\n        ),\n    )\n\n    return points$\n}\n","import { Pencil } from '../pencils'\nimport { Point, ShapeTypes, Snap, SnapType } from '../types'\n\nexport default (pencil: Pencil) => (ctx: CanvasRenderingContext2D) => (\n    mousePosition: Snap,\n    polygon: Point[],\n) => {\n    pencil.eraser()\n\n    // Draw potential new polygon\n    // if (state.value === StateType.AddPolygon) {\n    if (polygon.length > 1) {\n        pencil.polygon({\n            type: ShapeTypes.Polygon,\n            shape: [[...polygon, mousePosition.point]],\n            // TODO Provide a way to create T for new polygons\n            meta: { id: -1, hovering: true },\n        })\n\n        pencil.resetStyles()\n    } else if (polygon.length === 1) {\n        pencil.line({\n            type: ShapeTypes.Line,\n            shape: [...polygon, mousePosition.point],\n            meta: undefined as any,\n        })\n        pencil.resetStyles()\n    }\n\n    polygon.forEach(point =>\n        pencil.marker({\n            type: ShapeTypes.Point,\n            shape: point,\n            meta: {},\n        }),\n    )\n\n    if (mousePosition.type === SnapType.Line) {\n        ctx.beginPath()\n        ctx.moveTo(mousePosition.line[0][0], mousePosition.line[0][1])\n        ctx.lineTo(mousePosition.line[1][0], mousePosition.line[1][1])\n        ctx.strokeStyle = 'Cyan'\n        ctx.stroke()\n        // ctx\n    }\n\n    pencil.cursor(mousePosition)\n}\n","import _ from 'lodash'\n\nimport {\n    AllGeoJSON,\n    Feature,\n    FeatureCollection,\n    GeoJSONObject,\n    Geometries,\n    GeometryCollection,\n    MultiPolygon,\n    Polygon,\n    Position,\n    Types as GeoJSONTypes,\n} from '@turf/helpers'\n\nimport {\n    PolyLike,\n    PositionLike,\n    QFeature,\n    QFeatureCollection,\n    QMultiPolygon,\n    QPolygon,\n    QPolyLike,\n    QPosition,\n} from './types'\nimport { Point } from '../types'\n\ntype Project = (xy: number[]) => number[]\n\ninterface Collect {\n    coordinates: QPosition[]\n    lines: [QPosition, QPosition][]\n}\n\nconst defaultCollect = (): Collect => ({ coordinates: [], lines: [] })\n\nexport const pointPixelsAreEqual = ([x1, y1]: PositionLike, [x2, y2]: PositionLike): boolean => {\n    console.log(`${x1} === ${x2} && ${y1} === ${y2}`)\n    const eq = _.isEqual([x1, y1], [x2, y2])\n    console.log('Eq: ' + eq)\n    return eq\n}\n\nexport const projectGeometry = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Polygon | MultiPolygon,\n): QPolygon | QMultiPolygon => {\n    switch (geom.type) {\n        case 'MultiPolygon':\n            return projectMultiPolygon(project)(collect)(geom)\n        case 'Polygon':\n            return projectPolygon(project)(collect)(geom)\n        default:\n            return geom\n    }\n}\n\nexport const projectGeoJSON = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: PolyLike,\n): QPolyLike => {\n    switch (geom.type) {\n        case 'FeatureCollection':\n            return projectFeatureCollection(project)(collect)(geom as any)\n        case 'Feature':\n            return projectFeature(project)(collect)(geom)\n        // case 'GeometryCollection':\n        //   return projectGeometryCollection(project)(collect)(geom)\n        default:\n            return projectGeometry(project)(collect)(geom)\n    }\n}\n\nexport const projectFeature = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Feature<Polygon | MultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    geometry: projectGeometry(project)(collect)(geom.geometry),\n})\n\nexport const projectFeatureCollection = (project: Project) => (\n    collect: Collect = defaultCollect(),\n) => (\n    geom: FeatureCollection<Polygon | MultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    features: geom.features.map(projectFeature(project)(collect)),\n})\n\n// export const projectGeometryCollection = (project: Project) => (collect: Collect = defaultCollect()) => (\n//   geom: any\n// ): GeometryCollection => ({\n//   ...geom,\n//   geometries: geom.geometries.map(projectGeometry(project)(collect))\n// })\n\nexport const projectMultiPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: MultiPolygon,\n): QMultiPolygon => ({\n    ...polygon,\n    coordinates: polygon.coordinates.map(poly => poly.map(projectPositions(project)(collect))),\n})\n\nexport const projectPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: Polygon,\n): QPolygon => {\n    return {\n        ...polygon,\n        coordinates: polygon.coordinates.map(projectPositions(project)(collect)),\n    }\n}\n\nexport const projectPositions = (project: Project) => (collect: Collect = defaultCollect()) => (\n    coords: Position[],\n): QPosition[] =>\n    coords.map((coord, index) => {\n        const projected = project(coord)\n\n        const point: QPosition = [projected[0], projected[1], coord[0], coord[1]]\n        collect.coordinates.push(point)\n\n        if (index > 0) {\n            collect.lines.push([collect.coordinates[collect.coordinates.length - 2], point])\n\n            if (index === coords.length - 1) {\n                collect.lines.push([\n                    point,\n                    collect.coordinates[collect.coordinates.length - coords.length],\n                ])\n            }\n        }\n\n        return point\n    })\n\nexport const pointToLineDistance = ([x, y]: number[], [[x1, y1], [x2, y2]]: number[][]) => {\n    const A = x - x1\n    const B = y - y1\n    const C = x2 - x1\n    const D = y2 - y1\n\n    const dot = A * C + B * D\n    const lenSq = C * C + D * D\n    let param = -1\n    if (lenSq !== 0) {\n        // in case of 0 length line\n        param = dot / lenSq\n    }\n\n    let xx: number\n    let yy: number\n\n    if (param < 0) {\n        xx = x1\n        yy = y1\n    } else if (param > 1) {\n        xx = x2\n        yy = y2\n    } else {\n        xx = x1 + param * C\n        yy = y1 + param * D\n    }\n\n    const dx = x - xx\n    const dy = y - yy\n    return [[xx, yy], Math.sqrt(dx * dx + dy * dy)] as [number[], number]\n}\n\n/**\n *\n * @param position\n * @param lines\n */\nexport const findLineSnapPosition = (\n    [x, y, lng, lat]: [number, number, number, number],\n    lines: [[number, number, number, number], [number, number, number, number]][],\n) => {\n    let point: [number, number] | undefined\n    let distance = -1\n    let line: [[number, number, number, number], [number, number, number, number]] | undefined\n\n    lines.find((poly): boolean => {\n        const [[x1, y1, lng1, lat1], [x2, y2, lng2, lat2]] = poly\n        const [xy, dxy] = pointToLineDistance([x, y], [[x1, y1], [x2, y2]])\n\n        if (dxy <= 5) {\n            point = xy as [number, number]\n            distance = dxy\n            line = poly\n\n            return true\n        }\n\n        return false\n    })\n\n    if (distance >= 0 && point != null && line != null) {\n        return { point, distance, line }\n    }\n\n    return undefined\n}\n\nconst fromQPosition2Position = ([, , lng, lat]: QPosition): Position => [lng, lat]\n\nconst fromQPositions2Positions = (qPositions: QPosition[]): Position[] =>\n    qPositions.map(fromQPosition2Position)\n\nconst fromQPositionsSets2PositionsSets = (sets: QPosition[][]): Position[][] =>\n    sets.map(fromQPositions2Positions)\n\nconst fromQPolygon2Polygon = (qPolygon: QPolygon): Polygon => {\n    return {\n        ...qPolygon,\n        coordinates: fromQPositionsSets2PositionsSets(qPolygon.coordinates),\n    }\n}\n\nconst fromQMultiPolygon2MultiPolygon = (qMultiPolygon: QMultiPolygon): MultiPolygon => {\n    return {\n        ...qMultiPolygon,\n        coordinates: qMultiPolygon.coordinates.map(fromQPositionsSets2PositionsSets),\n    }\n}\n\nconst fromQGeometry2Geometry = (geometry: QPolygon | QMultiPolygon) => {\n    if (geometry.type === 'MultiPolygon') {\n        return fromQMultiPolygon2MultiPolygon(geometry)\n    }\n\n    return fromQPolygon2Polygon(geometry)\n}\n\nconst fromQFeature2Feature = (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): Feature<Polygon | MultiPolygon> => {\n    return {\n        ...feature,\n        geometry: fromQGeometry2Geometry(feature.geometry),\n    }\n}\n\nexport const fromQLikeToPolyLike = (qLike: QPolyLike): PolyLike => {\n    if (qLike.type === 'FeatureCollection') {\n        return {\n            ...qLike,\n            features: qLike.features.map(fromQFeature2Feature),\n        }\n    } else if (qLike.type === 'Feature') {\n        return fromQFeature2Feature(qLike)\n    }\n\n    return fromQGeometry2Geometry(qLike)\n}\n\nexport const mapGeometry = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (geometry: QPolygon | QMultiPolygon): QPolygon | QMultiPolygon => {\n    const nextGeometry = f(geometry)\n\n    if (nextGeometry !== geometry) {\n        return nextGeometry\n    }\n\n    return geometry\n}\n\nexport const mapFeature = (f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon) => (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => {\n    const nextGeometry = f(feature.geometry)\n\n    if (nextGeometry !== feature.geometry) {\n        return {\n            ...feature,\n            geometry: nextGeometry,\n        }\n    }\n\n    return feature\n}\n\nexport const mapFeatureCollection = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (\n    featureCollection: QFeatureCollection<QPolygon | QMultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => {\n    const nextFeatures: QFeature<QPolygon | QMultiPolygon>[] = []\n    let didChange = false\n\n    featureCollection.features.forEach(feature => {\n        const nextFeature = mapFeature(f)(feature)\n\n        if (nextFeature !== feature) {\n            didChange = true\n            nextFeatures.push(nextFeature)\n        }\n    })\n\n    if (didChange) {\n        return {\n            ...featureCollection,\n            features: nextFeatures,\n        }\n    }\n\n    return featureCollection\n}\n\nexport const mapPolyLike = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (polyLike: QPolyLike): QPolyLike => {\n    if (polyLike.type === 'Feature') {\n        return mapFeature(f)(polyLike)\n    } else if (polyLike.type === 'FeatureCollection') {\n        return mapFeatureCollection(f)(polyLike)\n    }\n\n    return mapGeometry(f)(polyLike)\n}\n\nexport const injectLineSnapPosition = (\n    ring: QPosition[],\n    line: [QPosition, QPosition],\n    point: QPosition,\n) => {\n    let didInject = false\n\n    const nextRing = ring.reduce(\n        (acc, coord) => {\n            const previous = acc[acc.length - 1]\n\n            if (\n                didInject === false &&\n                previous &&\n                pointPixelsAreEqual(previous, line[0]) &&\n                pointPixelsAreEqual(coord, line[1])\n            ) {\n                didInject = true\n                acc.push(point, coord)\n            } else {\n                acc.push(coord)\n            }\n\n            return acc\n        },\n        [] as QPosition[],\n    )\n\n    return { didInject, ring: nextRing }\n}\n\nexport const mapMouseEventToCoords = (evt: MouseEvent): [number, number] => [\n    evt.offsetX,\n    evt.offsetY,\n]\n","import {\n    fromEvent,\n    merge,\n    Subject,\n    Observable,\n    of,\n    combineLatest,\n    observable,\n    BehaviorSubject,\n    concat,\n    race,\n    empty,\n} from 'rxjs'\nimport {\n    map,\n    tap,\n    repeat,\n    filter,\n    scan,\n    mapTo,\n    switchMap,\n    startWith,\n    switchMapTo,\n    mergeMap,\n    withLatestFrom,\n    share,\n    ignoreElements,\n    last,\n    takeUntil,\n    endWith,\n    take,\n    mergeMapTo,\n    mergeAll,\n    delay,\n    publishBehavior,\n    refCount,\n    publishReplay,\n    shareReplay,\n} from 'rxjs/operators'\n\nimport KDBush from 'kdbush'\nimport createPolyBush from './rbush'\n\n// @ts-ignore\nimport nearestPointOnLine from '@turf/nearest-point-on-line'\n\nimport { StateType, State, Point, Shape, ShapeTypes, ConvertPoint, Snap, SnapType } from './types'\nimport { mapMouseEventToOffset, second, first, head, error } from './utils'\nimport createPencil from './pencils'\nimport { Event } from './events'\nimport { mapFirst, ofKeyCode, makeFromEventType, mapObservableToPropType } from './observables'\nimport {\n    convertShapesToListOfPoints,\n    filterPolygonShapes,\n    convertPolygonShapesToListOfLines,\n    convertShapesToListOfLines,\n    convertListOfLinesToLineString,\n} from './selectors'\n\nimport { AddState } from './add/types'\nimport { addPolygon, AddEventTypes, SubmitNewPolygonEvent } from './add/events'\nimport makeAddPolygonProgram from './add/observables'\nimport { isPolygonShape, warn } from './utils'\nimport { toMulticast } from './legacy/observables'\nimport { findLineSnapPosition } from './legacy/utils'\n\nofKeyCode([120, 88]).subscribe(() => console.clear())\n\nexport default <T>(convert: ConvertPoint, shapes$: Observable<Shape<T>[]>) => (\n    canvas: HTMLCanvasElement,\n    mouseCanvas: HTMLCanvasElement,\n    config: {\n        mapOffset?: (xy: [number, number]) => [number, number]\n    } = {},\n) => {\n    const ctx = canvas.getContext('2d')\n    const mouseCtx = mouseCanvas.getContext('2d')\n    const pencil = createPencil()(canvas)\n    const mousePencil = createPencil()(mouseCanvas)\n\n    /**\n     *\n     * @param param0\n     */\n    const toPoint = ([x, y]: [number, number]): Point => {\n        const [lng, lat] = convert.to([x, y])\n        return [x, y, lng, lat]\n    }\n\n    if (mousePencil && pencil && ctx != null && mouseCtx != null) {\n        canvas.style.cursor = 'none'\n        mouseCanvas.style.cursor = 'none'\n\n        /**\n         * Final API for drawing markers, polygons, and lines.\n         */\n\n        /**\n         * K-2 tree used to store all points that are present within\n         * the system and used to find points that are near the mouse\n         * position to snap to.\n         */\n        const pointsDb$ = new BehaviorSubject(\n            // @ts-ignore\n            new KDBush([]) as KDBush.KDBush<Point>,\n        )\n\n        const polyDb$ = new BehaviorSubject(createPolyBush())\n\n        const lineDb$ = new BehaviorSubject([] as [Point, Point][])\n\n        /**\n         * Observable for emitting events\n         */\n        const events$ = new Subject<Event>()\n\n        /**\n         * Observable emits all event types that are dispatched\n         */\n        const eventTypes$ = mapObservableToPropType(events$.asObservable())\n\n        /**\n         * Creates an observable that filters events by type\n         */\n        const fromEventType = makeFromEventType(eventTypes$)\n\n        /**\n         * Dispatches events\n         */\n        const dispatch = (event: Event) => {\n            events$.next(event)\n        }\n\n        const dispatchEvent = <E extends Event>($: Observable<E>) => $.pipe(tap(dispatch))\n        /**\n         * Observable streaming current and previous state\n         */\n        // const stateUpdates$ = new Subject<[State<T>, State<T>]>()\n\n        /**\n         * Maps state changes to actual state\n         */\n        // const state$ = stateUpdates$.pipe(mapFirst)\n\n        /**\n         * Finds the nearest point a given point can snap to\n         */\n\n        const mapPointToSnapFn$ = combineLatest(\n            shapes$.pipe(startWith([])),\n            pointsDb$,\n            lineDb$,\n        ).pipe(\n            map(([shapes, pointsDb, lineDb]) => {\n                return ([x, y, lng, lat]: Point): Snap => {\n                    const pointSnap = convertShapesToListOfPoints(shapes)[\n                        pointsDb.within(x, y, 10)[0]\n                    ]\n\n                    if (pointSnap) {\n                        return { type: SnapType.Point, point: pointSnap }\n                    }\n\n                    const lineSnap = findLineSnapPosition([x, y, lng!, lat!], lineDb as any)\n\n                    if (lineSnap) {\n                        const multiLineString = convertListOfLinesToLineString(lineDb)\n                        const maybePoint = nearestPointOnLine(multiLineString, [lng, lat])\n\n                        if (maybePoint) {\n                            const [sx, sy] = convert.from(maybePoint.geometry.coordinates)\n                            return {\n                                distance: 4,\n                                line: (lineSnap.line as any) as [Point, Point],\n                                type: SnapType.Line,\n                                point: [sx, sy, ...maybePoint.geometry.coordinates] as any, // [lineSnap.point[0], lineSnap.point[1], lng, lat] as Point,\n                            }\n                        }\n                    }\n\n                    return { type: SnapType.None, point: [x, y, lng, lat] as Point }\n                }\n            }),\n            shareReplay(1),\n        )\n\n        /**\n         *\n         */\n        const updatePointsDb$ = shapes$.pipe(\n            withLatestFrom(polyDb$),\n            tap(([shapes, polyDb]) => {\n                const polygons = filterPolygonShapes(shapes).map(item => item.shape)\n                lineDb$.next(convertShapesToListOfLines(shapes))\n                polyDb.replace(polygons)\n            }),\n            mapFirst,\n            map(convertShapesToListOfPoints),\n            tap(points => {\n                pointsDb$.next(\n                    // @ts-ignore\n                    new KDBush(points),\n                )\n            }),\n        )\n\n        const mouseClick$ = fromEvent<MouseEvent>(mouseCanvas, 'click')\n        const mouseClickOffset$ = mouseClick$.pipe(map(e => mapMouseEventToOffset(e)))\n\n        const translatedMouseClick$ = config.mapOffset\n            ? mouseClickOffset$.pipe(map(config.mapOffset))\n            : mouseClickOffset$\n\n        // const snappedClick$ = translatedMouseClick$.pipe(\n        //     withLatestFrom(mapPointToSnapFn$),\n        //     map(([point, mapPointToSnap]) => mapPointToSnap(point)),\n        // )\n\n        const mouseMove$ = fromEvent<MouseEvent>(mouseCanvas, 'mousemove')\n        const mouseMoveOffset$ = mouseMove$.pipe(map(e => mapMouseEventToOffset(e)))\n        const translatedMousemMove$ = config.mapOffset\n            ? mouseMoveOffset$.pipe(map(config.mapOffset))\n            : mouseMoveOffset$.pipe()\n\n        const mousePositionSnapped$ = translatedMousemMove$.pipe(\n            map(point => {\n                const [px, py] = point\n                const [lng, lat] = convert.to(point)\n\n                return [px, py, lng, lat] as Point\n            }),\n            withLatestFrom(mapPointToSnapFn$),\n            map(([point, mapPointToSnap]) => mapPointToSnap(point)),\n            // shareReplay(1),\n            // publishBehavior({ type: 'M', point: [0, 0, 0, 0] } as Snap),\n            // refCount(),\n            // share(),\n            // shareReplay(1),\n            shareReplay(1),\n        )\n        // .pipe(shareReplay(1))\n\n        // const mousePositionSnappedPoint$ = mousePositionSnapped$.pipe(map(({ point }) => point))\n\n        const hoverIndex$ = translatedMousemMove$.pipe(\n            map(toPoint),\n            withLatestFrom(polyDb$),\n            map(([point, polyDb]) => polyDb.searchPoint(point).map(item => item.index)),\n            scan((acc, next) => [acc[1], next] as const, [[], []] as readonly [number[], number[]]),\n            filter(([a, b]) => a.length !== b.length || a.some((n, index) => n !== b[index])),\n            map(([, b]) => b),\n            shareReplay(1),\n        )\n\n        const selected$ = concat(\n            mouseClick$.pipe(\n                warn,\n                withLatestFrom(hoverIndex$),\n                map(second),\n                map(head),\n                takeUntil(fromEventType(AddEventTypes.AddPolygon)),\n                startWith(undefined),\n                endWith(undefined),\n            ),\n            fromEventType('Noop').pipe(\n                take(1),\n                mapTo(undefined as number | undefined),\n            ),\n        ).pipe(repeat())\n\n        const add$ = makeAddPolygonProgram({\n            pencil: mousePencil,\n            mouseCtx,\n            from: convert.from,\n            shapes$,\n            mouseMove$: mousePositionSnapped$,\n            mouseClick$: mouseClick$.pipe(\n                withLatestFrom(mousePositionSnapped$),\n                map(second),\n                map(snap => snap.point),\n            ),\n            dispatchEvent,\n            fromEventType,\n        })\n\n        const draw$ = combineLatest(\n            shapes$.pipe(startWith([] as Shape<T>[])),\n            hoverIndex$.pipe(startWith([] as number[])),\n            selected$,\n        ).pipe(\n            tap(data => {\n                const [shapes, hoverIndices, selectedIndex] = data\n\n                pencil.resetStyles()\n\n                // Clear the canvas\n                pencil.eraser()\n\n                // Draw existing polygons\n                const polygons = filterPolygonShapes(shapes)\n                polygons.forEach((shape, index) => {\n                    const isHovering = hoverIndices.includes(index)\n                    const isSelected = selectedIndex === index\n                    pencil.polygon({ ...shape, meta: { isHovering, isSelected, id: shape.meta } })\n                    pencil.resetStyles()\n                })\n\n                if (selectedIndex != null) {\n                    const selectedPolygon = polygons[selectedIndex]\n\n                    selectedPolygon.shape.map(ring =>\n                        ring.map(point =>\n                            pencil.marker({\n                                type: ShapeTypes.Point,\n                                meta: selectedPolygon.meta,\n                                shape: point,\n                            }),\n                        ),\n                    )\n                }\n            }),\n        )\n\n        const clear$ = mousePositionSnapped$.pipe(\n            tap(snap => {\n                mousePencil.eraser()\n                mousePencil.cursor(snap)\n            }),\n            ignoreElements(),\n        )\n\n        const addShortCutKey$ = ofKeyCode([65, 97]).pipe(\n            mapTo({ type: AddEventTypes.AddPolygon }),\n            dispatchEvent,\n            ignoreElements(),\n        )\n\n        const noop$ = of({ type: 'Noop' as const }).pipe(\n            dispatchEvent,\n            ignoreElements(),\n        )\n\n        const core$ = merge(\n            addShortCutKey$,\n            of(void 0),\n            fromEventType('Noop'),\n            fromEventType(AddEventTypes.AddPolygon),\n        ).pipe(\n            warn,\n            switchMap(event => {\n                switch (event) {\n                    case AddEventTypes.AddPolygon: {\n                        return concat(add$, noop$)\n                    }\n                    default: {\n                        return clear$\n                    }\n                }\n            }),\n            // share(),\n        )\n\n        const plop$ = merge(\n            merge(updatePointsDb$, draw$ /* drawNewPolygon$, */).pipe(ignoreElements()),\n            core$,\n            // cursor$,\n        ).pipe(share())\n\n        // const subscription = plop$.subscribe()\n\n        return {\n            done: () => {\n                // subscription.unsubscribe()\n            },\n            subscribe: ((...args: any[]) => plop$.subscribe(...args)) as typeof plop$.subscribe,\n            api: {\n                add: () => dispatch(addPolygon()),\n            },\n        }\n    }\n\n    throw new Error('Canvas 2D Rendering Context Not Available')\n}\n","import { of, Subject, BehaviorSubject } from 'rxjs'\n\n// Plop core\nimport core from '../core'\nimport { Point, ShapeTypes, PolygonShape, Shape, ConvertPoint } from '../core/types'\n\nimport { tap, map } from 'rxjs/operators'\nimport { FeatureCollection, Feature, Polygon, MultiPolygon } from '@turf/helpers'\n\nexport type Geometry =\n    | Feature<Polygon | MultiPolygon>\n    | FeatureCollection<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon\n\nconst isPolygon = (geometry: Polygon | MultiPolygon): geometry is Polygon =>\n    geometry.type === 'Polygon'\n\nconst isMultiPolygon = (geometry: Polygon | MultiPolygon): geometry is MultiPolygon =>\n    geometry.type === 'MultiPolygon'\n\ntype From = ConvertPoint['from']\ntype Ring = Polygon['coordinates'][0]\n\nconst rand = () => Math.floor(Math.random() * 20) + 1\n\nconst ring2points = (from: From) => ([, ...ring]: Ring) => ring.map(([x, y]) => from([x, y]))\n\nconst polygon2shape = (from: From) => <G extends Polygon>(polygon: G): PolygonShape<number> => ({\n    type: ShapeTypes.Polygon,\n    shape: polygon.coordinates.map(ring2points(from)),\n    meta: rand(),\n})\n\nconst multiPolygon2shapes = (from: From) => <G extends MultiPolygon>(\n    multiPolygon: G,\n): PolygonShape<number>[] =>\n    multiPolygon.coordinates.map(polygon => ({\n        type: ShapeTypes.Polygon,\n        shape: polygon.map(ring2points(from)),\n        meta: rand(),\n    }))\n\nconst feature2shapes = (from: From) => <G extends Feature<MultiPolygon | Polygon>>(\n    feature: G,\n): PolygonShape<number>[] =>\n    isPolygon(feature.geometry)\n        ? [polygon2shape(from)(feature.geometry)]\n        : multiPolygon2shapes(from)(feature.geometry)\n\nconst featureCollection2shapes = (from: From) => <\n    G extends FeatureCollection<MultiPolygon | Polygon>\n>(\n    featureCollection: G,\n): PolygonShape<number>[] => featureCollection.features.flatMap(feature2shapes(from))\n\nconst geometry2shapes = (from: From) => (geometry: Geometry) =>\n    geometry.type === 'FeatureCollection'\n        ? featureCollection2shapes(from)(geometry)\n        : geometry.type === 'Feature'\n        ? feature2shapes(from)(geometry)\n        : isMultiPolygon(geometry)\n        ? multiPolygon2shapes(from)(geometry)\n        : [polygon2shape(from)(geometry)]\n\nexport const geometries2shapes = (from: From) => (geometries: Geometry[]) =>\n    geometries.flatMap(geometry2shapes(from))\n\nexport default (convert: ConvertPoint) => (\n    canvas: HTMLCanvasElement,\n    mouseCanvas: HTMLCanvasElement,\n    config: {\n        mapOffset?: (xy: [number, number]) => [number, number]\n    } = {},\n) => (geometries: Geometry[]) => {\n    const geometries$ = new BehaviorSubject(geometries)\n\n    const shapes$ = geometries$.pipe(map(geometries2shapes(convert.from)))\n\n    const plop = core(convert, shapes$)(canvas, mouseCanvas, config)\n\n    const refresh = () => geometries$.next(geometries$.getValue())\n\n    plop.subscribe(event => {\n        const coordinates = event.payload.map(convert.to)\n        coordinates.push(coordinates[0])\n        const polygon: Polygon = {\n            type: 'Polygon',\n            coordinates: [coordinates],\n        }\n        geometries$.next([...geometries$.getValue(), polygon])\n    })\n\n    return Object.assign(plop, { refresh })\n}\n","import '../../leaflet/leaflet.css'\n\nimport React from 'react'\nimport { Map, TileLayer, useLeaflet, Pane } from 'react-leaflet'\nimport _ from 'lodash'\nimport { FeatureCollection, Polygon, MultiPolygon } from '@turf/helpers'\n\n// Plop\nimport plopLeaflet from '../../modules/leaflet/src'\n\n// Data\nimport geojson from '../../data/nl.json'\n\nconst Canvas = () => {\n    const context = useLeaflet()\n    const [data, setData] = React.useState<FeatureCollection<Polygon | MultiPolygon>>(\n        geojson as any,\n    )\n\n    React.useEffect(() => {\n        if (context.map != null) {\n            const plop = plopLeaflet(context.map, { pane: context.pane })([data])\n\n            // plop.observables.\n\n            return plop.unsubscribe\n        }\n    }, [\n        context.map,\n        // context.map && context.map.getCenter().lat,\n        // context.map && context.map.getCenter().lng,\n    ])\n\n    return null\n}\n\nconst tileLayer = (\n    <TileLayer\n        url=\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n        attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n    />\n)\n\nexport default () => {\n    const [position] = React.useState([52.1326, 5.2913] as [number, number])\n\n    return (\n        <Map center={position} zoom={8}>\n            {tileLayer}\n            <Pane name=\"plop-canvas\">\n                <Canvas />\n            </Pane>\n        </Map>\n    )\n}\n","import { Map } from 'leaflet'\nimport { createCanvasLayer, fromLngLat, toLngLat, translateOffsetOfCanvas } from './utils'\nimport plopGeoJSON from '../../geojson'\nimport { FeatureCollection, Feature, Polygon, MultiPolygon } from '@turf/helpers'\n\nexport type Geometry =\n    | Feature<Polygon | MultiPolygon>\n    | FeatureCollection<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon\n\nexport default (map: Map, options: { pane?: string } = {}) => (geometries: Geometry[]) => {\n    const pane = options.pane || (map.createPane('plop') && 'plop')\n    const canvasLayer = createCanvasLayer(pane)\n    const mouseCanvasLayer = createCanvasLayer(pane)\n\n    canvasLayer.addTo(map)\n    mouseCanvasLayer.addTo(map)\n\n    const elCanvas: HTMLCanvasElement = (canvasLayer as any)._container\n    const elMouseCanvasLayer: HTMLCanvasElement = (mouseCanvasLayer as any)._container\n    const translateOffset = translateOffsetOfCanvas(elCanvas)\n\n    const plop = plopGeoJSON({\n        from: fromLngLat(map),\n        to: toLngLat(map),\n    })(elCanvas, elMouseCanvasLayer, {\n        mapOffset: translateOffset,\n    })(geometries)\n\n    map.addEventListener('moveend zoomend', plop.refresh)\n\n    const unsubscribe = () => {\n        map.removeEventListener('moveend zoomend', plop.refresh)\n        map.removeLayer(canvasLayer)\n        map.removeLayer(mouseCanvasLayer)\n        plop.done()\n    }\n\n    return Object.assign(plop, { unsubscribe })\n}\n","import React from 'react'\nimport './App.css'\n\nimport Map from './apps/map'\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"App\">\n            <div className=\"App-header\">\n                <p>\n                    <button\n                        onClick={\n                            // @ts-ignore\n                            () => api.api.addPolygon()\n                        }\n                    >\n                        ADD POLYGON\n                    </button>\n                </p>\n                <ol>\n                    <li>\n                        Press <i>&quot;a&quot;</i> or click the <i>&quot;Add Polygon&quot;</i>{' '}\n                        button to start drawing.\n                    </li>\n                    <li>\n                        Press <i>&quot;Enter&quot;</i> to finish drawing. You can only finish after\n                        at least 3 points are drawn.\n                    </li>\n                    <li>\n                        Press <i>&quot;c&quot;</i> to cancel the operation.\n                    </li>\n                    <li>\n                        Supports:\n                        <ul>\n                            <li>Snapping</li>\n                            <li>Undo & redo with Ctrl-Z/Y while adding points</li>\n                        </ul>\n                    </li>\n                </ol>\n            </div>\n            <div id=\"map\">\n                <Map />\n            </div>\n        </div>\n    )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}