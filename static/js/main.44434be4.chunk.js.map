{"version":3,"sources":["modules/core/utils/bbox.ts","modules/core/utils/inBbox.ts","modules/core/utils/booleanPointInPolygon.ts","modules/core/rbush.ts","modules/core/types.ts","modules/core/utils/mapMouseEventToCoords.ts","modules/core/add/events.ts","modules/core/pencils/marker.ts","modules/core/pencils/polygon.ts","modules/core/pencils/line.ts","modules/core/pencils/resetStyles.ts","modules/core/pencils/cursor.ts","modules/core/pencils/eraser.ts","modules/core/pencils/index.ts","modules/core/add/reducer.ts","modules/core/reducers.ts","modules/core/utils/index.ts","modules/core/observables.ts","modules/core/selectors.ts","modules/core/utils/isNotNr.ts","modules/core/add/observables.ts","modules/core/legacy/utils.ts","modules/core/legacy/observables.ts","modules/core/index.ts","modules/geojson/index.ts","apps/map/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["polygon","reduce","acc","x","y","minX","minY","maxX","Infinity","maxY","point","bbox","inRing","ring","ignoreBoundary","isInside","length","slice","i","j","xi","yi","xj","yj","ShapeTypes","StateType","EventTypes","SnapType","RBush","RbushClass","polygonToItem","index","Object","assign","boundingBox","insertPolygons","tree","state","polygons","items","map","count","load","searchByBoundingBox","search","searchByPoint","filter","item","options","inBBox","insidePoly","inHole","k","booleanPointInPolygon","window","insert","searchPoint","replace","clear","initialPolygons","AddEventTypes","evt","offsetX","offsetY","ctx","context","beginPath","arc","shape","Math","PI","fillStyle","fill","stroke","closePath","colors","n","marker","forEach","hx","hy","t","moveTo","lineTo","meta","id","hovering","strokeStyle","lineWidth","lineJoin","line","type","Point","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","data","canvas","getContext","save","setTransform","clearRect","width","height","restore","api","finalMarker","defaultMarker","finalPolygon","defaultPolygon","finalLine","defaultLine","cursor","defaultCursor","resetStyles","defaultResetStyles","eraser","addPolygon","AddPolygon","event","value","Noop","AddPointToNewPolygon","payload","SubmitNewPolygon","CancelNewPolygon","addReducer","emptyArray","memoize","f","previousA","previousB","a","returnEmptyArray","isPolygonShape","Polygon","isPointShape","isLineShape","Line","tuple","b","first","Array","isArray","mapFirst","makeEventTypes","events$","pipe","makeFromEventType","eventTypes$","eventType","dispatchedEventType","keyPress$","fromEvent","document","keyPressCode$","keyCode","ofKeyCode","pressedKeyCode","includes","enterKey$","cancelKey$","undoKey$","ctrlKey","mapTo","redoKey$","filterPolygonShapes","shapes","filterLineShapes","filterPointShapes","convertPointShapesToListOfPoints","pointShapes","pointShape","convertLineShapesToListOfPoints","lineShapes","flatMap","lineShape","convertPolygonShapesToListOfPoints","polygonShapes","polygonShape","flat","convertPolygonShapesToListOfLines","next","xs","reverse","last","p","push","convertShapesToListOfPoints","convertShapesToListOfLines","makeAddPointToPolygon","nextPoint$","dispatch","allNewPoints$","merge","scan","currentPoints","redoPoints","clone","splice","initial","tail","pressedEnter$","pressedCancel$","takeWhile","points","tap","addPolygonEvent$","concat","take","of","isNotNr","findLineSnapPosition","lines","distance","find","poly","x1","y1","x2","y2","xx","yy","C","D","lenSq","param","dx","dy","sqrt","pointToLineDistance","xy","dxy","toMulticast","observable","connect","publishedObservable","publish","createEventObservableCreator","mouseCanvas","subscribe","console","translateOffsetOfCanvas","style","transform","match","str","isNaN","tx","convert","shapes$","mouseCtx","pencil","pencil_","mousePencil","translateOffset","pointsDb","KDBush","polyDb","createPolyBush","lineDb","Subject","fromEventType","stateUpdates$","mapPointToSnapFn$","startWith","lng","lat","pointSnap","within","lineSnap","to","None","updatePointsDb$","setState","nextState","prev","mouseClick$","mouseClickOffset$","e","mapMouseEventToCoords","translatedMouseClick$","mouseMove$","withLatestFrom","mapPointToSnap","mouseMoveOffset$","translatedMousemMove$","mousePositionSnapped$","px","py","mousePositionSnappedPoint$","hoverIndex$","some","reduceActions$","transition","addPolygonProgram$","makeAddPolygonProgram","repeat","draw$","combineLatest","hoverIndices","subscription","from","mousePosition","newPolygon","undefined","done","unsubscribe","onAdd$","Error","features","convertGeoJson","feature","geom","geometry","coordinates","floor","random","g","isM","position","Map","props","center","zoom","TileLayer","url","attribution","Pane","name","children","createCanvasLayer","pane","padding","toLngLat","layerPointToLatLng","fromLngLat","latLngToLayerPoint","Canvas","useLeaflet","React","useEffect","canvasLayer","mouseCanvasLayer","addTo","elCanvas","_container","elMouseCanvasLayer","core","refresh","properties","onZoomOrMove","_","addEventListener","removeEventListener","removeLayer","getCenter","App","className","onClick","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.44434be4.chunk.js","sourcesContent":["import { Polygon } from '../types'\n\nexport default (polygon: Polygon) =>\n    polygon[0].reduce(\n        (acc, [x, y]) => {\n            if (x < acc.minX) acc.minX = x\n            if (y < acc.minY) acc.minY = y\n            if (acc.maxX === Infinity || x > acc.maxX) acc.maxX = x\n            if (acc.maxY === Infinity || y > acc.maxY) acc.maxY = y\n            return acc\n        },\n        {\n            minX: Infinity,\n            minY: Infinity,\n            maxX: Infinity,\n            maxY: Infinity,\n        },\n    )\n","import { Point } from '../types'\n\ntype BBox = {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n}\n\nexport default (point: Point, bbox: BBox) =>\n    bbox.minX <= point[0] && bbox.minY <= point[1] && bbox.maxX >= point[0] && bbox.maxY >= point[1]\n","import { Polygon, Point, Line } from '../types'\nimport boundingBox from './bbox'\nimport inBBox from './inBbox'\n\nexport default function booleanPointInPolygon(\n    point: Point,\n    polygon: Polygon,\n    options: {\n        ignoreBoundary?: boolean\n    } = {},\n) {\n    const bbox = boundingBox(polygon)\n\n    // Quick elimination if point is not inside bbox\n    if (inBBox(point, bbox) === false) {\n        return false\n    }\n\n    let insidePoly = false\n\n    if (inRing(point, polygon[0], options.ignoreBoundary)) {\n        let inHole = false\n        let k = 1\n        // check for the point in any of the holes\n        while (k < polygon.length && !inHole) {\n            if (inRing(point, polygon[k], !options.ignoreBoundary)) {\n                inHole = true\n            }\n            k++\n        }\n        if (!inHole) {\n            insidePoly = true\n        }\n    }\n\n    return insidePoly\n}\n\nfunction inRing(point: Point, ring: Line, ignoreBoundary?: boolean) {\n    let isInside = false\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1)\n    }\n\n    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        const xi = ring[i][0]\n        const yi = ring[i][1]\n        const xj = ring[j][0]\n        const yj = ring[j][1]\n        const onBoundary =\n            point[1] * (xi - xj) + yi * (xj - point[0]) + yj * (point[0] - xi) === 0 &&\n            (xi - point[0]) * (xj - point[0]) <= 0 &&\n            (yi - point[1]) * (yj - point[1]) <= 0\n        if (onBoundary) {\n            return !ignoreBoundary\n        }\n        const intersect =\n            yi > point[1] !== yj > point[1] &&\n            point[0] < ((xj - xi) * (point[1] - yi)) / (yj - yi) + xi\n        if (intersect) {\n            isInside = !isInside\n        }\n    }\n\n    return isInside\n}\n","import bbox from '@turf/bbox'\nimport * as _ from 'lodash'\n\n// @ts-ignore\nimport RbushClass from 'rbush/index'\n\nimport { Polygon, Point } from './types'\n\nimport boundingBox from './utils/bbox'\nimport booleanPointInPolygon from './utils/booleanPointInPolygon'\n\ntype RBush<T = {}> = new (...args: any) => rbush.RBush<T>\n\nconst RBush: RBush = RbushClass\n\nconst polygonToItem = (polygon: Polygon, index: number) =>\n    Object.assign(boundingBox(polygon), { polygon, index })\n\ntype Item = ReturnType<typeof polygonToItem>\ntype Tree = rbush.RBush<Item>\n\nconst insertPolygons = (tree: Tree, state: { count: number }) => (polygons: Polygon[]) => {\n    const items = polygons.map((polygon, index) => {\n        return polygonToItem(polygon, index + state.count + 1)\n    })\n    state.count += polygons.length\n    tree.load(items)\n}\n\nconst insertPolgyon = (tree: rbush.RBush<Item>, state: { count: number }) => (polygon: Polygon) => {\n    state.count += 1\n    tree.insert(polygonToItem(polygon, state.count))\n}\n\nconst searchByBoundingBox = (tree: Tree) => (boundingBox: rbush.BBox) => tree.search(boundingBox) // .map(item => item.polygon)\n\nconst searchByPoint = (tree: Tree) => {\n    const search = searchByBoundingBox(tree)\n\n    return ([x, y]: Point) => {\n        const items = search({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y,\n        })\n\n        return items.filter(item => booleanPointInPolygon([x, y], item.polygon))\n    }\n}\n\nexport default (...initialPolygons: Polygon[]) => {\n    const tree: rbush.RBush<Item> = new RBush() as any\n    Object.assign(window, { tree })\n    const state = { count: -1 }\n\n    const insert = insertPolygons(tree, state)\n    const search = searchByBoundingBox(tree)\n    const searchPoint = searchByPoint(tree)\n\n    const replace = (polygons: Polygon[]) => {\n        state.count = -1\n        tree.clear()\n        insert(polygons)\n    }\n    insert(initialPolygons)\n\n    return {\n        insert,\n        search,\n        searchPoint,\n        replace,\n    }\n}\n","import { AddState } from './add/types'\n\n/** Type alias for pixels */\nexport type Pixel = number\n\n/** Type alias for x- and y coordinates */\nexport type Coordinate = number\n\n/**\n * An (x, y) coordiante. The first 2 number represent the pixel\n * cordiantes while the optional second set of numbers are the\n * origina coordiantes. For example longitude and lattitude values.\n *\n * The system preservers the original coordiantes to prevent having\n * to convert them back and forth if they aren't changed.\n */\nexport type Point = [Pixel, Pixel, Coordinate, Coordinate] | [Pixel, Pixel]\n\n/**\n * A list of 2- or more [[Point]]s\n *\n * I would've preferred to tyep it [Point, Point, ...Point[]]\n */\nexport type Line = Point[]\n\n/**\n * A list of list of points where the first element in the list\n * is clockwise and the rest of the list counter clockwise\n * representing holes.\n *\n * I would've preferred to type it: [Point, Point, Point, ...Point[]][]\n * since each ring should have at least 3 points.\n */\nexport type Polygon = Line[]\n\nexport enum ShapeTypes {\n    Point = 'Point',\n    Polygon = 'Polygon',\n    Line = 'Line',\n}\n\nexport type PointShape<T> = {\n    type: ShapeTypes.Point\n    shape: Point\n    meta: T\n}\n\nexport type PolygonShape<T> = {\n    type: ShapeTypes.Polygon\n    shape: Polygon\n    meta: T\n}\n\nexport type LineShape<T> = {\n    type: ShapeTypes.Line\n    shape: Line\n    meta: T\n}\n\nexport type Shape<T> = PointShape<T> | PolygonShape<T> | LineShape<T>\n\nexport enum StateType {\n    Noop = 'Noop',\n    AddPolygon = 'AddPolygon',\n}\n\n// State\nexport interface NoopState {\n    readonly value: StateType.Noop\n}\n\nexport type PossibleStates = NoopState | AddState\nexport type State<T> = PossibleStates\n\n// Actions\nexport enum EventTypes {\n    SelectPolygon = 'SelectPolygon',\n    EditPolygon = 'EditPolygon',\n    RemovePolygon = 'RemovePolygon',\n}\n\nexport type FromPoint = (coordinate: number[]) => Point\nexport type ToPoint = (coordinate: Point) => number[]\nexport type ConvertPoint = { from: FromPoint; to: ToPoint }\n\nexport enum SnapType {\n    Point = 'P',\n    Line = 'L',\n    None = 'M',\n}\n\nexport type SnapPoint = { type: SnapType.Point; point: Point }\nexport type SnapLine = { type: SnapType.Line; point: Point; line: [Point, Point]; distance: number }\nexport type SnapNone = { type: SnapType.None; point: Point }\nexport type Snap = SnapPoint | SnapLine | SnapNone\n","export default (evt: MouseEvent): [number, number] => [evt.offsetX, evt.offsetY]\n","import { Point, Polygon } from '../types'\n\n/**\n * Event type descriptors for the \"Add Polygon\" process\n */\nexport enum AddEventTypes {\n    AddPolygon = 'AddPolygon',\n    AddPointToNewPolygon = 'AddPointToNewPolygon',\n    SubmitNewPolygon = 'SubmitNewPolygon',\n    CancelNewPolygon = 'CancelNewPolygon',\n}\n\n/**\n * Event dispatched when the user wants to add a new polygon.\n */\nexport type AddPolygonEvent = {\n    type: AddEventTypes.AddPolygon\n}\n\n/**\n * Event dispatched when the user clicks on the canvas to add a new point to the polygon they are creating.\n */\nexport type AddPointToNewPolygonEvent = {\n    type: AddEventTypes.AddPointToNewPolygon\n    payload: Point\n}\n\n/**\n * Event dispatched when the user has finished creating a new polygon.\n */\nexport type SubmitNewPolygonEvent = {\n    type: AddEventTypes.SubmitNewPolygon\n    payload: Polygon\n}\n\n/**\n * Event dispatched when the user wants to cancel creating a new polygon.\n */\nexport type CancelNewPolygonEvent = {\n    type: AddEventTypes.CancelNewPolygon\n}\n\n/**\n * All possible events for the \"Add poloygon\" process\n */\nexport type AddEvent =\n    | AddPolygonEvent\n    | AddPointToNewPolygonEvent\n    | SubmitNewPolygonEvent\n    | CancelNewPolygonEvent\n\n/**\n * Event creator instructing the program the user wants to create a new polygon.\n */\nexport const addPolygon = (): AddPolygonEvent => ({ type: AddEventTypes.AddPolygon })\n\n/**\n * Event creator instructing the program to add a new point to the new polygon.\n */\nexport const addPointToNewPolygon = (point: Point): AddPointToNewPolygonEvent => ({\n    type: AddEventTypes.AddPointToNewPolygon,\n    payload: point,\n})\n\n/**\n * Event creator instructing the program the user has finished creating a new polygon.\n */\nexport const submitNewPolygon = (polygon: Polygon): SubmitNewPolygonEvent => ({\n    type: AddEventTypes.SubmitNewPolygon,\n    payload: polygon,\n})\n\n/**\n * Event creator instructing the program the user wants to cancel creating a new polygon.\n */\nexport const cancelNewPolygon = (): CancelNewPolygonEvent => ({\n    type: AddEventTypes.CancelNewPolygon,\n})\n","import { PointShape } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (point: PointShape<any>, context = ctx) => {\n    context.beginPath()\n    context.arc(point.shape[0], point.shape[1], 5, 0, 2 * Math.PI)\n    context.fillStyle = '#fff'\n    context.fill()\n    context.stroke()\n    context.closePath()\n}\n","import { PointShape, PolygonShape, ShapeTypes } from '../types'\n\nconst colors = [\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n]\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default <T extends { hovering: boolean }>(\n    marker: (point: PointShape<T>, ctx?: CanvasRenderingContext2D) => void,\n) => (ctx: CanvasRenderingContext2D) => (polygon: PolygonShape<T>, context = ctx) => {\n    //\n    context.beginPath()\n\n    polygon.shape.forEach(ring => {\n        const [[hx, hy], ...t] = ring\n\n        context.moveTo(hx, hy)\n\n        t.forEach(([x, y]) => {\n            context.lineTo(x, y)\n        })\n        context.closePath()\n    })\n\n    context.fillStyle =\n        // @ts-ignore\n        (colors[polygon.meta.id] && colors[polygon.meta.id](polygon.meta.hovering ? 1 : 0.5)) ||\n        `rgba(255, 255, 255, ${polygon.meta.hovering ? 1 : 0.5})`\n    context.strokeStyle =\n        // @ts-ignore\n        (colors[polygon.meta.id] && colors[polygon.meta.id](1)) || `rgba(255, 255, 255, 1)`\n\n    context.lineWidth = 1\n    context.lineJoin = 'round'\n\n    context.fill()\n\n    context.stroke()\n\n    // polygon.shape.forEach(ring =>\n    //     ring.forEach(point =>\n    //         marker({ shape: point, meta: polygon.meta, type: ShapeTypes.Point }, context),\n    //     ),\n    // )\n}\n","import { PointShape, LineShape, ShapeTypes } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: PointShape<any>, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (line: LineShape<any>, context = ctx) => {\n    context.beginPath()\n\n    const [[hx, hy], ...t] = line.shape\n\n    context.moveTo(hx, hy)\n\n    t.forEach(([x, y]) => {\n        context.lineTo(x, y)\n    })\n\n    context.stroke()\n\n    line.shape.forEach(point =>\n        marker({ type: ShapeTypes.Point, shape: point, meta: line.meta }, context),\n    )\n}\n","export default (ctx: CanvasRenderingContext2D) => () => {\n    ctx.fillStyle = '#ffffff'\n    ctx.strokeStyle = '#000000'\n    ctx.lineWidth = 1\n    ctx.shadowBlur = 0\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'\n}\n","import { Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (data: {\n    type: 'P' | 'M' | 'L'\n    point: Point\n}) => {\n    const [x, y] = data.point\n    ctx.fillStyle = 'transparent'\n    ctx.lineWidth = 1\n\n    ctx.beginPath()\n    ctx.arc(x, y, 1, 0, 2 * Math.PI)\n    ctx.stroke()\n    ctx.fill()\n    ctx.closePath()\n\n    ctx.lineWidth = 2\n    ctx.strokeStyle =\n        // if\n        data.type === 'P'\n            ? // then\n              'Yellow'\n            : // else if\n            data.type === 'L'\n            ? // then\n              'Cyan'\n            : // else\n              'Black'\n\n    ctx.beginPath()\n    ctx.arc(x, y, 15, 0, 2 * Math.PI)\n    ctx.stroke()\n    ctx.fill()\n    ctx.closePath()\n}\n","export default (canvas: HTMLCanvasElement) => () => {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx) {\n        ctx.save()\n\n        // Use the identity matrix while clearing the canvas\n        ctx.setTransform(1, 0, 0, 1, 0, 0)\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n        ctx.restore()\n    }\n}\n","import defaultMarker from './marker'\nimport defaultPolygon from './polygon'\nimport defaultLine from './line'\nimport defaultResetStyles from './resetStyles'\nimport defaultCursor from './cursor'\nimport eraser from './eraser'\n\ninterface Api {\n    marker: typeof defaultMarker\n    polygon: typeof defaultPolygon\n    line: typeof defaultLine\n    cursor: typeof defaultCursor\n    resetStyles: typeof defaultResetStyles\n}\n\nexport default (api: Partial<Api> = {}) => (canvas: HTMLCanvasElement) => {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx) {\n        const finalMarker = (api.marker || defaultMarker)(ctx)\n        const finalPolygon = (api.polygon || defaultPolygon)(finalMarker)(ctx)\n        const finalLine = (api.line || defaultLine)(finalMarker)(ctx)\n        const cursor = (api.cursor || defaultCursor)(ctx)\n        const resetStyles = (api.resetStyles || defaultResetStyles)(ctx)\n\n        return {\n            marker: finalMarker,\n            polygon: finalPolygon,\n            line: finalLine,\n            resetStyles,\n            cursor,\n            eraser: eraser(canvas),\n            api: {\n                marker: defaultMarker,\n                polygon: defaultPolygon(finalMarker),\n                line: defaultLine(finalMarker),\n                resetStyles: defaultResetStyles,\n                cursor: defaultCursor,\n                eraser,\n            },\n        }\n    }\n}\n","import { State, NoopState, StateType, Point } from '../types'\n\nimport { AddState } from './types'\nimport { AddEventTypes } from './events'\nimport { Event } from '../events'\n\nimport isPolygon from '../utils/isPolygon'\n\n/**\n * Transitions state to the beginning o the \"Add polygon\" process\n */\nexport const fromNoopToAddPolygon = <T>(state: NoopState): AddState => {\n    return {\n        value: StateType.AddPolygon,\n    }\n}\n\n/**\n * Adds a point to the new poloygon the user is creating.\n */\nexport const addPointToNewPolygon = <T>(state: AddState, point: Point): AddState => {\n    return {\n        value: StateType.AddPolygon,\n    }\n}\n\n/**\n * Transitions state to include the new polygon and return to base state.\n */\nexport const submitNewPolygon = <T>(state: AddState): NoopState => {\n    return {\n        value: StateType.Noop,\n    }\n}\n\n/**\n * Transitions back to base state without a new polygon.\n */\nexport const cancelNewPolygon = <T>(state: AddState): NoopState => {\n    return {\n        value: StateType.Noop,\n    }\n}\n\n/**\n * Handles incoming events and transitions state accordingly.\n */\nexport default <T>(state: State<T>, event: Event): State<T> => {\n    // Transition to \"AddPolygon\" state\n    if (event.type === AddEventTypes.AddPolygon && state.value === StateType.Noop) {\n        return fromNoopToAddPolygon<T>(state)\n    }\n\n    // Add point to new polygon currently being drawn\n    else if (\n        event.type === AddEventTypes.AddPointToNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return addPointToNewPolygon(state, event.payload)\n    }\n\n    // Finish drawing new polygon\n    else if (\n        event.type === AddEventTypes.SubmitNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return submitNewPolygon(state)\n    }\n\n    // Cancel drawing a new polygon\n    else if (\n        event.type === AddEventTypes.CancelNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return cancelNewPolygon(state)\n    }\n\n    return state\n}\n","import { State } from './types'\nimport { Event } from './events'\nimport addReducer from './add/reducer'\n\nexport default <T>(state: State<T>, event: Event): State<T> => addReducer(state, event)\n","import { Shape, ShapeTypes, LineShape, PointShape, PolygonShape } from '../types'\n\n// Constants\nexport const emptyArray: any[] = []\n\nexport const memoize = <A, B>(f: (a: A) => B) => {\n    let previousA: A | undefined\n    let previousB: B | undefined\n\n    return (a: A): B => {\n        if (a !== previousA) {\n            previousA = a\n            previousB = f(a)\n        }\n\n        return returnEmptyArray(previousB as B)\n    }\n}\n\n// Assertion functions\n\n/** Asserts if the given shape is of type [[PolygonShape]] */\nexport const isPolygonShape = <T>(shape: Shape<T>): shape is PolygonShape<T> =>\n    shape.type === ShapeTypes.Polygon\n\n/** Asserts if the given shape is of type [[PointShape]] */\nexport const isPointShape = <T>(shape: Shape<T>): shape is PointShape<T> =>\n    shape.type === ShapeTypes.Point\n\n/** Asserts if the given shape is of type [[LineShape]] */\nexport const isLineShape = <T>(shape: Shape<T>): shape is LineShape<T> =>\n    shape.type === ShapeTypes.Line\n\n// Tuple functions\n\n/** Converts value a and b into a tuple */\nexport const tuple = <A, B>(a: A, b: B): [A, B] => [a, b]\n\n/** Returns the first element of a tuple */\nexport const first = <A>([a]: [A, any]): A => a\n\n/** Returns the second element of a tuple */\nexport const second = <B>([, b]: [any, B]): B => b\n\n// Array functions\n\n/** Return everything but the last element in an array. */\nexport const initial = <T>(xs: T[]) => {\n    const clone = [...xs]\n    clone.splice(xs.length - 1, 1)\n    return clone\n}\n\n/** Return everything but the first element in array. */\nexport const tail = <T>(xs: T[]) => {\n    const [_, ...t] = xs\n    return t\n}\n\n/** Retrun the first element in an array. */\nexport const head = <T>(xs: T[]) => {\n    const [h] = xs\n    return h\n}\n\n/** Time */\nexport const last = <T>(xs: T[]) => {\n    const [l] = [...xs].reverse()\n    return l\n}\n\nexport const returnEmptyArray = <T>(value: T): T =>\n    Array.isArray(value) && value.length <= 0 ? (emptyArray as any) : value\n","import { fromEvent, Observable } from 'rxjs'\nimport { map, filter, tap, mapTo } from 'rxjs/operators'\n\nimport { Event, EventType } from './events'\n\nimport { first } from './utils'\n\n/** Maps an observable of a tuple to an observable of the first element in the tuple */\nexport const mapFirst = map(first)\n\n/**\n *\n */\nexport const makeEventTypes = (events$: Observable<Event>) => events$.pipe(map(event => event.type))\n\n/**\n *\n */\nexport const makeFromEventType = (eventTypes$: Observable<Event['type']>) => <T extends EventType>(\n    eventType: T,\n) =>\n    eventTypes$.pipe(\n        filter(\n            (dispatchedEventType): dispatchedEventType is T => eventType === dispatchedEventType,\n        ),\n    )\n\n/**\n *\n */\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress')\n/**\n *\n */\nexport const keyPressCode$ = keyPress$.pipe(map(evt => evt.keyCode))\n\n/**\n *\n */\nexport const ofKeyCode = (keyCode: number | number[]) =>\n    keyPressCode$.pipe(\n        filter(pressedKeyCode =>\n            Array.isArray(keyCode) ? keyCode.includes(pressedKeyCode) : pressedKeyCode === keyCode,\n        ),\n    )\n\n/**\n *\n */\nexport const enterKey$ = ofKeyCode(13)\n\n/**\n *\n */\nexport const cancelKey$ = ofKeyCode(99)\n\nexport const undoKey$ = keyPress$\n    .pipe(filter(evt => evt.ctrlKey && [122, 90, 26].includes(evt.keyCode)))\n    .pipe(mapTo('undo' as const))\n\nexport const redoKey$ = keyPress$\n    .pipe(filter(evt => evt.ctrlKey && [121, 89, 25].includes(evt.keyCode)))\n    .pipe(mapTo('redo' as const))\n","import { State, Point, Shape, StateType, PointShape, LineShape, PolygonShape } from './types'\nimport { memoize, isPolygonShape, isPointShape, isLineShape, emptyArray, last } from './utils'\n\n/**\n * From `[Polygon, T] -> [Polygon]\n */\nexport const filterPolygonShapes = memoize(<T>(shapes: Shape<T>[]): PolygonShape<T>[] =>\n    shapes.filter(isPolygonShape),\n)\n\n/** TODO */\nexport const filterLineShapes = memoize(<T>(shapes: Shape<T>[]): LineShape<T>[] =>\n    shapes.filter(isLineShape),\n)\n\n/** TODO */\nexport const filterPointShapes = memoize(<T>(shapes: Shape<T>[]): PointShape<T>[] =>\n    shapes.filter(isPointShape),\n)\n\n/**\n * Redduces a list of [[PointShape]] into a list of points\n */\nexport const convertPointShapesToListOfPoints = memoize(<T>(pointShapes: PointShape<T>[]) =>\n    pointShapes.map(pointShape => pointShape.shape),\n)\nexport const convertLineShapesToListOfPoints = memoize(<T>(lineShapes: LineShape<T>[]) =>\n    lineShapes.flatMap(lineShape => lineShape.shape),\n)\nexport const convertPolygonShapesToListOfPoints = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape => polygonShape.shape.flat()),\n)\nexport const convertPolygonShapesToListOfLines = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape =>\n        polygonShape.shape.flatMap(ring => {\n            const [a, b, ...c] = ring\n            return c.reduce(\n                (acc, next) => {\n                    if (acc.length > 0) {\n                        const [, p] = last(acc)\n                        acc.push([p, next])\n                    }\n                    return acc\n                },\n                [[a, b]] as [Point, Point][],\n            )\n        }),\n    ),\n)\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfPoints = memoize(<T>(shapes: Shape<T>[]): Point[] => [\n    ...convertPointShapesToListOfPoints(filterPointShapes(shapes)),\n    ...convertLineShapesToListOfPoints(filterLineShapes(shapes)),\n    ...convertPolygonShapesToListOfPoints(filterPolygonShapes(shapes)),\n])\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfLines = memoize(<T>(shapes: Shape<T>[]): [Point, Point][] =>\n    convertPolygonShapesToListOfLines(filterPolygonShapes(shapes)),\n)\n","export default <T>(value: number | T): value is T => typeof value !== 'number'\n","import { Observable, concat, merge, of, combineLatest } from 'rxjs'\nimport { take, tap, filter, scan, mapTo, takeWhile, map } from 'rxjs/operators'\n\nimport { cancelKey$, enterKey$, ofKeyCode, undoKey$, redoKey$ } from '../observables'\nimport { AddEventTypes, submitNewPolygon, cancelNewPolygon, addPolygon } from './events'\nimport { Point } from '../types'\nimport { Event } from '../events'\nimport isNotNr from '../utils/isNotNr'\nimport { initial, head, tail, first, tuple } from '../utils'\n\n/**\n * Creates a program that will add a point to [[AddState]]'s `.newPolygon`\n * on every mosue click until the cancel or submit events are dispatched.\n */\nexport const makeAddPointToPolygon = <T>(\n    nextPoint$: Observable<Point>,\n    dispatch: (event: Event) => void,\n) => {\n    const allNewPoints$ = merge(nextPoint$, undoKey$, redoKey$).pipe(\n        scan(\n            ([currentPoints, redoPoints], event) =>\n                // if\n                Array.isArray(event)\n                    ? // then\n                      tuple([...currentPoints, event], [])\n                    : // else if\n                    event === 'undo' && currentPoints.length > 0\n                    ? // then\n                      tuple(initial(currentPoints), [\n                          currentPoints[currentPoints.length - 1],\n                          ...redoPoints,\n                      ])\n                    : // else if\n                    event === 'redo' && redoPoints.length > 0\n                    ? // then\n                      tuple([...currentPoints, head(redoPoints)], tail(redoPoints))\n                    : // else\n                      tuple(currentPoints, []),\n            tuple<Point[], Point[]>([], []),\n        ),\n        map(first),\n    )\n\n    const pressedEnter$ = enterKey$.pipe(mapTo('submit' as const))\n\n    const pressedCancel$ = cancelKey$.pipe(mapTo('cancel' as const))\n\n    type Emitted = 'submit' | 'cancel' | Point[]\n    type Accumulated = readonly [Emitted, Point[]]\n\n    return merge(pressedEnter$, pressedCancel$, allNewPoints$)\n        .pipe(\n            scan(\n                (acc, next) =>\n                    // if\n                    Array.isArray(next)\n                        ? // then\n                          ([next, next] as const)\n                        : // else\n                          ([next, acc[1]] as const),\n                // Initial scan value\n                [[], []] as Accumulated,\n            ),\n            takeWhile(\n                ([data, points]) =>\n                    // if\n                    data === 'cancel'\n                        ? // then\n                          false\n                        : // else if\n                        data === 'submit' && points.length > 2\n                        ? // then\n                          false\n                        : // else\n                          true,\n                // Inclusive takeWhile\n                true,\n            ),\n        )\n        .pipe(\n            // filter(([submit, cancel]) => submit || cancel),\n            tap(([event, points]) => {\n                if (event === 'submit' && points.length > 2) {\n                    dispatch(submitNewPolygon([points]))\n                } else if (event === 'cancel') {\n                    dispatch(cancelNewPolygon())\n                }\n            }),\n            map(([, points]) => points),\n        )\n}\n\n/**\n * Creates a program for adding new polygons.\n */\nexport default <T>(\n    nextPoint$: Observable<Point>,\n    addPolygonEvent$: Observable<AddEventTypes.AddPolygon>,\n    dispatch: (event: Event) => void,\n): Observable<Point[]> =>\n    concat(\n        merge(\n            concat(\n                // Await pressing key \"a\" or \"A\"\n                ofKeyCode([65, 97]).pipe(take(1)),\n                // Dispatch \"AddPolygon\" event\n                of(addPolygon()).pipe(tap(dispatch)),\n            ).pipe(filter(isNotNr)),\n            addPolygonEvent$,\n        ).pipe(take(1)),\n        makeAddPointToPolygon(nextPoint$, dispatch),\n        // Emit a final empty list of points once we are done.\n        of([] as Point[]),\n    ).pipe(filter((data): data is Point[] => Array.isArray(data)))\n","import _ from 'lodash'\n\nimport {\n    AllGeoJSON,\n    Feature,\n    FeatureCollection,\n    GeoJSONObject,\n    Geometries,\n    GeometryCollection,\n    MultiPolygon,\n    Polygon,\n    Position,\n    Types as GeoJSONTypes,\n} from '@turf/helpers'\n\nimport {\n    PolyLike,\n    PositionLike,\n    QFeature,\n    QFeatureCollection,\n    QMultiPolygon,\n    QPolygon,\n    QPolyLike,\n    QPosition,\n} from './types'\nimport { Point } from '../types'\n\ntype Project = (xy: number[]) => number[]\n\ninterface Collect {\n    coordinates: QPosition[]\n    lines: [QPosition, QPosition][]\n}\n\nconst defaultCollect = (): Collect => ({ coordinates: [], lines: [] })\n\nexport const pointPixelsAreEqual = ([x1, y1]: PositionLike, [x2, y2]: PositionLike): boolean => {\n    console.log(`${x1} === ${x2} && ${y1} === ${y2}`)\n    const eq = _.isEqual([x1, y1], [x2, y2])\n    console.log('Eq: ' + eq)\n    return eq\n}\n\nexport const projectGeometry = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Polygon | MultiPolygon,\n): QPolygon | QMultiPolygon => {\n    switch (geom.type) {\n        case 'MultiPolygon':\n            return projectMultiPolygon(project)(collect)(geom)\n        case 'Polygon':\n            return projectPolygon(project)(collect)(geom)\n        default:\n            return geom\n    }\n}\n\nexport const projectGeoJSON = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: PolyLike,\n): QPolyLike => {\n    switch (geom.type) {\n        case 'FeatureCollection':\n            return projectFeatureCollection(project)(collect)(geom as any)\n        case 'Feature':\n            return projectFeature(project)(collect)(geom)\n        // case 'GeometryCollection':\n        //   return projectGeometryCollection(project)(collect)(geom)\n        default:\n            return projectGeometry(project)(collect)(geom)\n    }\n}\n\nexport const projectFeature = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Feature<Polygon | MultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    geometry: projectGeometry(project)(collect)(geom.geometry),\n})\n\nexport const projectFeatureCollection = (project: Project) => (\n    collect: Collect = defaultCollect(),\n) => (\n    geom: FeatureCollection<Polygon | MultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    features: geom.features.map(projectFeature(project)(collect)),\n})\n\n// export const projectGeometryCollection = (project: Project) => (collect: Collect = defaultCollect()) => (\n//   geom: any\n// ): GeometryCollection => ({\n//   ...geom,\n//   geometries: geom.geometries.map(projectGeometry(project)(collect))\n// })\n\nexport const projectMultiPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: MultiPolygon,\n): QMultiPolygon => ({\n    ...polygon,\n    coordinates: polygon.coordinates.map(poly => poly.map(projectPositions(project)(collect))),\n})\n\nexport const projectPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: Polygon,\n): QPolygon => {\n    return {\n        ...polygon,\n        coordinates: polygon.coordinates.map(projectPositions(project)(collect)),\n    }\n}\n\nexport const projectPositions = (project: Project) => (collect: Collect = defaultCollect()) => (\n    coords: Position[],\n): QPosition[] =>\n    coords.map((coord, index) => {\n        const projected = project(coord)\n\n        const point: QPosition = [projected[0], projected[1], coord[0], coord[1]]\n        collect.coordinates.push(point)\n\n        if (index > 0) {\n            collect.lines.push([collect.coordinates[collect.coordinates.length - 2], point])\n\n            if (index === coords.length - 1) {\n                collect.lines.push([\n                    point,\n                    collect.coordinates[collect.coordinates.length - coords.length],\n                ])\n            }\n        }\n\n        return point\n    })\n\nexport const pointToLineDistance = ([x, y]: number[], [[x1, y1], [x2, y2]]: number[][]) => {\n    const A = x - x1\n    const B = y - y1\n    const C = x2 - x1\n    const D = y2 - y1\n\n    const dot = A * C + B * D\n    const lenSq = C * C + D * D\n    let param = -1\n    if (lenSq !== 0) {\n        // in case of 0 length line\n        param = dot / lenSq\n    }\n\n    let xx: number\n    let yy: number\n\n    if (param < 0) {\n        xx = x1\n        yy = y1\n    } else if (param > 1) {\n        xx = x2\n        yy = y2\n    } else {\n        xx = x1 + param * C\n        yy = y1 + param * D\n    }\n\n    const dx = x - xx\n    const dy = y - yy\n    return [[xx, yy], Math.sqrt(dx * dx + dy * dy)] as [number[], number]\n}\n\n/**\n *\n * @param position\n * @param lines\n */\nexport const findLineSnapPosition = (\n    [x, y, lng, lat]: [number, number, number, number],\n    lines: [[number, number, number, number], [number, number, number, number]][],\n) => {\n    let point: [number, number] | undefined\n    let distance = -1\n    let line: [[number, number, number, number], [number, number, number, number]] | undefined\n\n    lines.find((poly): boolean => {\n        const [[x1, y1, lng1, lat1], [x2, y2, lng2, lat2]] = poly\n        const [xy, dxy] = pointToLineDistance([x, y], [[x1, y1], [x2, y2]])\n\n        if (dxy <= 5) {\n            point = xy as [number, number]\n            distance = dxy\n            line = poly\n\n            return true\n        }\n\n        return false\n    })\n\n    if (distance >= 0 && point != null && line != null) {\n        return { point, distance, line }\n    }\n\n    return undefined\n}\n\nconst fromQPosition2Position = ([, , lng, lat]: QPosition): Position => [lng, lat]\n\nconst fromQPositions2Positions = (qPositions: QPosition[]): Position[] =>\n    qPositions.map(fromQPosition2Position)\n\nconst fromQPositionsSets2PositionsSets = (sets: QPosition[][]): Position[][] =>\n    sets.map(fromQPositions2Positions)\n\nconst fromQPolygon2Polygon = (qPolygon: QPolygon): Polygon => {\n    return {\n        ...qPolygon,\n        coordinates: fromQPositionsSets2PositionsSets(qPolygon.coordinates),\n    }\n}\n\nconst fromQMultiPolygon2MultiPolygon = (qMultiPolygon: QMultiPolygon): MultiPolygon => {\n    return {\n        ...qMultiPolygon,\n        coordinates: qMultiPolygon.coordinates.map(fromQPositionsSets2PositionsSets),\n    }\n}\n\nconst fromQGeometry2Geometry = (geometry: QPolygon | QMultiPolygon) => {\n    if (geometry.type === 'MultiPolygon') {\n        return fromQMultiPolygon2MultiPolygon(geometry)\n    }\n\n    return fromQPolygon2Polygon(geometry)\n}\n\nconst fromQFeature2Feature = (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): Feature<Polygon | MultiPolygon> => {\n    return {\n        ...feature,\n        geometry: fromQGeometry2Geometry(feature.geometry),\n    }\n}\n\nexport const fromQLikeToPolyLike = (qLike: QPolyLike): PolyLike => {\n    if (qLike.type === 'FeatureCollection') {\n        return {\n            ...qLike,\n            features: qLike.features.map(fromQFeature2Feature),\n        }\n    } else if (qLike.type === 'Feature') {\n        return fromQFeature2Feature(qLike)\n    }\n\n    return fromQGeometry2Geometry(qLike)\n}\n\nexport const mapGeometry = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (geometry: QPolygon | QMultiPolygon): QPolygon | QMultiPolygon => {\n    const nextGeometry = f(geometry)\n\n    if (nextGeometry !== geometry) {\n        return nextGeometry\n    }\n\n    return geometry\n}\n\nexport const mapFeature = (f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon) => (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => {\n    const nextGeometry = f(feature.geometry)\n\n    if (nextGeometry !== feature.geometry) {\n        return {\n            ...feature,\n            geometry: nextGeometry,\n        }\n    }\n\n    return feature\n}\n\nexport const mapFeatureCollection = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (\n    featureCollection: QFeatureCollection<QPolygon | QMultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => {\n    const nextFeatures: QFeature<QPolygon | QMultiPolygon>[] = []\n    let didChange = false\n\n    featureCollection.features.forEach(feature => {\n        const nextFeature = mapFeature(f)(feature)\n\n        if (nextFeature !== feature) {\n            didChange = true\n            nextFeatures.push(nextFeature)\n        }\n    })\n\n    if (didChange) {\n        return {\n            ...featureCollection,\n            features: nextFeatures,\n        }\n    }\n\n    return featureCollection\n}\n\nexport const mapPolyLike = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (polyLike: QPolyLike): QPolyLike => {\n    if (polyLike.type === 'Feature') {\n        return mapFeature(f)(polyLike)\n    } else if (polyLike.type === 'FeatureCollection') {\n        return mapFeatureCollection(f)(polyLike)\n    }\n\n    return mapGeometry(f)(polyLike)\n}\n\nexport const injectLineSnapPosition = (\n    ring: QPosition[],\n    line: [QPosition, QPosition],\n    point: QPosition,\n) => {\n    let didInject = false\n\n    const nextRing = ring.reduce(\n        (acc, coord) => {\n            const previous = acc[acc.length - 1]\n\n            if (\n                didInject === false &&\n                previous &&\n                pointPixelsAreEqual(previous, line[0]) &&\n                pointPixelsAreEqual(coord, line[1])\n            ) {\n                didInject = true\n                acc.push(point, coord)\n            } else {\n                acc.push(coord)\n            }\n\n            return acc\n        },\n        [] as QPosition[],\n    )\n\n    return { didInject, ring: nextRing }\n}\n\nexport const mapMouseEventToCoords = (evt: MouseEvent): [number, number] => [\n    evt.offsetX,\n    evt.offsetY,\n]\n","import {\n    ConnectableObservable,\n    fromEvent,\n    Observable,\n    of,\n    OperatorFunction,\n    race,\n    Subject,\n} from 'rxjs'\nimport { filter, map, multicast, publish, switchMapTo, take, tap } from 'rxjs/operators'\n\nimport { Either, left, right } from 'fp-ts/lib/Either'\n\nimport { mapMouseEventToCoords } from './utils'\n\nexport const toMulticast = <T>(\n    observable: Observable<T>,\n    connect = true,\n): ConnectableObservable<T> => {\n    const publishedObservable: ConnectableObservable<T> = observable.pipe(publish()) as any\n\n    if (connect === true) {\n        publishedObservable.connect()\n    }\n\n    return publishedObservable\n}\n\n/**\n *\n * @param event\n */\nexport const createEventObservableCreator = <E = MouseEvent>(event: string) => (\n    mouseCanvas: HTMLCanvasElement,\n) => toMulticast(fromEvent<E>(mouseCanvas, event))\n\n/**\n *\n */\nexport const createMouseMoveObservable = createEventObservableCreator<MouseEvent>('mousemove')\n\n/**\n *\n */\nexport const createMouseDownObservable = createEventObservableCreator<MouseEvent>('mousedown')\n\n/**\n *\n */\nexport const createMouseUpObservable = createEventObservableCreator<MouseEvent>('mouseup')\n\n/**\n *\n */\nexport const createMouseClickObservable = createEventObservableCreator<MouseEvent>('click')\n\nexport const createMouseMovePosObservable = (mouseMove$: Observable<MouseEvent>) =>\n    mouseMove$.pipe(map(mapMouseEventToCoords))\n\nexport const createMouseDownPosObservable = (mouseDown$: Observable<MouseEvent>) =>\n    mouseDown$.pipe(map(mapMouseEventToCoords))\n\nexport const createMouseUpPosObservable = (mouseUp$: Observable<MouseEvent>) =>\n    mouseUp$.pipe(map(mapMouseEventToCoords))\n\nexport const createMouseClickPosObservable = (mouseClick$: Observable<MouseEvent>) =>\n    mouseClick$.pipe(map(mapMouseEventToCoords))\n\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress') // .pipe(tap(console.info))\n\nexport const keyPressCode$ = keyPress$.pipe(map(evt => evt.keyCode))\n\nexport const ofKeyCode = (keyCode: number) =>\n    keyPressCode$.pipe(filter(pressedKeyCode => pressedKeyCode === keyCode))\n\nexport const enterKey$ = ofKeyCode(13)\n\nexport const cancelKey$ = ofKeyCode(99)\n\n/**\n * From one observable to a race between 2 others to a observable of Eihter<L, R>\n * @param observable\n */\nexport const fromObservableToEither =\n    // From observable T\n    <A>(observable: Observable<A>) =>\n        // with observable L\n        <L>(leftObservable: Observable<L>) =>\n            // And observable R\n            <R>(rightObservable: Observable<R>): Observable<Either<L, R>> =>\n                // To observable Either<L, R>\n                observable.pipe(\n                    switchMapTo(\n                        // Race left or right\n                        race(\n                            leftObservable.pipe(map((evt: L): Either<L, R> => left(evt))),\n                            rightObservable.pipe(map((evt: R): Either<L, R> => right(evt))),\n                        ).pipe(take(1)),\n                    ),\n                )\n\nexport const mapRight = <L, R>(observable: Observable<Either<L, R>>) =>\n    observable.pipe(\n        filter(lr => lr.isRight()),\n        map(rightEither => rightEither.value as R),\n    )\n\nexport const mapRightTo = <L, R>(observable: Observable<Either<L, R>>) => (\n    operatorFn: OperatorFunction<R, R>,\n) => mapRight(observable).pipe(operatorFn)\n\nexport const mapLeft = <L, R>(observable: Observable<Either<L, R>>) =>\n    observable.pipe(\n        filter(lr => lr.isLeft()),\n        map(leftEither => leftEither.value as L),\n    )\n\nexport const mapLeftTo = <L, R>(observable: Observable<Either<L, R>>) => (\n    operatorFn: OperatorFunction<L, L>,\n) => mapLeft(observable).pipe(operatorFn)\n\nexport default (mouseCanvas: HTMLCanvasElement, canvas: HTMLCanvasElement) => {\n    const mouseMove$ = createMouseMoveObservable(mouseCanvas)\n    const mouseDown$ = createMouseDownObservable(mouseCanvas)\n    const mouseUp$ = createMouseUpObservable(mouseCanvas)\n    const mouseClick$ = createMouseClickObservable(mouseCanvas)\n\n    const mouseMovePos$ = createMouseMovePosObservable(mouseMove$)\n    const mouseDownPos$ = createMouseDownPosObservable(mouseDown$)\n    const mouseUpPos$ = createMouseUpPosObservable(mouseUp$)\n    const mouseClickPos$ = createMouseClickPosObservable(mouseClick$)\n\n    const mouseMoveEventOrUpPos$ = fromObservableToEither(mouseDown$)(mouseMove$)(mouseUpPos$)\n    const mouseUpEventOrMovePos$ = fromObservableToEither(mouseDown$)(mouseUp$)(mouseMovePos$)\n\n    const mapToUpPosFromEither = mapRightTo(mouseMoveEventOrUpPos$)\n    const mapToMovePosFromUpMoveEither = mapLeftTo(mouseUpEventOrMovePos$)\n\n    return {\n        mouseMove$,\n        mouseDown$,\n        mouseUp$,\n        mouseClick$,\n        mouseMovePos$,\n        mouseDownPos$,\n        mouseUpPos$,\n        mouseClickPos$,\n        keyPress$,\n        enterKey$,\n        mouseMoveEventOrUpPos$,\n        mouseUpEventOrMovePos$,\n        mapToUpPosFromEither,\n        mapToMovePosFromUpMoveEither,\n        toMulticast,\n    }\n}\n","import { fromEvent, merge, Subject, Observable, of, combineLatest, observable } from 'rxjs'\nimport {\n    map,\n    tap,\n    repeat,\n    filter,\n    scan,\n    mapTo,\n    switchMap,\n    startWith,\n    switchMapTo,\n    mergeMap,\n    withLatestFrom,\n} from 'rxjs/operators'\n\nimport KDBush from 'kdbush'\nimport createPolyBush from './rbush'\n\nimport { StateType, State, Point, Shape, ShapeTypes, ConvertPoint, Snap, SnapType } from './types'\nimport mapMouseEventToCoords from './utils/mapMouseEventToCoords'\nimport pencil_ from './pencils'\nimport { Event } from './events'\nimport transition from './reducers'\nimport { mapFirst, ofKeyCode, makeFromEventType, makeEventTypes } from './observables'\nimport {\n    convertShapesToListOfPoints,\n    filterPolygonShapes,\n    convertPolygonShapesToListOfLines,\n    convertShapesToListOfLines,\n} from './selectors'\n\nimport { AddState } from './add/types'\nimport { addPolygon, AddEventTypes, SubmitNewPolygonEvent } from './add/events'\nimport makeAddPolygonProgram from './add/observables'\nimport { isPolygonShape } from './utils'\nimport { toMulticast } from './legacy/observables'\nimport { findLineSnapPosition } from './legacy/utils'\nimport { point } from 'leaflet'\n\nofKeyCode([120, 88]).subscribe(() => console.clear())\n\nconst translateOffsetOfCanvas = (canvas: HTMLCanvasElement) => ([x, y]: [\n    number,\n    number,\n]): Point => {\n    const [tx = 0, ty = 0] = (\n        canvas.style.transform.match(/translate3d\\((-?\\d+)px[, ]+(-?\\d+)px[, ]+(-?\\d+)/) || []\n    )\n        .map(str => +str)\n        .filter(n => !isNaN(n))\n\n    return [x + tx, y + ty] as [number, number]\n}\n\nexport default <T>(convert: ConvertPoint, shapes$: Observable<Shape<T>[]>) => (\n    canvas: HTMLCanvasElement,\n    mouseCanvas = canvas,\n) => {\n    const ctx = canvas.getContext('2d')\n    const mouseCtx = mouseCanvas.getContext('2d')\n    const pencil = pencil_()(canvas)\n    const mousePencil = pencil_()(mouseCanvas)\n    const translateOffset = translateOffsetOfCanvas(canvas)\n\n    if (mousePencil && pencil && ctx != null && mouseCtx != null) {\n        canvas.style.cursor = 'none'\n        mouseCanvas.style.cursor = 'none'\n        /**\n         * Final API for drawing markers, polygons, and lines.\n         */\n\n        /**\n         * K-2 tree used to store all points that are present within\n         * the system and used to find points that are near the mouse\n         * position to snap to.\n         */\n        let pointsDb: KDBush.KDBush<Point> =\n            // @ts-ignore\n            new KDBush([])\n\n        const polyDb = createPolyBush()\n        let lineDb: [Point, Point][] = []\n\n        /**\n         * Observable for emitting events\n         */\n        const events$ = new Subject<Event>()\n\n        /**\n         * Observable emits all event types that are dispatched\n         */\n        const eventTypes$ = makeEventTypes(events$)\n\n        /**\n         * Creates an observable that filters events by type\n         */\n        const fromEventType = makeFromEventType(eventTypes$)\n\n        /**\n         * Dispatches events\n         */\n        const dispatch = (event: Event) => events$.next(event)\n\n        /**\n         * Observable streaming current and previous state\n         */\n        const stateUpdates$ = new Subject<[State<T>, State<T>]>()\n\n        /**\n         * Filters state updates by checking if state has actually changed\n         */\n        const stateChanges$ = stateUpdates$.pipe(filter(([c, p]) => c !== p))\n\n        /**\n         * Maps state changes to actual state\n         */\n        const state$ = stateUpdates$.pipe(mapFirst)\n\n        /**\n         * Finds the nearest point a given point can snap to\n         */\n\n        const mapPointToSnapFn$ = shapes$.pipe(\n            startWith([]),\n            map(shapes => ([x, y, lng, lat]: Point): Snap => {\n                const pointSnap = convertShapesToListOfPoints(shapes)[pointsDb.within(x, y, 10)[0]]\n\n                if (pointSnap) {\n                    return { type: SnapType.Point as const, point: pointSnap }\n                }\n\n                const lineSnap = findLineSnapPosition([x, y, lng!, lat!], lineDb as any)\n\n                if (lineSnap) {\n                    const [x, y] = lineSnap.point\n                    const [lng, lat] = convert.to(lineSnap.point)\n                    return {\n                        distance: 4,\n                        line: (lineSnap.line as any) as [Point, Point],\n                        type: SnapType.Line,\n                        point: [x, y, lng, lat], // [lineSnap.point[0], lineSnap.point[1], lng, lat] as Point,\n                    }\n                }\n\n                return { type: SnapType.None as const, point: [x, y, lng, lat] as Point }\n            }),\n        )\n\n        /**\n         *\n         */\n        const updatePointsDb$ = shapes$.pipe(\n            tap(shapes => {\n                const polygons = filterPolygonShapes(shapes).map(item => item.shape)\n                lineDb = convertShapesToListOfLines(shapes)\n                polyDb.replace(polygons)\n            }),\n            map(convertShapesToListOfPoints),\n            tap(points => {\n                // @ts-ignore\n                pointsDb = new KDBush(points)\n            }),\n        )\n\n        let state: State<T> = {\n            value: StateType.Noop,\n        }\n\n        const setState = (nextState: State<T>, affectsHistory = true) => {\n            const prev = state\n\n            state = nextState\n            stateUpdates$.next([state, prev])\n        }\n\n        const mouseClick$ = fromEvent<MouseEvent>(mouseCanvas, 'click')\n        const mouseClickOffset$ = mouseClick$.pipe(map(e => mapMouseEventToCoords(e)))\n\n        const translatedMouseClick$ = mouseClickOffset$.pipe(map(translateOffset))\n        const snappedClick$ = translatedMouseClick$.pipe(\n            withLatestFrom(mapPointToSnapFn$),\n            map(([point, mapPointToSnap]) => mapPointToSnap(point)),\n        )\n\n        const mouseMove$ = fromEvent<MouseEvent>(mouseCanvas, 'mousemove')\n        const mouseMoveOffset$ = mouseMove$.pipe(map(e => mapMouseEventToCoords(e)))\n        const translatedMousemMove$ = mouseMoveOffset$.pipe(map(translateOffset))\n\n        const mousePositionSnapped$ = toMulticast(\n            translatedMousemMove$.pipe(\n                map(point => {\n                    const [px, py] = point\n                    const [lng, lat] = convert.to(point)\n\n                    return [px, py, lng, lat] as Point\n                }),\n                withLatestFrom(mapPointToSnapFn$),\n                map(([point, mapPointToSnap]) => mapPointToSnap(point)),\n            ),\n        )\n\n        const mousePositionSnappedPoint$ = mousePositionSnapped$.pipe(map(({ point }) => point))\n\n        const hoverIndex$ = translatedMousemMove$.pipe(\n            map(point => polyDb.searchPoint(point).map(item => item.index)),\n            scan((acc, next) => [acc[1], next] as const, [[], []] as readonly [number[], number[]]),\n            filter(([a, b]) => a.length !== b.length || a.some((n, index) => n !== b[index])),\n            map(([, b]) => b),\n        )\n\n        const reduceActions$ = events$.pipe(\n            tap(event => {\n                const nextState = transition(state, event)\n\n                setState(nextState)\n            }),\n        )\n\n        const addPolygonProgram$ = makeAddPolygonProgram(\n            // snappedClick$.pipe(map(({ point }) => point)),\n            mouseClick$.pipe(\n                withLatestFrom(mousePositionSnappedPoint$),\n                map(([, point]) => point),\n            ),\n            fromEventType(AddEventTypes.AddPolygon),\n            dispatch,\n        ).pipe(repeat())\n\n        const draw$ = combineLatest(\n            shapes$.pipe(startWith([] as Shape<T>[])),\n            hoverIndex$.pipe(startWith([] as number[])),\n        ).pipe(\n            tap(data => {\n                const [shapes, hoverIndices] = data\n\n                pencil.resetStyles()\n\n                // Clear the canvas\n                pencil.eraser()\n\n                // Draw existing polygons\n                const polygons = filterPolygonShapes(shapes)\n                polygons.forEach((shape, index) => {\n                    const hovering = hoverIndices.includes(index)\n                    pencil.polygon({ ...shape, meta: { hovering, id: shape.meta } })\n                    pencil.resetStyles()\n                })\n            }),\n        )\n\n        const subscription = merge(\n            reduceActions$,\n            updatePointsDb$,\n            draw$,\n            combineLatest(\n                mousePositionSnapped$,\n                combineLatest(shapes$, addPolygonProgram$.pipe(startWith([] as Point[]))).pipe(\n                    map(([, points]) =>\n                        points.map(point => {\n                            const [, , lng, lat] = point\n                            if (lng != null && lat != null) {\n                                const [x, y] = convert.from([lng, lat])\n\n                                return [x, y, lng, lat] as Point\n                            }\n\n                            return point\n                        }),\n                    ),\n                ),\n            ).pipe(\n                tap(([mousePosition, newPolygon]) => {\n                    mousePencil.eraser()\n\n                    // Draw potential new polygon\n                    // if (state.value === StateType.AddPolygon) {\n                    if (newPolygon.length > 1) {\n                        mousePencil.polygon({\n                            type: ShapeTypes.Polygon,\n                            shape: [[...newPolygon, mousePosition.point]],\n                            // TODO Provide a way to create T for new polygons\n                            meta: { id: -1, hovering: true },\n                        })\n\n                        mousePencil.resetStyles()\n                    } else if (newPolygon.length === 1) {\n                        mousePencil.line({\n                            type: ShapeTypes.Line,\n                            shape: [...newPolygon, mousePosition.point],\n                            meta: (undefined as any) as T,\n                        })\n                        pencil.resetStyles()\n                    }\n\n                    newPolygon.forEach(point =>\n                        mousePencil.marker({\n                            type: ShapeTypes.Point,\n                            shape: point,\n                            meta: {},\n                        }),\n                    )\n\n                    if (mousePosition.type === SnapType.Line) {\n                        mouseCtx.beginPath()\n                        mouseCtx.moveTo(mousePosition.line[0][0], mousePosition.line[0][1])\n                        mouseCtx.lineTo(mousePosition.line[1][0], mousePosition.line[1][1])\n                        mouseCtx.strokeStyle = 'Cyan'\n                        mouseCtx.stroke()\n                        // ctx\n                    }\n                    mousePencil.cursor(mousePosition)\n                }),\n            ),\n        ).subscribe()\n\n        return {\n            done: () => {\n                subscription.unsubscribe()\n            },\n            api: {\n                addPolygon: () => dispatch(addPolygon()),\n                onAdd$: events$.pipe(\n                    filter(\n                        (event): event is SubmitNewPolygonEvent =>\n                            event.type === AddEventTypes.SubmitNewPolygon,\n                    ),\n                ),\n            },\n        }\n    }\n\n    throw new Error('Canvas 2D Rendering Context Not Available')\n}\n","import core from '../core'\nimport { Point, ShapeTypes, PolygonShape, Shape, ConvertPoint } from '../core/types'\n\nimport { of, Subject } from 'rxjs'\nimport geojson from '../../data/nl.json'\nimport { tap } from 'rxjs/operators'\nimport { Polygon as P, MultiPolygon as M } from '@turf/helpers'\n\nconst data: typeof geojson.features = geojson.features\n\ntype G = typeof data[0]['geometry']\n\nconst isP = (g: G): g is P => g.type === 'Polygon'\nconst isM = (g: G): g is M => g.type === 'MultiPolygon'\n\nconst convertGeoJson = (from: ConvertPoint['from']): PolygonShape<number>[] =>\n    // @ts-ignore\n    data\n        // .filter(feature => true || feature.properties.ZoneID % 2 === 0)\n        .flatMap((feature): Shape<number>[] => {\n            const geom = feature.geometry\n\n            if (isP(geom)) {\n                return [\n                    {\n                        type: ShapeTypes.Polygon,\n                        shape: geom.coordinates.map(ring => ring.map(point => from(point))),\n\n                        meta: Math.floor(Math.random() * 20) + 1,\n                    },\n                ]\n            } else if (isM(geom)) {\n                return geom.coordinates.map(poly => {\n                    return {\n                        type: ShapeTypes.Polygon,\n                        shape: poly.map(ring => ring.map(point => from(point))),\n                        meta: Math.floor(Math.random() * 20) + 1,\n                    }\n                })\n            }\n            return []\n        })\n\nexport default (convert: ConvertPoint) => (canvas: HTMLCanvasElement, mouseCanvas = canvas) => {\n    const shapes$ = new Subject<PolygonShape<number>[]>()\n\n    const api = core(convert, shapes$)(canvas, mouseCanvas)\n\n    const refresh = () => shapes$.next(convertGeoJson(convert.from))\n\n    api.api.onAdd$\n        .pipe(\n            tap(event => {\n                const coordinates = event.payload[0].map(px => convert.to(px))\n                coordinates.push(coordinates[0])\n                data.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Polygon',\n                        coordinates: [coordinates],\n                    },\n                    // @ts-ignore\n                    properties: {\n                        // ZoneID: 2,\n                    },\n                })\n\n                refresh()\n            }),\n        )\n        .subscribe()\n\n    refresh()\n\n    return Object.assign(api, { refresh })\n}\n","import React from 'react'\nimport { Map as ReactLeafletMap, Popup, TileLayer, useLeaflet, Pane, Circle } from 'react-leaflet'\nimport * as _ from 'lodash'\n\nimport '../../leaflet/leaflet.css'\nimport { canvas, Map as LeafletMap } from 'leaflet'\nimport { geoJSON } from 'leaflet'\n\nimport topolokus from '../../modules/geojson'\n\n// const position2: [number, number] = [51.885, 5.0509] // [51.505, -0.09]\n\nimport geojson from '../../data/geosample.json'\nimport { Point } from '../../modules/core/types'\n\nconst position: [number, number] = [52.1326, 5.2913] // [51.505, -0.09]\nconst Map: React.FC = (props: { children?: React.ReactNode }) => (\n    <ReactLeafletMap center={position} zoom={8}>\n        <TileLayer\n            url=\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n            attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n        />\n\n        <Pane name=\"canvas\">\n            {props.children}\n            <div>xyt</div>\n        </Pane>\n    </ReactLeafletMap>\n)\n\nconst createCanvasLayer = (pane?: string) => canvas({ padding: 0, pane })\n\n// type CanvasLayer = undefined | ReturnType<typeof createCanvasLayer>\n\nconst toLngLat = (map: LeafletMap) => ([x, y, lng, lat]: Point): [number, number] => {\n    const point = map.layerPointToLatLng([x, y])\n    return [lng || point.lng, lat || point.lat]\n}\n\nconst fromLngLat = (map: LeafletMap) => ([lng, lat]: number[]): Point => {\n    const point = map.latLngToLayerPoint([lat, lng + 0])\n    return [point.x, point.y, lng, lat]\n}\n\nconst Canvas = () => {\n    const context = useLeaflet()\n\n    React.useEffect(() => {\n        if (context.map != null) {\n            const map = context.map\n            const canvasLayer = createCanvasLayer(context.pane)\n            const mouseCanvasLayer = createCanvasLayer(context.pane)\n            canvasLayer.addTo(context.map)\n            mouseCanvasLayer.addTo(context.map)\n            // @ts-ignore\n            // const layer = geoJSON(geojson.features[0].geometry as any, { renderer: canvasLayer })\n\n            // layer.addTo(context.map)\n\n            Object.assign(window, { canvasLayer })\n\n            const elCanvas: HTMLCanvasElement = (canvasLayer as any)._container\n            const elMouseCanvasLayer: HTMLCanvasElement = (mouseCanvasLayer as any)._container\n\n            const api = topolokus({\n                from: fromLngLat(map),\n                to: toLngLat(map),\n            })(elCanvas, elMouseCanvasLayer)\n\n            const onZoomOrMove = _.debounce(api.refresh)\n\n            // map.dragging.disable()\n            Object.assign(window, { api })\n\n            map.addEventListener('moveend zoomend', onZoomOrMove)\n\n            return () => {\n                map.removeEventListener('moveend zoomend', onZoomOrMove)\n                map.removeLayer(canvasLayer)\n                // map.removeLayer(mouseCanvasLayer)\n                api.done()\n            }\n        }\n    }, [\n        context.map,\n        context.map && context.map.getCenter().lat,\n        context.map && context.map.getCenter().lng,\n    ])\n\n    return null\n}\n\nexport default () => {\n    return (\n        <Map>\n            <Canvas />\n        </Map>\n    )\n}\n","import React from 'react'\nimport './App.css'\n\nimport Map from './apps/map'\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"App\">\n            <div className=\"App-header\">\n                <p>\n                    <button\n                        onClick={\n                            // @ts-ignore\n                            () => api.api.addPolygon()\n                        }\n                    >\n                        ADD POLYGON\n                    </button>\n                </p>\n                <ol>\n                    <li>\n                        Press <i>&quot;a&quot;</i> or click the <i>&quot;Add Polygon&quot;</i>{' '}\n                        button to start drawing.\n                    </li>\n                    <li>\n                        Press <i>&quot;Enter&quot;</i> to finish drawing. You can only finish after\n                        at least 3 points are drawn.\n                    </li>\n                    <li>\n                        Press <i>&quot;c&quot;</i> to cancel the operation.\n                    </li>\n                    <li>\n                        Supports:\n                        <ul>\n                            <li>Snapping</li>\n                            <li>Undo & redo with Ctrl-Z/Y while adding points</li>\n                        </ul>\n                    </li>\n                </ol>\n            </div>\n            <div id=\"map\">\n                <Map />\n            </div>\n        </div>\n    )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}