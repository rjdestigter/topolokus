{"version":3,"sources":["modules/core/utils/bbox.ts","modules/core/utils/inBbox.ts","modules/core/utils/booleanPointInPolygon.ts","modules/core/rbush.ts","modules/core/types.ts","modules/core/utils/mapMouseEventToCoords.ts","modules/core/add/events.ts","modules/core/pencils/marker.ts","modules/core/pencils/polygon.ts","modules/core/pencils/line.ts","modules/core/pencils/resetStyles.ts","modules/core/add/reducer.ts","modules/core/utils/index.ts","modules/core/observables.ts","modules/core/selectors.ts","modules/core/utils/isNotNr.ts","modules/core/add/observables.ts","modules/core/legacy/utils.ts","modules/core/legacy/observables.ts","modules/core/index.ts","modules/core/pencils/index.ts","modules/core/reducers.ts","modules/geojson/index.ts","apps/map/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["polygon","reduce","acc","x","y","minX","minY","maxX","Infinity","maxY","point","bbox","inRing","ring","ignoreBoundary","isInside","length","slice","i","j","xi","yi","xj","yj","ShapeTypes","StateType","EventTypes","RBush","RbushClass","polygonToItem","index","Object","assign","boundingBox","insertPolygons","tree","state","polygons","items","map","count","console","warn","load","searchByBoundingBox","search","searchByPoint","filter","item","options","inBBox","insidePoly","inHole","k","booleanPointInPolygon","AddEventTypes","evt","offsetX","offsetY","ctx","context","beginPath","arc","shape","Math","PI","fillStyle","fill","stroke","closePath","colors","n","marker","forEach","hx","hy","t","moveTo","lineTo","meta","id","hovering","strokeStyle","lineWidth","lineJoin","line","type","Point","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","addPolygon","AddPolygon","event","value","Noop","fromNoopToAddPolygon","AddPointToNewPolygon","addPointToNewPolygon","payload","SubmitNewPolygon","submitNewPolygon","CancelNewPolygon","cancelNewPolygon","emptyArray","memoize","f","previousA","previousB","a","Array","isArray","isPolygonShape","Polygon","isPointShape","isLineShape","Line","mapFirst","keyPress$","fromEvent","document","keyPressCode$","pipe","keyCode","ofKeyCode","pressedKeyCode","includes","enterKey$","cancelKey$","filterPolygonShapes","shapes","filterLineShapes","filterPointShapes","convertPointShapesToListOfPoints","pointShapes","pointShape","convertLineShapesToListOfLines","lineShapes","flatMap","lineShape","convertPolygonShapesToListOfPolygons","polygonShapes","polygonShape","flat","convertShapesToListOfPoints","initial","xs","clone","splice","tail","makeAddPointToPolygon","newPoint$","dispatch","undoKey$","tap","e","log","ctrlKey","mapTo","redoKey$","allNewPoints$","merge","scan","currentPoints","redoPoints","pressedEnter$","pressedCancel$","next","takeWhile","data","points","makeAddPolygonProgram","onMouseClick$","addPolygonEvent$","concat","take","of","isNotNr","toMulticast","observable","connect","publishedObservable","publish","createEventObservableCreator","mouseCanvas","shapes$","canvas","getContext","pencil","api","finalMarker","defaultMarker","defaultPolygon","defaultLine","resetStyles","pencil_","pointsDb","KDBush","polyDb","window","insert","searchPoint","replace","clear","initialPolygons","createPolyBush","events$","Subject","fromEventType","eventTypes$","eventType","dispatchedEventType","makeFromEventType","makeEventTypes","stateUpdates$","state$","mapPointToSnap","pointSnap","shapesState","within","updatePointsDb$","mousePosition","selectedIndices","subscribe","history","future","setState","nextState","affectsHistory","prev","push","mapMouseEventToCoords","onMouseMove$","mousePosition$","onMouseClickTranslated$","style","transform","match","str","isNaN","tx","onMouseMoveTranslated$","hoverIndex$","b","some","hoverIndexNoop$","switchMap","updateStateWithMousePosition$","reduceActions$","addReducer","transition","groupCollapsed","groupEnd","addPolygonProgram$","repeat","draw$","combineLatest","startWith","newPolygon","hoverIndices","save","clearRect","width","height","setTransform","restore","undefined","subscription","pop","getState","getHistory","done","unsubscribe","onAdd$","Error","features","convert","core","info","refresh","from","feature","geom","geometry","coordinates","floor","random","g","isM","poly","px","to","properties","position","Map","props","center","zoom","TileLayer","url","attribution","Pane","name","children","toLngLat","lng","lat","layerPointToLatLng","fromLngLat","latLngToLayerPoint","Canvas","useLeaflet","React","useEffect","canvasLayer","pane","padding","addTo","elCanvas","_container","topolokus","onZoomOrMove","_","addEventListener","removeEventListener","removeLayer","getCenter","App","className","onClick","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.900f77c9.chunk.js","sourcesContent":["import { Polygon } from '../types'\n\nexport default (polygon: Polygon) =>\n    polygon[0].reduce(\n        (acc, [x, y]) => {\n            if (x < acc.minX) acc.minX = x\n            if (y < acc.minY) acc.minY = y\n            if (acc.maxX === Infinity || x > acc.maxX) acc.maxX = x\n            if (acc.maxY === Infinity || y > acc.maxY) acc.maxY = y\n            return acc\n        },\n        {\n            minX: Infinity,\n            minY: Infinity,\n            maxX: Infinity,\n            maxY: Infinity,\n        },\n    )\n","import { Point } from '../types'\n\ntype BBox = {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n}\n\nexport default (point: Point, bbox: BBox) =>\n    bbox.minX <= point[0] && bbox.minY <= point[1] && bbox.maxX >= point[0] && bbox.maxY >= point[1]\n","import { Polygon, Point, Line } from '../types'\nimport boundingBox from './bbox'\nimport inBBox from './inBbox'\n\nexport default function booleanPointInPolygon(\n    point: Point,\n    polygon: Polygon,\n    options: {\n        ignoreBoundary?: boolean\n    } = {},\n) {\n    const bbox = boundingBox(polygon)\n\n    // Quick elimination if point is not inside bbox\n    if (inBBox(point, bbox) === false) {\n        return false\n    }\n\n    let insidePoly = false\n\n    if (inRing(point, polygon[0], options.ignoreBoundary)) {\n        let inHole = false\n        let k = 1\n        // check for the point in any of the holes\n        while (k < polygon.length && !inHole) {\n            if (inRing(point, polygon[k], !options.ignoreBoundary)) {\n                inHole = true\n            }\n            k++\n        }\n        if (!inHole) {\n            insidePoly = true\n        }\n    }\n\n    return insidePoly\n}\n\nfunction inRing(point: Point, ring: Line, ignoreBoundary?: boolean) {\n    let isInside = false\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1)\n    }\n\n    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        const xi = ring[i][0]\n        const yi = ring[i][1]\n        const xj = ring[j][0]\n        const yj = ring[j][1]\n        const onBoundary =\n            point[1] * (xi - xj) + yi * (xj - point[0]) + yj * (point[0] - xi) === 0 &&\n            (xi - point[0]) * (xj - point[0]) <= 0 &&\n            (yi - point[1]) * (yj - point[1]) <= 0\n        if (onBoundary) {\n            return !ignoreBoundary\n        }\n        const intersect =\n            yi > point[1] !== yj > point[1] &&\n            point[0] < ((xj - xi) * (point[1] - yi)) / (yj - yi) + xi\n        if (intersect) {\n            isInside = !isInside\n        }\n    }\n\n    return isInside\n}\n","import bbox from '@turf/bbox'\nimport * as _ from 'lodash'\n\n// @ts-ignore\nimport RbushClass from 'rbush/index'\n\nimport { Polygon, Point } from './types'\n\nimport boundingBox from './utils/bbox'\nimport booleanPointInPolygon from './utils/booleanPointInPolygon'\n\ntype RBush<T = {}> = new (...args: any) => rbush.RBush<T>\n\nconst RBush: RBush = RbushClass\n\nconst polygonToItem = (polygon: Polygon, index: number) =>\n    Object.assign(boundingBox(polygon), { polygon, index })\n\ntype Item = ReturnType<typeof polygonToItem>\ntype Tree = rbush.RBush<Item>\n\nconst insertPolygons = (tree: Tree, state: { count: number }) => (polygons: Polygon[]) => {\n    // console.log(`Count: ${state.count}`)\n    const items = polygons.map((polygon, index) => {\n        // console.info(index, state.count, index + state.count + 1)\n        return polygonToItem(polygon, index + state.count + 1)\n    })\n    state.count += polygons.length\n    console.warn(`Inserting ${items.length}`)\n    tree.load(items)\n}\n\nconst insertPolgyon = (tree: rbush.RBush<Item>, state: { count: number }) => (polygon: Polygon) => {\n    state.count += 1\n    tree.insert(polygonToItem(polygon, state.count))\n}\n\nconst searchByBoundingBox = (tree: Tree) => (boundingBox: rbush.BBox) => tree.search(boundingBox) // .map(item => item.polygon)\n\nconst searchByPoint = (tree: Tree) => {\n    const search = searchByBoundingBox(tree)\n\n    return ([x, y]: Point) => {\n        const items = search({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y,\n        })\n\n        // items.length > 0 && console.log(items)\n        return items.filter(item => booleanPointInPolygon([x, y], item.polygon))\n    }\n}\n\nexport default (...initialPolygons: Polygon[]) => {\n    const tree: rbush.RBush<Item> = new RBush() as any\n    Object.assign(window, { tree })\n    const state = { count: -1 }\n\n    const insert = insertPolygons(tree, state)\n    const search = searchByBoundingBox(tree)\n    const searchPoint = searchByPoint(tree)\n\n    const replace = (polygons: Polygon[]) => {\n        state.count = -1\n        tree.clear()\n        insert(polygons)\n    }\n    insert(initialPolygons)\n\n    return {\n        insert,\n        search,\n        searchPoint,\n        replace,\n    }\n}\n","import { AddState } from './add/types'\n\n/** Type alias for pixels */\nexport type Pixel = number\n\n/** Type alias for x- and y coordinates */\nexport type Coordinate = number\n\n/**\n * An (x, y) coordiante. The first 2 number represent the pixel\n * cordiantes while the optional second set of numbers are the\n * origina coordiantes. For example longitude and lattitude values.\n *\n * The system preservers the original coordiantes to prevent having\n * to convert them back and forth if they aren't changed.\n */\nexport type Point = [Pixel, Pixel, Coordinate, Coordinate] | [Pixel, Pixel]\n\n/**\n * A list of 2- or more [[Point]]s\n *\n * I would've preferred to tyep it [Point, Point, ...Point[]]\n */\nexport type Line = Point[]\n\n/**\n * A list of list of points where the first element in the list\n * is clockwise and the rest of the list counter clockwise\n * representing holes.\n *\n * I would've preferred to type it: [Point, Point, Point, ...Point[]][]\n * since each ring should have at least 3 points.\n */\nexport type Polygon = Line[]\n\nexport enum ShapeTypes {\n    Point = 'Point',\n    Polygon = 'Polygon',\n    Line = 'Line',\n}\n\nexport type PointShape<T> = {\n    type: ShapeTypes.Point\n    shape: Point\n    meta: T\n}\n\nexport type PolygonShape<T> = {\n    type: ShapeTypes.Polygon\n    shape: Polygon\n    meta: T\n}\n\nexport type LineShape<T> = {\n    type: ShapeTypes.Line\n    shape: Line\n    meta: T\n}\n\nexport type Shape<T> = PointShape<T> | PolygonShape<T> | LineShape<T>\n\nexport enum StateType {\n    Noop = 'Noop',\n    AddPolygon = 'AddPolygon',\n}\n\n// State\nexport interface SharedState<T> {\n    readonly mousePosition: [Pixel, Pixel]\n    readonly hovering: boolean\n    // readonly hoverIndex: number\n    readonly selectedIndices: number[]\n}\n\nexport interface NoopState {\n    readonly value: StateType.Noop\n}\n\nexport type PossibleStates = NoopState | AddState\nexport type State<T> = SharedState<T> & PossibleStates\n\n// Actions\nexport enum EventTypes {\n    SelectPolygon = 'SelectPolygon',\n    EditPolygon = 'EditPolygon',\n    RemovePolygon = 'RemovePolygon',\n}\n","export default (evt: MouseEvent): [number, number] => [evt.offsetX, evt.offsetY]\n","import { Point, Polygon } from '../types'\n\n/**\n * Event type descriptors for the \"Add Polygon\" process\n */\nexport enum AddEventTypes {\n    AddPolygon = 'AddPolygon',\n    AddPointToNewPolygon = 'AddPointToNewPolygon',\n    SubmitNewPolygon = 'SubmitNewPolygon',\n    CancelNewPolygon = 'CancelNewPolygon',\n}\n\n/**\n * Event dispatched when the user wants to add a new polygon.\n */\nexport type AddPolygonEvent = {\n    type: AddEventTypes.AddPolygon\n}\n\n/**\n * Event dispatched when the user clicks on the canvas to add a new point to the polygon they are creating.\n */\nexport type AddPointToNewPolygonEvent = {\n    type: AddEventTypes.AddPointToNewPolygon\n    payload: Point\n}\n\n/**\n * Event dispatched when the user has finished creating a new polygon.\n */\nexport type SubmitNewPolygonEvent = {\n    type: AddEventTypes.SubmitNewPolygon\n    payload: Polygon\n}\n\n/**\n * Event dispatched when the user wants to cancel creating a new polygon.\n */\nexport type CancelNewPolygonEvent = {\n    type: AddEventTypes.CancelNewPolygon\n}\n\n/**\n * All possible events for the \"Add poloygon\" process\n */\nexport type AddEvent =\n    | AddPolygonEvent\n    | AddPointToNewPolygonEvent\n    | SubmitNewPolygonEvent\n    | CancelNewPolygonEvent\n\n/**\n * Event creator instructing the program the user wants to create a new polygon.\n */\nexport const addPolygon = (): AddPolygonEvent => ({ type: AddEventTypes.AddPolygon })\n\n/**\n * Event creator instructing the program to add a new point to the new polygon.\n */\nexport const addPointToNewPolygon = (point: Point): AddPointToNewPolygonEvent => ({\n    type: AddEventTypes.AddPointToNewPolygon,\n    payload: point,\n})\n\n/**\n * Event creator instructing the program the user has finished creating a new polygon.\n */\nexport const submitNewPolygon = (polygon: Polygon): SubmitNewPolygonEvent => ({\n    type: AddEventTypes.SubmitNewPolygon,\n    payload: polygon,\n})\n\n/**\n * Event creator instructing the program the user wants to cancel creating a new polygon.\n */\nexport const cancelNewPolygon = (): CancelNewPolygonEvent => ({\n    type: AddEventTypes.CancelNewPolygon,\n})\n","import { PointShape } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (point: PointShape<any>, context = ctx) => {\n    context.beginPath()\n    context.arc(point.shape[0], point.shape[1], 5, 0, 2 * Math.PI)\n    context.fillStyle = '#fff'\n    context.fill()\n    context.stroke()\n    context.closePath()\n}\n","import { PointShape, PolygonShape, ShapeTypes } from '../types'\n\nconst colors = [\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n]\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default <T extends { hovering: boolean }>(\n    marker: (point: PointShape<T>, ctx?: CanvasRenderingContext2D) => void,\n) => (ctx: CanvasRenderingContext2D) => (polygon: PolygonShape<T>, context = ctx) => {\n    //\n    context.beginPath()\n\n    polygon.shape.forEach(ring => {\n        const [[hx, hy], ...t] = ring\n\n        context.moveTo(hx, hy)\n\n        t.forEach(([x, y]) => {\n            context.lineTo(x, y)\n        })\n        context.closePath()\n    })\n\n    context.fillStyle =\n        // @ts-ignore\n        (colors[polygon.meta.id] && colors[polygon.meta.id](polygon.meta.hovering ? 1 : 0.5)) ||\n        `rgba(255, 255, 255, ${polygon.meta.hovering ? 1 : 0.5})`\n    context.strokeStyle =\n        // @ts-ignore\n        (colors[polygon.meta.id] && colors[polygon.meta.id](1)) || `rgba(255, 255, 255, 1)`\n\n    context.lineWidth = 1\n    context.lineJoin = 'round'\n\n    context.fill()\n\n    context.stroke()\n\n    // polygon.shape.forEach(ring =>\n    //     ring.forEach(point =>\n    //         marker({ shape: point, meta: polygon.meta, type: ShapeTypes.Point }, context),\n    //     ),\n    // )\n}\n","import { PointShape, LineShape, ShapeTypes } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: PointShape<any>, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (line: LineShape<any>, context = ctx) => {\n    context.beginPath()\n\n    const [[hx, hy], ...t] = line.shape\n\n    context.moveTo(hx, hy)\n\n    t.forEach(([x, y]) => {\n        context.lineTo(x, y)\n    })\n\n    context.stroke()\n\n    line.shape.forEach(point =>\n        marker({ type: ShapeTypes.Point, shape: point, meta: line.meta }, context),\n    )\n}\n","export default (ctx: CanvasRenderingContext2D) => {\n    ctx.fillStyle = '#ffffff'\n    ctx.strokeStyle = '#000000'\n    ctx.lineWidth = 1\n    ctx.shadowBlur = 0\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'\n}\n","import { State, NoopState, StateType, Point, SharedState } from '../types'\n\nimport { AddState } from './types'\nimport { AddEventTypes } from './events'\nimport { Event } from '../events'\n\nimport isPolygon from '../utils/isPolygon'\n\n/**\n * Transitions state to the beginning o the \"Add polygon\" process\n */\nexport const fromNoopToAddPolygon = <T>(\n    state: SharedState<T> & NoopState,\n): SharedState<T> & AddState => {\n    return {\n        ...state,\n        value: StateType.AddPolygon,\n        // newPolygon: [],\n    }\n}\n\n/**\n * Adds a point to the new poloygon the user is creating.\n */\nexport const addPointToNewPolygon = <T>(\n    state: SharedState<T> & AddState,\n    point: Point,\n): SharedState<T> & AddState => {\n    return {\n        ...state,\n        value: StateType.AddPolygon,\n        // newPolygon: [...state.newPolygon, point],\n    }\n}\n\n/**\n * Transitions state to include the new polygon and return to base state.\n */\nexport const submitNewPolygon = <T>(\n    state: SharedState<T> & AddState,\n): SharedState<T> & NoopState => {\n    return {\n        ...state,\n        value: StateType.Noop,\n        // polygons: [...state.polygons, polygon],\n    }\n}\n\n/**\n * Transitions back to base state without a new polygon.\n */\nexport const cancelNewPolygon = <T>(\n    state: SharedState<T> & AddState,\n): SharedState<T> & NoopState => {\n    return {\n        ...state,\n        value: StateType.Noop,\n    }\n}\n\n/**\n * Handles incoming events and transitions state accordingly.\n */\nexport default <T>(state: State<T>, event: Event): State<T> => {\n    // Transition to \"AddPolygon\" state\n    if (event.type === AddEventTypes.AddPolygon && state.value === StateType.Noop) {\n        return fromNoopToAddPolygon<T>(state)\n    }\n\n    // Add point to new polygon currently being drawn\n    else if (\n        event.type === AddEventTypes.AddPointToNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return addPointToNewPolygon(state, event.payload)\n    }\n\n    // Finish drawing new polygon\n    else if (\n        event.type === AddEventTypes.SubmitNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return submitNewPolygon(state)\n    }\n\n    // Cancel drawing a new polygon\n    else if (\n        event.type === AddEventTypes.CancelNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return cancelNewPolygon(state)\n    }\n\n    return state\n}\n","import { Shape, ShapeTypes, LineShape, PointShape, PolygonShape } from '../types'\n\n/** Returns the first element of a tuple */\nexport const first = <A, B>(t: [A, B]): A => t[0]\n\nexport const emptyArray: any[] = []\n\nexport const returnEmptyArray = <T>(value: T): T =>\n    Array.isArray(value) && value.length <= 0 ? (emptyArray as any) : value\n\nexport const memoize = <A, B>(f: (a: A) => B) => {\n    let previousA: A | undefined\n    let previousB: B | undefined\n\n    return (a: A): B => {\n        if (a !== previousA) {\n            previousA = a\n            previousB = f(a)\n        }\n\n        return returnEmptyArray(previousB as B)\n    }\n}\n\nexport const isPolygonShape = <T>(shape: Shape<T>): shape is PolygonShape<T> =>\n    shape.type === ShapeTypes.Polygon\n\nexport const isPointShape = <T>(shape: Shape<T>): shape is PointShape<T> =>\n    shape.type === ShapeTypes.Point\n\nexport const isLineShape = <T>(shape: Shape<T>): shape is LineShape<T> =>\n    shape.type === ShapeTypes.Line\n","import { fromEvent, Observable } from 'rxjs'\nimport { map, filter, tap } from 'rxjs/operators'\n\nimport { Event, EventType } from './events'\n\nimport { first } from './utils'\n\n/** Maps an observable of a tuple to an observable of the first element in the tuple */\nexport const mapFirst = map(first)\n\n/**\n *\n */\nexport const makeEventTypes = (events$: Observable<Event>) => events$.pipe(map(event => event.type))\n\n/**\n *\n */\nexport const makeFromEventType = (eventTypes$: Observable<Event['type']>) => <T extends EventType>(\n    eventType: T,\n) =>\n    eventTypes$.pipe(\n        filter(\n            (dispatchedEventType): dispatchedEventType is T => eventType === dispatchedEventType,\n        ),\n    )\n\n/**\n *\n */\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress')\n/**\n *\n */\nexport const keyPressCode$ = keyPress$.pipe(map(evt => evt.keyCode))\n\n/**\n *\n */\nexport const ofKeyCode = (keyCode: number | number[]) =>\n    keyPressCode$.pipe(\n        filter(pressedKeyCode =>\n            Array.isArray(keyCode) ? keyCode.includes(pressedKeyCode) : pressedKeyCode === keyCode,\n        ),\n    )\n\n/**\n *\n */\nexport const enterKey$ = ofKeyCode(13)\n\n/**\n *\n */\nexport const cancelKey$ = ofKeyCode(99)\n","import { State, Point, Shape, StateType, PointShape, LineShape, PolygonShape } from './types'\nimport { memoize, isPolygonShape, isPointShape, isLineShape, emptyArray } from './utils'\n\n/**\n * From `[Polygon, T] -> [Polygon]\n */\nexport const filterPolygonShapes = memoize(<T>(shapes: Shape<T>[]): PolygonShape<T>[] =>\n    shapes.filter(isPolygonShape),\n)\n\n/** TODO */\nexport const filterLineShapes = memoize(<T>(shapes: Shape<T>[]): LineShape<T>[] =>\n    shapes.filter(isLineShape),\n)\n\n/** TODO */\nexport const filterPointShapes = memoize(<T>(shapes: Shape<T>[]): PointShape<T>[] =>\n    shapes.filter(isPointShape),\n)\n\n/**\n * Redduces a list of [[PointShape]] into a list of points\n */\nexport const convertPointShapesToListOfPoints = memoize(<T>(pointShapes: PointShape<T>[]) =>\n    pointShapes.map(pointShape => pointShape.shape),\n)\nexport const convertLineShapesToListOfLines = memoize(<T>(lineShapes: LineShape<T>[]) =>\n    lineShapes.flatMap(lineShape => lineShape.shape),\n)\nexport const convertPolygonShapesToListOfPolygons = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape => polygonShape.shape.flat()),\n)\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfPoints = memoize(<T>(shapes: Shape<T>[]): Point[] => [\n    ...convertPointShapesToListOfPoints(filterPointShapes(shapes)),\n    ...convertLineShapesToListOfLines(filterLineShapes(shapes)),\n    ...convertPolygonShapesToListOfPolygons(filterPolygonShapes(shapes)),\n])\n\n// export const newPolygonS = (state: State<any>): Point[] => {\n//     if (state.value === StateType.AddPolygon) {\n//         return state.newPolygon\n//     }\n\n//     return emptyArray\n// }\n","export default <T>(value: number | T): value is T => typeof value !== 'number'\n","import { Observable, concat, merge, of, combineLatest } from 'rxjs'\nimport {\n    take,\n    tap,\n    takeUntil,\n    filter,\n    switchMap,\n    scan,\n    switchMapTo,\n    mapTo,\n    startWith,\n    takeWhile,\n    map,\n} from 'rxjs/operators'\n\nimport { AddState } from './types'\nimport { cancelKey$, enterKey$, ofKeyCode, makeFromEventType, keyPress$ } from '../observables'\nimport {\n    AddEventTypes,\n    addPointToNewPolygon,\n    submitNewPolygon,\n    cancelNewPolygon,\n    SubmitNewPolygonEvent,\n    addPolygon,\n} from './events'\nimport { Point, Polygon, NoopState, SharedState } from '../types'\nimport { Event } from '../events'\nimport isNotNr from '../utils/isNotNr'\nimport { noop } from '@babel/types'\n\n/** Type describing the function that passes an event to the events$ [[Subject]] */\ntype Dispatch = (event: Event) => void\n\n/** Observable for event of type  AddPolygon */\nexport const makeAddPolygonEvent$ = (fromEventType: ReturnType<typeof makeFromEventType>) =>\n    fromEventType(AddEventTypes.AddPolygon)\n\n/** Observable for event of type  AddPointToNewPolygon */\nexport const makeAddPointToNewPolygonEvent$ = (\n    fromEventType: ReturnType<typeof makeFromEventType>,\n) => fromEventType(AddEventTypes.AddPointToNewPolygon)\n\n/** Observable for event of type  SubmitNewPolygon */\nexport const makeSubmitNewPolygonEvent$ = (fromEventType: ReturnType<typeof makeFromEventType>) =>\n    fromEventType(AddEventTypes.SubmitNewPolygon)\n\n/** Observable for event of type  CancelNewPolygon */\nexport const makeCancelNewPolygonEvent$ = (fromEventType: ReturnType<typeof makeFromEventType>) =>\n    fromEventType(AddEventTypes.CancelNewPolygon)\n\nconst initial = <T>(xs: T[]) => {\n    const clone = [...xs]\n    clone.splice(xs.length - 1, 1)\n    return clone\n}\n\nconst tail = <T>(xs: T[]) => {\n    const [_, ...t] = xs\n    return t\n}\n\nconst head = <T>(xs: T[]) => {\n    const [h] = xs\n    return h\n}\n\n/**\n * Creates a program that will add a point to [[AddState]]'s `.newPolygon`\n * on every mosue click until the cancel or submit events are dispatched.\n */\nexport const makeAddPointToPolygon = <T>(\n    newPoint$: Observable<Point>,\n    dispatch: (event: Event) => void,\n) => {\n    const undoKey$ = keyPress$\n        .pipe(\n            tap(e => console.log('undo', e)),\n            filter(evt => evt.ctrlKey && [122, 90, 26].includes(evt.keyCode)),\n        )\n        .pipe(mapTo('undo' as const))\n\n    const redoKey$ = keyPress$\n        .pipe(filter(evt => evt.ctrlKey && [121, 89, 25].includes(evt.keyCode)))\n        .pipe(mapTo('redo' as const))\n\n    const allNewPoints$ = merge(newPoint$, undoKey$, redoKey$).pipe(\n        scan(\n            ([currentPoints, redoPoints], event) =>\n                // if\n                Array.isArray(event)\n                    ? // then\n                      ([[...currentPoints, event], []] as [Point[], Point[]])\n                    : // else if\n                    event === 'undo' && currentPoints.length > 0\n                    ? // then\n                      ([\n                          initial(currentPoints),\n                          [currentPoints[currentPoints.length - 1], ...redoPoints],\n                      ] as [Point[], Point[]])\n                    : // else if\n                    event === 'redo' && redoPoints.length > 0\n                    ? // then\n                      ([[...currentPoints, head(redoPoints)], tail(redoPoints)] as [\n                          Point[],\n                          Point[],\n                      ])\n                    : // else\n                      ([currentPoints, []] as [Point[], Point[]]),\n            [[], []] as [Point[], Point[]],\n        ),\n        map(([currentPoints]) => currentPoints),\n    )\n\n    const pressedEnter$ = enterKey$.pipe(mapTo('submit' as const))\n\n    const pressedCancel$ = cancelKey$.pipe(mapTo('cancel' as const))\n\n    type Emitted = 'submit' | 'cancel' | Point[]\n    type Accumulated = readonly [Emitted, Point[]]\n\n    return merge(pressedEnter$, pressedCancel$, allNewPoints$)\n        .pipe(\n            scan(\n                (acc, next) =>\n                    // if\n                    Array.isArray(next)\n                        ? // then\n                          ([next, next] as const)\n                        : // else\n                          ([next, acc[1]] as const),\n                // Initial scan value\n                [[], []] as Accumulated,\n            ),\n            takeWhile(\n                ([data, points]) =>\n                    // if\n                    data === 'cancel'\n                        ? // then\n                          false\n                        : // else if\n                        data === 'submit' && points.length > 2\n                        ? // then\n                          false\n                        : // else\n                          true,\n                // Inclusive takeWhile\n                true,\n            ),\n        )\n        .pipe(\n            // filter(([submit, cancel]) => submit || cancel),\n            tap(([event, points]) => {\n                console.log('Event', event, ...points)\n                if (event === 'submit' && points.length > 2) {\n                    dispatch(submitNewPolygon([points]))\n                } else if (event === 'cancel') {\n                    dispatch(cancelNewPolygon())\n                }\n            }),\n            map(([, points]) => points),\n        )\n}\n\n/**\n * Creates a program for adding new polygons.\n */\nexport const makeAddPolygonProgram = <T>(\n    onMouseClick$: Observable<Point>,\n    addPolygonEvent$: Observable<AddEventTypes.AddPolygon>,\n    dispatch: (event: Event) => void,\n): Observable<Point[]> =>\n    concat(\n        merge(\n            concat(\n                // Await pressing key \"a\" or \"A\"\n                ofKeyCode([65, 97]).pipe(take(1)),\n                // Dispatch \"AddPolygon\" event\n                of(addPolygon()).pipe(tap(dispatch)),\n            ).pipe(filter(isNotNr)),\n            addPolygonEvent$,\n        ).pipe(take(1)),\n        makeAddPointToPolygon(onMouseClick$, dispatch),\n        // Emit a final empty list of points once we are done.\n        of([] as Point[]),\n    ).pipe(\n        tap(data => console.log(`Emit: ${data}`)),\n        filter((data): data is Point[] => Array.isArray(data)),\n    )\n\nexport default makeAddPolygonProgram\n","import _ from 'lodash'\n\nimport {\n    AllGeoJSON,\n    Feature,\n    FeatureCollection,\n    GeoJSONObject,\n    Geometries,\n    GeometryCollection,\n    MultiPolygon,\n    Polygon,\n    Position,\n    Types as GeoJSONTypes,\n} from '@turf/helpers'\n\nimport {\n    PolyLike,\n    PositionLike,\n    QFeature,\n    QFeatureCollection,\n    QMultiPolygon,\n    QPolygon,\n    QPolyLike,\n    QPosition,\n} from './types'\n\ntype Project = (xy: number[]) => number[]\n\ninterface Collect {\n    coordinates: QPosition[]\n    lines: [QPosition, QPosition][]\n}\n\nconst defaultCollect = (): Collect => ({ coordinates: [], lines: [] })\n\nexport const pointPixelsAreEqual = ([x1, y1]: PositionLike, [x2, y2]: PositionLike): boolean => {\n    console.log(`${x1} === ${x2} && ${y1} === ${y2}`)\n    const eq = _.isEqual([x1, y1], [x2, y2])\n    console.log('Eq: ' + eq)\n    return eq\n}\n\nexport const projectGeometry = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Polygon | MultiPolygon,\n): QPolygon | QMultiPolygon => {\n    switch (geom.type) {\n        case 'MultiPolygon':\n            return projectMultiPolygon(project)(collect)(geom)\n        case 'Polygon':\n            return projectPolygon(project)(collect)(geom)\n        default:\n            return geom\n    }\n}\n\nexport const projectGeoJSON = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: PolyLike,\n): QPolyLike => {\n    switch (geom.type) {\n        case 'FeatureCollection':\n            return projectFeatureCollection(project)(collect)(geom as any)\n        case 'Feature':\n            return projectFeature(project)(collect)(geom)\n        // case 'GeometryCollection':\n        //   return projectGeometryCollection(project)(collect)(geom)\n        default:\n            return projectGeometry(project)(collect)(geom)\n    }\n}\n\nexport const projectFeature = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Feature<Polygon | MultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    geometry: projectGeometry(project)(collect)(geom.geometry),\n})\n\nexport const projectFeatureCollection = (project: Project) => (\n    collect: Collect = defaultCollect(),\n) => (\n    geom: FeatureCollection<Polygon | MultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    features: geom.features.map(projectFeature(project)(collect)),\n})\n\n// export const projectGeometryCollection = (project: Project) => (collect: Collect = defaultCollect()) => (\n//   geom: any\n// ): GeometryCollection => ({\n//   ...geom,\n//   geometries: geom.geometries.map(projectGeometry(project)(collect))\n// })\n\nexport const projectMultiPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: MultiPolygon,\n): QMultiPolygon => ({\n    ...polygon,\n    coordinates: polygon.coordinates.map(poly => poly.map(projectPositions(project)(collect))),\n})\n\nexport const projectPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: Polygon,\n): QPolygon => {\n    return {\n        ...polygon,\n        coordinates: polygon.coordinates.map(projectPositions(project)(collect)),\n    }\n}\n\nexport const projectPositions = (project: Project) => (collect: Collect = defaultCollect()) => (\n    coords: Position[],\n): QPosition[] =>\n    coords.map((coord, index) => {\n        const projected = project(coord)\n\n        const point: QPosition = [projected[0], projected[1], coord[0], coord[1]]\n        collect.coordinates.push(point)\n\n        if (index > 0) {\n            collect.lines.push([collect.coordinates[collect.coordinates.length - 2], point])\n\n            if (index === coords.length - 1) {\n                collect.lines.push([\n                    point,\n                    collect.coordinates[collect.coordinates.length - coords.length],\n                ])\n            }\n        }\n\n        return point\n    })\n\nexport const pointToLineDistance = ([x, y]: number[], [[x1, y1], [x2, y2]]: number[][]) => {\n    const A = x - x1\n    const B = y - y1\n    const C = x2 - x1\n    const D = y2 - y1\n\n    const dot = A * C + B * D\n    const lenSq = C * C + D * D\n    let param = -1\n    if (lenSq !== 0) {\n        // in case of 0 length line\n        param = dot / lenSq\n    }\n\n    let xx: number\n    let yy: number\n\n    if (param < 0) {\n        xx = x1\n        yy = y1\n    } else if (param > 1) {\n        xx = x2\n        yy = y2\n    } else {\n        xx = x1 + param * C\n        yy = y1 + param * D\n    }\n\n    const dx = x - xx\n    const dy = y - yy\n    return [[xx, yy], Math.sqrt(dx * dx + dy * dy)] as [number[], number]\n}\n\n/**\n *\n * @param position\n * @param lines\n */\nexport const findLineSnapPosition = (position: Position, lines: [QPosition, QPosition][]) => {\n    let point: Position | undefined\n    let distance = -1\n    let line: [QPosition, QPosition] | undefined\n\n    lines.find((poly): boolean => {\n        const [xy, d] = pointToLineDistance(position, poly)\n\n        if (d <= 5) {\n            point = xy\n            distance = d\n            line = poly\n\n            return true\n        }\n\n        return false\n    })\n\n    if (distance >= 0 && point != null && line != null) {\n        return { point, distance, line }\n    }\n\n    return undefined\n}\n\nconst fromQPosition2Position = ([, , lng, lat]: QPosition): Position => [lng, lat]\n\nconst fromQPositions2Positions = (qPositions: QPosition[]): Position[] =>\n    qPositions.map(fromQPosition2Position)\n\nconst fromQPositionsSets2PositionsSets = (sets: QPosition[][]): Position[][] =>\n    sets.map(fromQPositions2Positions)\n\nconst fromQPolygon2Polygon = (qPolygon: QPolygon): Polygon => {\n    return {\n        ...qPolygon,\n        coordinates: fromQPositionsSets2PositionsSets(qPolygon.coordinates),\n    }\n}\n\nconst fromQMultiPolygon2MultiPolygon = (qMultiPolygon: QMultiPolygon): MultiPolygon => {\n    return {\n        ...qMultiPolygon,\n        coordinates: qMultiPolygon.coordinates.map(fromQPositionsSets2PositionsSets),\n    }\n}\n\nconst fromQGeometry2Geometry = (geometry: QPolygon | QMultiPolygon) => {\n    if (geometry.type === 'MultiPolygon') {\n        return fromQMultiPolygon2MultiPolygon(geometry)\n    }\n\n    return fromQPolygon2Polygon(geometry)\n}\n\nconst fromQFeature2Feature = (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): Feature<Polygon | MultiPolygon> => {\n    return {\n        ...feature,\n        geometry: fromQGeometry2Geometry(feature.geometry),\n    }\n}\n\nexport const fromQLikeToPolyLike = (qLike: QPolyLike): PolyLike => {\n    if (qLike.type === 'FeatureCollection') {\n        return {\n            ...qLike,\n            features: qLike.features.map(fromQFeature2Feature),\n        }\n    } else if (qLike.type === 'Feature') {\n        return fromQFeature2Feature(qLike)\n    }\n\n    return fromQGeometry2Geometry(qLike)\n}\n\nexport const mapGeometry = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (geometry: QPolygon | QMultiPolygon): QPolygon | QMultiPolygon => {\n    const nextGeometry = f(geometry)\n\n    if (nextGeometry !== geometry) {\n        return nextGeometry\n    }\n\n    return geometry\n}\n\nexport const mapFeature = (f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon) => (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => {\n    const nextGeometry = f(feature.geometry)\n\n    if (nextGeometry !== feature.geometry) {\n        return {\n            ...feature,\n            geometry: nextGeometry,\n        }\n    }\n\n    return feature\n}\n\nexport const mapFeatureCollection = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (\n    featureCollection: QFeatureCollection<QPolygon | QMultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => {\n    const nextFeatures: QFeature<QPolygon | QMultiPolygon>[] = []\n    let didChange = false\n\n    featureCollection.features.forEach(feature => {\n        const nextFeature = mapFeature(f)(feature)\n\n        if (nextFeature !== feature) {\n            didChange = true\n            nextFeatures.push(nextFeature)\n        }\n    })\n\n    if (didChange) {\n        return {\n            ...featureCollection,\n            features: nextFeatures,\n        }\n    }\n\n    return featureCollection\n}\n\nexport const mapPolyLike = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (polyLike: QPolyLike): QPolyLike => {\n    if (polyLike.type === 'Feature') {\n        return mapFeature(f)(polyLike)\n    } else if (polyLike.type === 'FeatureCollection') {\n        return mapFeatureCollection(f)(polyLike)\n    }\n\n    return mapGeometry(f)(polyLike)\n}\n\nexport const injectLineSnapPosition = (\n    ring: QPosition[],\n    line: [QPosition, QPosition],\n    point: QPosition,\n) => {\n    let didInject = false\n\n    console.log(ring, line, point)\n\n    const nextRing = ring.reduce(\n        (acc, coord) => {\n            console.log('Acc', acc)\n            const previous = acc[acc.length - 1]\n\n            if (\n                didInject === false &&\n                previous &&\n                pointPixelsAreEqual(previous, line[0]) &&\n                pointPixelsAreEqual(coord, line[1])\n            ) {\n                console.log('Inject', point, coord)\n                didInject = true\n                acc.push(point, coord)\n            } else {\n                acc.push(coord)\n            }\n\n            return acc\n        },\n        [] as QPosition[],\n    )\n\n    return { didInject, ring: nextRing }\n}\n\nexport const mapMouseEventToCoords = (evt: MouseEvent): [number, number] => [\n    evt.offsetX,\n    evt.offsetY,\n]\n","import {\n    ConnectableObservable,\n    fromEvent,\n    Observable,\n    of,\n    OperatorFunction,\n    race,\n    Subject,\n} from 'rxjs'\nimport { filter, map, multicast, publish, switchMapTo, take, tap } from 'rxjs/operators'\n\nimport { Either, left, right } from 'fp-ts/lib/Either'\n\nimport { mapMouseEventToCoords } from './utils'\n\nexport const toMulticast = <T>(\n    observable: Observable<T>,\n    connect = true,\n): ConnectableObservable<T> => {\n    const publishedObservable: ConnectableObservable<T> = observable.pipe(publish()) as any\n\n    if (connect === true) {\n        publishedObservable.connect()\n    }\n\n    return publishedObservable\n}\n\n/**\n *\n * @param event\n */\nexport const createEventObservableCreator = <E = MouseEvent>(event: string) => (\n    mouseCanvas: HTMLCanvasElement,\n) => toMulticast(fromEvent<E>(mouseCanvas, event))\n\n/**\n *\n */\nexport const createMouseMoveObservable = createEventObservableCreator<MouseEvent>('mousemove')\n\n/**\n *\n */\nexport const createMouseDownObservable = createEventObservableCreator<MouseEvent>('mousedown')\n\n/**\n *\n */\nexport const createMouseUpObservable = createEventObservableCreator<MouseEvent>('mouseup')\n\n/**\n *\n */\nexport const createMouseClickObservable = createEventObservableCreator<MouseEvent>('click')\n\nexport const createMouseMovePosObservable = (mouseMove$: Observable<MouseEvent>) =>\n    mouseMove$.pipe(map(mapMouseEventToCoords))\n\nexport const createMouseDownPosObservable = (mouseDown$: Observable<MouseEvent>) =>\n    mouseDown$.pipe(map(mapMouseEventToCoords))\n\nexport const createMouseUpPosObservable = (mouseUp$: Observable<MouseEvent>) =>\n    mouseUp$.pipe(map(mapMouseEventToCoords))\n\nexport const createMouseClickPosObservable = (mouseClick$: Observable<MouseEvent>) =>\n    mouseClick$.pipe(map(mapMouseEventToCoords))\n\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress') // .pipe(tap(console.info))\n\nexport const keyPressCode$ = keyPress$.pipe(map(evt => evt.keyCode))\n\nexport const ofKeyCode = (keyCode: number) =>\n    keyPressCode$.pipe(filter(pressedKeyCode => pressedKeyCode === keyCode))\n\nexport const enterKey$ = ofKeyCode(13)\n\nexport const cancelKey$ = ofKeyCode(99)\n\n/**\n * From one observable to a race between 2 others to a observable of Eihter<L, R>\n * @param observable\n */\nexport const fromObservableToEither =\n    // From observable T\n    <A>(observable: Observable<A>) =>\n        // with observable L\n        <L>(leftObservable: Observable<L>) =>\n            // And observable R\n            <R>(rightObservable: Observable<R>): Observable<Either<L, R>> =>\n                // To observable Either<L, R>\n                observable.pipe(\n                    switchMapTo(\n                        // Race left or right\n                        race(\n                            leftObservable.pipe(map((evt: L): Either<L, R> => left(evt))),\n                            rightObservable.pipe(map((evt: R): Either<L, R> => right(evt))),\n                        ).pipe(take(1)),\n                    ),\n                )\n\nexport const mapRight = <L, R>(observable: Observable<Either<L, R>>) =>\n    observable.pipe(\n        filter(lr => lr.isRight()),\n        map(rightEither => rightEither.value as R),\n    )\n\nexport const mapRightTo = <L, R>(observable: Observable<Either<L, R>>) => (\n    operatorFn: OperatorFunction<R, R>,\n) => mapRight(observable).pipe(operatorFn)\n\nexport const mapLeft = <L, R>(observable: Observable<Either<L, R>>) =>\n    observable.pipe(\n        filter(lr => lr.isLeft()),\n        map(leftEither => leftEither.value as L),\n    )\n\nexport const mapLeftTo = <L, R>(observable: Observable<Either<L, R>>) => (\n    operatorFn: OperatorFunction<L, L>,\n) => mapLeft(observable).pipe(operatorFn)\n\nexport default (mouseCanvas: HTMLCanvasElement, canvas: HTMLCanvasElement) => {\n    const mouseMove$ = createMouseMoveObservable(mouseCanvas)\n    const mouseDown$ = createMouseDownObservable(mouseCanvas)\n    const mouseUp$ = createMouseUpObservable(mouseCanvas)\n    const mouseClick$ = createMouseClickObservable(mouseCanvas)\n\n    const mouseMovePos$ = createMouseMovePosObservable(mouseMove$)\n    const mouseDownPos$ = createMouseDownPosObservable(mouseDown$)\n    const mouseUpPos$ = createMouseUpPosObservable(mouseUp$)\n    const mouseClickPos$ = createMouseClickPosObservable(mouseClick$)\n\n    const mouseMoveEventOrUpPos$ = fromObservableToEither(mouseDown$)(mouseMove$)(mouseUpPos$)\n    const mouseUpEventOrMovePos$ = fromObservableToEither(mouseDown$)(mouseUp$)(mouseMovePos$)\n\n    const mapToUpPosFromEither = mapRightTo(mouseMoveEventOrUpPos$)\n    const mapToMovePosFromUpMoveEither = mapLeftTo(mouseUpEventOrMovePos$)\n\n    return {\n        mouseMove$,\n        mouseDown$,\n        mouseUp$,\n        mouseClick$,\n        mouseMovePos$,\n        mouseDownPos$,\n        mouseUpPos$,\n        mouseClickPos$,\n        keyPress$,\n        enterKey$,\n        mouseMoveEventOrUpPos$,\n        mouseUpEventOrMovePos$,\n        mapToUpPosFromEither,\n        mapToMovePosFromUpMoveEither,\n        toMulticast,\n    }\n}\n","import { fromEvent, merge, Subject, Observable, of, combineLatest } from 'rxjs'\nimport {\n    map,\n    tap,\n    repeat,\n    filter,\n    scan,\n    mapTo,\n    switchMap,\n    startWith,\n    switchMapTo,\n} from 'rxjs/operators'\n\nimport KDBush from 'kdbush'\nimport createPolyBush from './rbush'\n\nimport { StateType, State, Point, Shape, SharedState, ShapeTypes } from './types'\nimport mapMouseEventToCoords from './utils/mapMouseEventToCoords'\nimport pencil_ from './pencils'\nimport { Event } from './events'\nimport transition from './reducers'\nimport { mapFirst, ofKeyCode, makeFromEventType, makeEventTypes } from './observables'\nimport { convertShapesToListOfPoints, filterPolygonShapes } from './selectors'\n\nimport { AddState } from './add/types'\nimport { addPolygon, AddEventTypes, SubmitNewPolygonEvent } from './add/events'\nimport makeAddPolygonProgram from './add/observables'\nimport { isPolygonShape } from './utils'\nimport { toMulticast } from './legacy/observables'\n\n// let cycle = 1\n// let mousemoveIndex = 0\n\nexport default <T>(shapes$: Observable<Shape<T>[]>) => (canvas: HTMLCanvasElement) => {\n    const ctx = canvas.getContext('2d')\n\n    // console.group(`Cycle ${cycle}`)\n\n    if (ctx != null) {\n        /**\n         * Final API for drawing markers, polygons, and lines.\n         */\n        const pencil = pencil_()(ctx)\n\n        /**\n         * K-2 tree used to store all points that are present within\n         * the system and used to find points that are near the mouse\n         * position to snap to.\n         */\n        let pointsDb: KDBush.KDBush<Point> =\n            // @ts-ignore\n            new KDBush([])\n\n        const polyDb = createPolyBush()\n\n        /**\n         * Observable for emitting events\n         */\n        const events$ = new Subject<Event>()\n\n        /**\n         * Observable emits all event types that are dispatched\n         */\n        const eventTypes$ = makeEventTypes(events$)\n\n        /**\n         * Creates an observable that filters events by type\n         */\n        const fromEventType = makeFromEventType(eventTypes$)\n\n        /**\n         * Dispatches events\n         */\n        const dispatch = (event: Event) => events$.next(event)\n\n        /**\n         * Observable streaming current and previous state\n         */\n        const stateUpdates$ = new Subject<[State<T>, State<T>]>()\n\n        /**\n         * Filters state updates by checking if state has actually changed\n         */\n        const stateChanges$ = stateUpdates$.pipe(filter(([c, p]) => c !== p))\n\n        /**\n         * Maps state changes to actual state\n         */\n        const state$ = stateUpdates$.pipe(mapFirst)\n\n        /**\n         * Finds the nearest point a given point can snap to\n         */\n        const mapPointToSnap = ([x, y]: [number, number]): Point => {\n            const pointSnap = convertShapesToListOfPoints(shapesState)[pointsDb.within(x, y, 10)[0]]\n            pointSnap && console.log(...pointSnap)\n            return pointSnap || [x, y]\n        }\n\n        /**\n         *\n         */\n        const updatePointsDb$ = shapes$.pipe(\n            tap(shapes => {\n                const polygons = filterPolygonShapes(shapes).map(item => item.shape)\n                polyDb.replace(polygons)\n            }),\n            map(convertShapesToListOfPoints),\n            tap(points => {\n                console.log(`Recreating KdTree with     ${points.length} points.`)\n                // @ts-ignore\n                pointsDb = new KDBush(points)\n            }),\n        )\n\n        let state: State<T> = {\n            mousePosition: [0, 0],\n            value: StateType.Noop,\n            hovering: false,\n            // hoverIndex: -1,\n            selectedIndices: [],\n        }\n\n        let shapesState: Shape<T>[] = []\n        shapes$.subscribe(shapes => (shapesState = shapes))\n\n        const history: State<T>[] = []\n        let future: State<T>[] = []\n\n        const setState = (nextState: State<T>, affectsHistory = true) => {\n            // console.time('setState')\n            const prev = state\n\n            if (affectsHistory) {\n                history.push(state)\n                future = []\n            }\n\n            state = nextState\n            stateUpdates$.next([state, prev])\n            // console.timeEnd('setState')\n        }\n\n        const undo = () => {\n            const prev = history.pop()\n\n            if (prev) {\n                future.push(state)\n                setState(\n                    {\n                        ...prev,\n                        mousePosition: state.mousePosition,\n                    },\n                    false,\n                )\n            }\n        }\n\n        const redo = () => {\n            const next = future.pop()\n\n            if (next) {\n                history.push(next)\n                setState(\n                    {\n                        ...next,\n                        mousePosition: state.mousePosition,\n                    },\n                    false,\n                )\n            }\n        }\n\n        const onMouseClick$ = fromEvent<MouseEvent>(canvas, 'click').pipe(\n            map(e => mapMouseEventToCoords(e)),\n        )\n\n        const onMouseDown$ = fromEvent<MouseEvent>(canvas, 'mousedown')\n\n        const onMouseUp = fromEvent<MouseEvent>(canvas, 'mouseup')\n\n        const onMouseMove$ = fromEvent<MouseEvent>(canvas, 'mousemove').pipe(\n            // tap(() => console.time(`mousemove:${mousemoveIndex}`)),\n            map(e => mapMouseEventToCoords(e)),\n        )\n\n        const mousePosition$ = state$.pipe(map(state => state.mousePosition))\n\n        const onMouseClickTranslated$ = onMouseClick$.pipe(\n            map(([x, y]) => {\n                const [tx = 0, ty = 0] = (\n                    canvas.style.transform.match(\n                        /translate3d\\((-?\\d+)px[, ]+(-?\\d+)px[, ]+(-?\\d+)/,\n                    ) || []\n                )\n                    .map(str => +str)\n                    .filter(n => !isNaN(n))\n\n                return [x + tx, y + ty] as [number, number]\n            }),\n        )\n\n        const onMouseMoveTranslated$ = onMouseMove$.pipe(\n            map(([x, y]) => {\n                const [tx = 0, ty = 0] = (\n                    canvas.style.transform.match(\n                        /translate3d\\((-?\\d+)px[, ]+(-?\\d+)px[, ]+(-?\\d+)/,\n                    ) || []\n                )\n                    .map(str => +str)\n                    .filter(n => !isNaN(n))\n\n                return [x + tx, y + ty] as [number, number]\n            }),\n        )\n\n        const hoverIndex$ = toMulticast(\n            mousePosition$.pipe(\n                // tap(() => console.time('hoverIndex')),\n                map(point => polyDb.searchPoint(point).map(item => item.index)),\n                scan((acc, next) => [acc[1], next] as const, [[], []] as readonly [\n                    number[],\n                    number[],\n                ]),\n                // tap(() => console.timeEnd('hoverIndex')),\n                // tap(n => console.log(n)),\n                filter(([a, b]) => a.length !== b.length || a.some((n, index) => n !== b[index])),\n                map(([, b]) => b),\n            ),\n        )\n\n        const value$ = state$.pipe(map(state => state.value))\n\n        const hoverIndexNoop$ = value$.pipe(\n            switchMap(value => (value === StateType.Noop ? hoverIndex$ : of([] as number[]))),\n        )\n\n        const updateStateWithMousePosition$ = onMouseMoveTranslated$.pipe(\n            map(mapPointToSnap),\n            tap(mousePosition => {\n                setState(\n                    {\n                        ...state,\n                        mousePosition: mousePosition as [number, number],\n                    },\n                    false,\n                )\n            }),\n        )\n\n        // const logStateChange$ = stateUpdates$.pipe(tap(console.log))\n\n        const reduceActions$ = events$.pipe(\n            tap(event => {\n                const nextState = transition(state, event)\n                console.groupCollapsed(event.type)\n                console.log(event)\n                console.log(state)\n                console.groupEnd()\n                setState(nextState)\n            }),\n        )\n\n        const addPolygonProgram$ = makeAddPolygonProgram(\n            onMouseClickTranslated$.pipe(map(mapPointToSnap)),\n            fromEventType(AddEventTypes.AddPolygon),\n            dispatch,\n        ).pipe(repeat())\n\n        const newPolygonAndShapes$ = combineLatest(\n            addPolygonProgram$.pipe(startWith([] as Point[])),\n            shapes$.pipe(startWith([] as Shape<T>[])),\n            hoverIndexNoop$.pipe(startWith([] as number[])),\n            // addMode$,\n        )\n\n        const draw$ = newPolygonAndShapes$.pipe(\n            tap(data => {\n                const [newPolygon, shapes, hoverIndices] = data\n                pencil.resetStyles(ctx)\n\n                // Clear the canvas\n                ctx.save()\n                ctx.clearRect(0, 0, canvas.width, canvas.height)\n                // Use the identity matrix while clearing the canvas\n                ctx.setTransform(1, 0, 0, 1, 0, 0)\n                ctx.clearRect(0, 0, canvas.width, canvas.height)\n                ctx.restore()\n                // console.log(hoverIndices)\n                // Draw existing polygons fin state\n\n                const polygons = filterPolygonShapes(shapes)\n                polygons.forEach((shape, index) => {\n                    const hovering = hoverIndices.includes(index)\n                    pencil.polygon({ ...shape, meta: { hovering, id: shape.meta } })\n                    pencil.resetStyles(ctx)\n                })\n\n                // Draw potential new polygon\n                // if (state.value === StateType.AddPolygon) {\n                if (newPolygon.length > 1) {\n                    pencil.polygon({\n                        type: ShapeTypes.Polygon,\n                        shape: [[...newPolygon, state.mousePosition]],\n                        // TODO Provide a way to create T for new polygons\n                        meta: { id: -1, hovering: true },\n                    })\n\n                    pencil.resetStyles(ctx)\n                } else if (newPolygon.length === 1) {\n                    pencil.line({\n                        type: ShapeTypes.Line,\n                        shape: [...newPolygon, state.mousePosition],\n                        meta: (undefined as any) as T,\n                    })\n                    pencil.resetStyles(ctx)\n                }\n\n                newPolygon.forEach(point =>\n                    pencil.marker({ type: ShapeTypes.Point, shape: point, meta: {} }),\n                )\n            }),\n        )\n\n        const subscription = merge(\n            reduceActions$,\n            updateStateWithMousePosition$,\n            // logStateChange$,\n            updatePointsDb$,\n            ofKeyCode([117, 85]).pipe(tap(undo)),\n            ofKeyCode([114, 82]).pipe(tap(redo)),\n            draw$,\n        ).subscribe()\n\n        return {\n            getState: () => state,\n            getHistory: () => history,\n            // subscribe: (cb: () => void) => {\n            //     stateUpdates$.subscribe(cb)\n            // },\n            done: () => {\n                subscription.unsubscribe()\n            },\n            api: {\n                addPolygon: () => dispatch(addPolygon()),\n                onAdd$: events$.pipe(\n                    filter(\n                        (event): event is SubmitNewPolygonEvent =>\n                            event.type === AddEventTypes.SubmitNewPolygon,\n                    ),\n                ),\n            },\n        }\n    }\n\n    throw new Error('Canvas 2D Rendering Context Not Available')\n}\n","import defaultMarker from './marker'\nimport defaultPolygon from './polygon'\nimport defaultLine from './line'\nimport resetStyles from './resetStyles'\n\ninterface Api {\n    marker: typeof defaultMarker\n    polygon: typeof defaultPolygon\n    line: typeof defaultLine\n}\n\nexport default (api: Partial<Api> = {}) => (ctx: CanvasRenderingContext2D) => {\n    const finalMarker = (api.marker || defaultMarker)(ctx)\n    const finalPolygon = (api.polygon || defaultPolygon)(finalMarker)(ctx)\n    const finalLine = (api.line || defaultLine)(finalMarker)(ctx)\n\n    return {\n        marker: finalMarker,\n        polygon: finalPolygon,\n        line: finalLine,\n        resetStyles,\n    }\n}\n","import { State } from './types'\nimport { Event } from './events'\nimport addReducer from './add/reducer'\n\nexport default <T>(state: State<T>, event: Event): State<T> => addReducer(state, event)\n","import core from '../core'\nimport { Point, ShapeTypes, PolygonShape, Shape } from '../core/types'\n\nimport { of, Subject } from 'rxjs'\nimport geojson from '../../data/nl.json'\nimport { tap } from 'rxjs/operators'\nimport { Polygon as P, MultiPolygon as M } from '@turf/helpers'\n\ntype From = (coordinate: number[]) => Point\ntype To = (coordinate: Point) => number[]\n\nconst data: typeof geojson.features = geojson.features\n\ntype G = typeof data[0]['geometry']\n\nconst isP = (g: G): g is P => g.type === 'Polygon'\nconst isM = (g: G): g is M => g.type === 'MultiPolygon'\n\nconst convertGeoJson = (from: From): PolygonShape<number>[] =>\n    // @ts-ignore\n    data\n        // .filter(feature => true || feature.properties.ZoneID % 2 === 0)\n        .flatMap((feature): Shape<number>[] => {\n            const geom = feature.geometry\n\n            if (isP(geom)) {\n                return [\n                    {\n                        type: ShapeTypes.Polygon,\n                        shape: geom.coordinates.map(ring => ring.map(point => from(point))),\n\n                        meta: Math.floor(Math.random() * 20) + 1,\n                    },\n                ]\n            } else if (isM(geom)) {\n                return geom.coordinates.map(poly => {\n                    return {\n                        type: ShapeTypes.Polygon,\n                        shape: poly.map(ring => ring.map(point => from(point))),\n                        meta: Math.floor(Math.random() * 20) + 1,\n                    }\n                })\n            }\n            return []\n        })\n\nexport default (convert: { from: From; to: To }) => (canvas: HTMLCanvasElement) => {\n    const shapes$ = new Subject<PolygonShape<number>[]>()\n\n    const api = core(shapes$.pipe(tap(() => console.info('Updating after zoom/pan'))))(canvas)\n\n    const refresh = () => shapes$.next(convertGeoJson(convert.from))\n\n    api.api.onAdd$\n        .pipe(\n            tap(event => {\n                const coordinates = event.payload[0].map(px => convert.to(px))\n                coordinates.push(coordinates[0])\n                data.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Polygon',\n                        coordinates: [coordinates],\n                    },\n                    // @ts-ignore\n                    properties: {\n                        // ZoneID: 2,\n                    },\n                })\n\n                refresh()\n            }),\n        )\n        .subscribe()\n\n    refresh()\n\n    return Object.assign(api, { refresh })\n}\n","import React from 'react'\nimport { Map as ReactLeafletMap, Popup, TileLayer, useLeaflet, Pane, Circle } from 'react-leaflet'\nimport * as _ from 'lodash'\n\nimport '../../leaflet/leaflet.css'\nimport { canvas, Map as LeafletMap } from 'leaflet'\nimport { geoJSON } from 'leaflet'\n\nimport topolokus from '../../modules/geojson'\n\n// const position2: [number, number] = [51.885, 5.0509] // [51.505, -0.09]\n\nimport geojson from '../../data/geosample.json'\nimport { Point } from '../../modules/core/types'\n\nconst position: [number, number] = [52.1326, 5.2913] // [51.505, -0.09]\nconst Map: React.FC = (props: { children?: React.ReactNode }) => (\n    <ReactLeafletMap center={position} zoom={8}>\n        <TileLayer\n            url=\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n            attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n        />\n\n        <Pane name=\"canvas\">\n            {props.children}\n            <div>xyt</div>\n        </Pane>\n    </ReactLeafletMap>\n)\n\nconst createCanvasLayer = (pane?: string) => canvas({ padding: 0, pane })\n\n// type CanvasLayer = undefined | ReturnType<typeof createCanvasLayer>\n\nconst toLngLat = (map: LeafletMap) => ([x, y, lng, lat]: Point): [number, number] => {\n    const point = map.layerPointToLatLng([x, y])\n    return [lng || point.lng, lat || point.lat]\n}\n\nconst fromLngLat = (map: LeafletMap) => ([lng, lat]: number[]): Point => {\n    const point = map.latLngToLayerPoint([lat, lng + 0])\n    return [point.x, point.y, lng, lat]\n}\n\nconst Canvas = () => {\n    const context = useLeaflet()\n\n    React.useEffect(() => {\n        if (context.map != null) {\n            const map = context.map\n            const canvasLayer = createCanvasLayer(context.pane)\n            // const mouseCanvasLayer = createCanvasLayer(context.pane)\n            canvasLayer.addTo(context.map)\n            // mouseCanvasLayer.addTo(context.map)\n            // @ts-ignore\n            // const layer = geoJSON(geojson.features[0].geometry as any, { renderer: canvasLayer })\n\n            // layer.addTo(context.map)\n\n            Object.assign(window, { canvasLayer })\n\n            const elCanvas: HTMLCanvasElement = (canvasLayer as any)._container\n            // const elMouseCanvasLayer: HTMLCanvasElement = (mouseCanvasLayer as any)._container\n\n            const api = topolokus({\n                from: fromLngLat(map),\n                to: toLngLat(map),\n            })(elCanvas)\n\n            const onZoomOrMove = _.debounce(api.refresh)\n\n            // map.dragging.disable()\n            Object.assign(window, { api })\n\n            map.addEventListener('moveend zoomend', onZoomOrMove)\n\n            return () => {\n                map.removeEventListener('moveend zoomend', onZoomOrMove)\n                map.removeLayer(canvasLayer)\n                // map.removeLayer(mouseCanvasLayer)\n                api.done()\n            }\n        }\n    }, [\n        context.map,\n        context.map && context.map.getCenter().lat,\n        context.map && context.map.getCenter().lng,\n    ])\n\n    return null\n}\n\nexport default () => {\n    return (\n        <Map>\n            <Canvas />\n        </Map>\n    )\n}\n","import React from 'react'\nimport './App.css'\n\nimport Map from './apps/map'\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"App\">\n            <div className=\"App-header\">\n                <p>\n                    <button\n                        onClick={\n                            // @ts-ignore\n                            () => api.api.addPolygon()\n                        }\n                    >\n                        ADD POLYGON\n                    </button>\n                </p>\n                <ol>\n                    <li>\n                        Press <i>&quot;a&quot;</i> or click the <i>&quot;Add Polygon&quot;</i>{' '}\n                        button to start drawing.\n                    </li>\n                    <li>\n                        Press <i>&quot;Enter&quot;</i> to finish drawing. You can only finish after\n                        at least 3 points are drawn.\n                    </li>\n                    <li>\n                        Press <i>&quot;c&quot;</i> to cancel the operation.\n                    </li>\n                    <li>\n                        Supports:\n                        <ul>\n                            <li>Snapping</li>\n                            <li>Undo & redo with Ctrl-Z/Y while adding points</li>\n                        </ul>\n                    </li>\n                </ol>\n            </div>\n            <div id=\"map\">\n                <Map />\n            </div>\n        </div>\n    )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}