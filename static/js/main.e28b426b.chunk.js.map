{"version":3,"sources":["modules/core/types.ts","modules/leaflet/src/utils.ts","modules/core/utils/assert.ts","modules/core/utils/array.ts","modules/core/utils/tuple.ts","modules/core/utils/function.ts","modules/core/utils/transform.ts","modules/core/add/events.ts","modules/core/rbush.ts","modules/core/pencils/marker.ts","modules/core/pencils/polygon.ts","modules/core/pencils/line.ts","modules/core/pencils/resetStyles.ts","modules/core/pencils/cursor.ts","modules/core/pencils/eraser.ts","modules/core/pencils/index.ts","modules/core/observables.ts","modules/core/add/reducer.ts","modules/core/selectors.ts","modules/core/add/observables.ts","modules/core/legacy/utils.ts","modules/core/legacy/observables.ts","modules/core/index.ts","modules/core/reducers.ts","modules/geojson/index.ts","apps/map/index.tsx","modules/leaflet/src/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["ShapeTypes","StateType","EventTypes","SnapType","toLngLat","map","x","y","lng","lat","point","layerPointToLatLng","fromLngLat","latLngToLayerPoint","createCanvasLayer","pane","canvas","padding","isInBBox","bbox","minX","minY","maxX","maxY","isPolygonShape","shape","type","Polygon","isPointShape","Point","isLineShape","Line","isNotOfTypeNbr","value","emptyArray","tuple","a","b","first","memoize","f","previousA","previousB","Array","isArray","length","polygon2bbox","polygon","reduce","acc","Infinity","inRing","ring","ignoreBoundary","isInside","slice","i","j","xi","yi","xj","yj","AddEventTypes","mapMouseEventToOffset","evt","offsetX","offsetY","RBush","RbushClass","polygonToItem","index","Object","assign","insertPolygons","tree","state","polygons","items","count","load","searchByBoundingBox","boundingBox","search","searchByPoint","filter","item","options","insidePoly","inHole","k","booleanPointInPolygon","ctx","context","beginPath","arc","Math","PI","fillStyle","fill","stroke","closePath","colors","n","marker","forEach","hx","hy","t","moveTo","lineTo","meta","id","hovering","strokeStyle","lineWidth","lineJoin","line","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","data","getContext","save","setTransform","clearRect","width","height","restore","api","finalMarker","defaultMarker","finalPolygon","defaultPolygon","finalLine","defaultLine","cursor","defaultCursor","resetStyles","defaultResetStyles","eraser","addPolygon","AddPolygon","event","Noop","AddPointToNewPolygon","payload","SubmitNewPolygon","CancelNewPolygon","mapFirst","mapObservableToPropType","$","pipe","prop","obj","keyPress$","fromEvent","document","keyPressCode$","keyCode","ofKeyCode","pressedKeyCode","includes","enterKey$","cancelKey$","undoKey$","ctrlKey","mapTo","redoKey$","filterPolygonShapes","shapes","filterLineShapes","filterPointShapes","convertPointShapesToListOfPoints","pointShapes","pointShape","convertLineShapesToListOfPoints","lineShapes","flatMap","lineShape","convertPolygonShapesToListOfPoints","polygonShapes","polygonShape","flat","convertPolygonShapesToListOfLines","next","xs","reverse","last","p","push","convertShapesToListOfPoints","convertShapesToListOfLines","convertListOfLinesToLineString","lineDb","turfMultiLineString","x1","y1","makeAddPointToPolygon","nextPoint$","dispatch","allNewPoints$","merge","scan","currentPoints","redoPoints","clone","splice","initial","tail","pressedEnter$","pressedCancel$","takeWhile","points","tap","findLineSnapPosition","lines","distance","find","poly","x2","y2","xx","yy","C","D","lenSq","param","dx","dy","sqrt","pointToLineDistance","xy","dxy","toMulticast","observable","connect","publishedObservable","publish","createEventObservableCreator","mouseCanvas","subscribe","console","clear","convert","shapes$","mouseCtx","pencil","pencil_","mousePencil","translateOffset","style","transform","match","str","isNaN","tx","translateOffsetOfCanvas","pointsDb$","BehaviorSubject","KDBush","polyDb$","window","insert","searchPoint","replace","initialPolygons","createPolyBush","lineDb$","events$","Subject","fromEventType","eventTypes$","eventType","dispatchedEventType","makeFromEventType","asObservable","stateUpdates$","mapPointToSnapFn$","combineLatest","startWith","pointsDb","pointSnap","within","lineSnap","multiLineString","maybePoint","nearestPointOnLine","from","geometry","coordinates","sx","sy","None","updatePointsDb$","withLatestFrom","polyDb","mouseClick$","translatedMousemMove$","e","mapPointToSnap","mousePositionSnapped$","px","py","to","mousePositionSnappedPoint$","hoverIndex$","some","reduceActions$","nextState","prev","setState","addReducer","transition","addPolygonProgram$","addPolygonEvent$","concat","take","of","makeAddPolygonProgram","repeat","draw$","hoverIndices","subscription","mousePosition","newPolygon","undefined","done","unsubscribe","onAdd$","Error","rand","floor","random","ring2points","polygon2shape","multiPolygon2shapes","multiPolygon","feature2shapes","feature","geometry2shapes","featureCollection","features","featureCollection2shapes","isMultiPolygon","geometries","geometries$","plop","core","refresh","getValue","Canvas","useLeaflet","React","useState","geojson","useEffect","createPane","canvasLayer","mouseCanvasLayer","addTo","elCanvas","_container","elMouseCanvasLayer","plopGeoJSON","addEventListener","removeEventListener","removeLayer","plopLeaflet","tileLayer","TileLayer","url","attribution","position","Map","center","zoom","Pane","name","App","className","onClick","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e28b426b.chunk.js","sourcesContent":["import { AddState } from './add/types'\n\n/** Type alias for pixels */\nexport type Pixel = number\n\n/** Type alias for x- and y coordinates */\nexport type Coordinate = number\n\n/**\n * An (x, y) coordiante. The first 2 number represent the pixel\n * cordiantes while the optional second set of numbers are the\n * origina coordiantes. For example longitude and lattitude values.\n *\n * The system preservers the original coordiantes to prevent having\n * to convert them back and forth if they aren't changed.\n */\nexport type Point = [Pixel, Pixel, Coordinate, Coordinate]\n\n/**\n * A list of 2- or more [[Point]]s\n *\n * I would've preferred to tyep it [Point, Point, ...Point[]]\n */\nexport type Line = Point[]\n\n/**\n * A list of list of points where the first element in the list\n * is clockwise and the rest of the list counter clockwise\n * representing holes.\n *\n * I would've preferred to type it: [Point, Point, Point, ...Point[]][]\n * since each ring should have at least 3 points.\n */\nexport type Polygon = Line[]\n\nexport enum ShapeTypes {\n    Point = 'Point',\n    Polygon = 'Polygon',\n    Line = 'Line',\n}\n\nexport type PointShape<T> = {\n    type: ShapeTypes.Point\n    shape: Point\n    meta: T\n}\n\nexport type PolygonShape<T> = {\n    type: ShapeTypes.Polygon\n    shape: Polygon\n    meta: T\n}\n\nexport type LineShape<T> = {\n    type: ShapeTypes.Line\n    shape: Line\n    meta: T\n}\n\nexport type Shape<T> = PointShape<T> | PolygonShape<T> | LineShape<T>\n\nexport enum StateType {\n    Noop = 'Noop',\n    AddPolygon = 'AddPolygon',\n}\n\n// State\nexport interface NoopState {\n    readonly value: StateType.Noop\n}\n\nexport type PossibleStates = NoopState | AddState\nexport type State<T> = PossibleStates\n\n// Actions\nexport enum EventTypes {\n    SelectPolygon = 'SelectPolygon',\n    EditPolygon = 'EditPolygon',\n    RemovePolygon = 'RemovePolygon',\n}\n\nexport type FromPoint = (coordinate: number[]) => Point\nexport type ToPoint = (coordinate: Point) => number[]\nexport type ConvertPoint = { from: FromPoint; to: ToPoint }\n\nexport enum SnapType {\n    Point = 'P',\n    Line = 'L',\n    None = 'M',\n}\n\nexport type SnapPoint = { type: SnapType.Point; point: Point }\nexport type SnapLine = { type: SnapType.Line; point: Point; line: [Point, Point]; distance: number }\nexport type SnapNone = { type: SnapType.None; point: Point }\nexport type Snap = SnapPoint | SnapLine | SnapNone\n","import { Map, canvas } from 'leaflet'\n\nimport { Point } from '../../core/types'\n\n/**\n * ```hs\n * translateOffsetOfCanvas :: HTMLCanvasElement -> (number, number) -> (number, number)\n * ```\n * @param canvas The canvas to adjust the coordinate of\n * @returns Coordinates of a canvas adjusted in relation to it's transformation.\n */\nexport const translateOffsetOfCanvas = (canvas: HTMLCanvasElement) => ([x, y]: [number, number]): [\n    number,\n    number,\n] => {\n    const [tx = 0, ty = 0] = (\n        canvas.style.transform.match(/translate3d\\((-?\\d+)px[, ]+(-?\\d+)px[, ]+(-?\\d+)/) || []\n    )\n        .map(str => +str)\n        .filter(n => !isNaN(n))\n\n    return [x + tx, y + ty] as [number, number]\n}\n\n/**\n * toLngLat :: L.Map -> Point -> (numbr, number)\n * @param canvas\n */\nexport const toLngLat = (map: Map) => ([x, y, lng, lat]: Point): [number, number] => {\n    const point = map.layerPointToLatLng([x, y])\n    return [lng || point.lng, lat || point.lat]\n}\n\n/**\n * fromLngLat :: L.Map -> (number, number) -> Point\n * @param canvas\n */\nexport const fromLngLat = (map: Map) => ([lng, lat]: number[]): Point => {\n    const point = map.latLngToLayerPoint([lat, lng + 0])\n    return [point.x, point.y, lng, lat]\n}\n\n/**\n * createCanvasLayer :: String -> L.Canvas\n * @param canvas\n */\nexport const createCanvasLayer = (pane?: string) => canvas({ padding: 0, pane })\n","import { Point, ShapeTypes, Shape, PointShape, PolygonShape, LineShape, Line } from '../types'\n\nexport const hasProp = <K extends string>(prop: K) => <U, T extends { [P in K]: U }>(obj: T) =>\n    obj[prop]\n\ntype BBox = {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n}\n\nexport const isInBBox = (point: Point, bbox: BBox) =>\n    bbox.minX <= point[0] && bbox.minY <= point[1] && bbox.maxX >= point[0] && bbox.maxY >= point[1]\n\n/** Asserts if the given shape is of type [[PolygonShape]] */\nexport const isPolygonShape = <T>(shape: Shape<T>): shape is PolygonShape<T> =>\n    shape.type === ShapeTypes.Polygon\n\n/** Asserts if the given shape is of type [[PointShape]] */\nexport const isPointShape = <T>(shape: Shape<T>): shape is PointShape<T> =>\n    shape.type === ShapeTypes.Point\n\n/** Asserts if the given shape is of type [[LineShape]] */\nexport const isLineShape = <T>(shape: Shape<T>): shape is LineShape<T> =>\n    shape.type === ShapeTypes.Line\n\nexport const isEqual = <A, B extends A>(value: A) => (compare: B) => value === compare\n\nexport const isNotOfTypeNbr = <T>(value: number | T): value is T => typeof value !== 'number'\n\nexport const isPolygon = (points?: Point[]): points is Line => points != null && points.length > 2\n","export const emptyArray: any[] = []\n\n/** Return everything but the last element in an array. */\nexport const initial = <T>(xs: T[]) => {\n    const clone = [...xs]\n    clone.splice(xs.length - 1, 1)\n    return clone\n}\n\n/** Return everything but the first element in array. */\nexport const tail = <T>(xs: T[]) => {\n    const [_, ...t] = xs\n    return t\n}\n\n/** Retrun the first element in an array. */\nexport const head = <T>(xs: T[]) => {\n    const [h] = xs\n    return h\n}\n\n/** Time */\nexport const last = <T>(xs: T[]) => {\n    const [l] = [...xs].reverse()\n    return l\n}\n\nexport const returnEmptyArray = <T>(value: T): T =>\n    Array.isArray(value) && value.length <= 0 ? (emptyArray as any) : value\n","/** Converts value a and b into a tuple */\nexport const tuple = <A, B>(a: A, b: B): [A, B] => [a, b]\n\n/** Returns the first element of a tuple */\nexport const first = <A>([a]: [A, any]): A => a\n\n/** Returns the second element of a tuple */\nexport const second = <B>([, b]: [any, B]): B => b\n","import { returnEmptyArray } from './array'\n\nexport const memoize = <A, B>(f: (a: A) => B) => {\n    let previousA: A | undefined\n    let previousB: B | undefined\n\n    return (a: A): B => {\n        if (a !== previousA) {\n            previousA = a\n            previousB = f(a)\n        }\n\n        return returnEmptyArray(previousB as B)\n    }\n}\n","import { Polygon, Point, Line } from '../types'\nimport { isInBBox } from './assert'\n\nexport const polygon2bbox = (polygon: Polygon) =>\n    polygon[0].reduce(\n        (acc, [x, y]) => {\n            if (x < acc.minX) acc.minX = x\n            if (y < acc.minY) acc.minY = y\n            if (acc.maxX === Infinity || x > acc.maxX) acc.maxX = x\n            if (acc.maxY === Infinity || y > acc.maxY) acc.maxY = y\n            return acc\n        },\n        {\n            minX: Infinity,\n            minY: Infinity,\n            maxX: Infinity,\n            maxY: Infinity,\n        },\n    )\n\n/**\n *\n */\nexport function booleanPointInPolygon(\n    point: Point,\n    polygon: Polygon,\n    options: {\n        ignoreBoundary?: boolean\n    } = {},\n) {\n    const bbox = polygon2bbox(polygon)\n\n    // Quick elimination if point is not inside bbox\n    if (isInBBox(point, bbox) === false) {\n        return false\n    }\n\n    let insidePoly = false\n\n    if (inRing(point, polygon[0], options.ignoreBoundary)) {\n        let inHole = false\n        let k = 1\n        // check for the point in any of the holes\n        while (k < polygon.length && !inHole) {\n            if (inRing(point, polygon[k], !options.ignoreBoundary)) {\n                inHole = true\n            }\n            k++\n        }\n        if (!inHole) {\n            insidePoly = true\n        }\n    }\n\n    return insidePoly\n}\n\nfunction inRing(point: Point, ring: Line, ignoreBoundary?: boolean) {\n    let isInside = false\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1)\n    }\n\n    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        const xi = ring[i][0]\n        const yi = ring[i][1]\n        const xj = ring[j][0]\n        const yj = ring[j][1]\n        const onBoundary =\n            point[1] * (xi - xj) + yi * (xj - point[0]) + yj * (point[0] - xi) === 0 &&\n            (xi - point[0]) * (xj - point[0]) <= 0 &&\n            (yi - point[1]) * (yj - point[1]) <= 0\n        if (onBoundary) {\n            return !ignoreBoundary\n        }\n        const intersect =\n            yi > point[1] !== yj > point[1] &&\n            point[0] < ((xj - xi) * (point[1] - yi)) / (yj - yi) + xi\n        if (intersect) {\n            isInside = !isInside\n        }\n    }\n\n    return isInside\n}\n\nexport const mapMouseEventToOffset = (evt: MouseEvent): [number, number] => [\n    evt.offsetX,\n    evt.offsetY,\n]\n\nexport const mapProp = <K extends string>(prop: K) => <T extends { [P in K]: T[K] }>(obj: T) =>\n    obj[prop]\n","import { Point, Polygon } from '../types'\n\n/**\n * Event type descriptors for the \"Add Polygon\" process\n */\nexport enum AddEventTypes {\n    AddPolygon = 'AddPolygon',\n    AddPointToNewPolygon = 'AddPointToNewPolygon',\n    SubmitNewPolygon = 'SubmitNewPolygon',\n    CancelNewPolygon = 'CancelNewPolygon',\n}\n\n/**\n * Event dispatched when the user wants to add a new polygon.\n */\nexport type AddPolygonEvent = {\n    type: AddEventTypes.AddPolygon\n}\n\n/**\n * Event dispatched when the user clicks on the canvas to add a new point to the polygon they are creating.\n */\nexport type AddPointToNewPolygonEvent = {\n    type: AddEventTypes.AddPointToNewPolygon\n    payload: Point\n}\n\n/**\n * Event dispatched when the user has finished creating a new polygon.\n */\nexport type SubmitNewPolygonEvent = {\n    type: AddEventTypes.SubmitNewPolygon\n    payload: Polygon\n}\n\n/**\n * Event dispatched when the user wants to cancel creating a new polygon.\n */\nexport type CancelNewPolygonEvent = {\n    type: AddEventTypes.CancelNewPolygon\n}\n\n/**\n * All possible events for the \"Add poloygon\" process\n */\nexport type AddEvent =\n    | AddPolygonEvent\n    | AddPointToNewPolygonEvent\n    | SubmitNewPolygonEvent\n    | CancelNewPolygonEvent\n\n/**\n * Event creator instructing the program the user wants to create a new polygon.\n */\nexport const addPolygon = (): AddPolygonEvent => ({ type: AddEventTypes.AddPolygon })\n\n/**\n * Event creator instructing the program to add a new point to the new polygon.\n */\nexport const addPointToNewPolygon = (point: Point): AddPointToNewPolygonEvent => ({\n    type: AddEventTypes.AddPointToNewPolygon,\n    payload: point,\n})\n\n/**\n * Event creator instructing the program the user has finished creating a new polygon.\n */\nexport const submitNewPolygon = (polygon: Polygon): SubmitNewPolygonEvent => ({\n    type: AddEventTypes.SubmitNewPolygon,\n    payload: polygon,\n})\n\n/**\n * Event creator instructing the program the user wants to cancel creating a new polygon.\n */\nexport const cancelNewPolygon = (): CancelNewPolygonEvent => ({\n    type: AddEventTypes.CancelNewPolygon,\n})\n","import * as _ from 'lodash'\n\n// @ts-ignore\nimport RbushClass from 'rbush/index'\n\nimport { Polygon, Point } from './types'\n\nimport { polygon2bbox, booleanPointInPolygon } from './utils'\n\ntype RBush<T = {}> = new (...args: any) => rbush.RBush<T>\n\nconst RBush: RBush = RbushClass\n\nconst polygonToItem = (polygon: Polygon, index: number) =>\n    Object.assign(polygon2bbox(polygon), { polygon, index })\n\ntype Item = ReturnType<typeof polygonToItem>\ntype Tree = rbush.RBush<Item>\n\nconst insertPolygons = (tree: Tree, state: { count: number }) => (polygons: Polygon[]) => {\n    const items = polygons.map((polygon, index) => {\n        return polygonToItem(polygon, index + state.count + 1)\n    })\n    state.count += polygons.length\n    tree.load(items)\n}\n\nconst insertPolgyon = (tree: rbush.RBush<Item>, state: { count: number }) => (polygon: Polygon) => {\n    state.count += 1\n    tree.insert(polygonToItem(polygon, state.count))\n}\n\nconst searchByBoundingBox = (tree: Tree) => (boundingBox: rbush.BBox) => tree.search(boundingBox) // .map(item => item.polygon)\n\nconst searchByPoint = (tree: Tree) => {\n    const search = searchByBoundingBox(tree)\n\n    return ([x, y, a, b]: Point) => {\n        const items = search({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y,\n        })\n\n        return items.filter(item => booleanPointInPolygon([x, y, a, b], item.polygon))\n    }\n}\n\nexport default (...initialPolygons: Polygon[]) => {\n    const tree: rbush.RBush<Item> = new RBush() as any\n    Object.assign(window, { tree })\n    const state = { count: -1 }\n\n    const insert = insertPolygons(tree, state)\n    const search = searchByBoundingBox(tree)\n    const searchPoint = searchByPoint(tree)\n\n    const replace = (polygons: Polygon[]) => {\n        state.count = -1\n        tree.clear()\n        insert(polygons)\n    }\n    insert(initialPolygons)\n\n    return {\n        insert,\n        search,\n        searchPoint,\n        replace,\n    }\n}\n","import { PointShape } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (point: PointShape<any>, context = ctx) => {\n    context.beginPath()\n    context.arc(point.shape[0], point.shape[1], 5, 0, 2 * Math.PI)\n    context.fillStyle = '#fff'\n    context.fill()\n    context.stroke()\n    context.closePath()\n}\n","import { PointShape, PolygonShape, ShapeTypes } from '../types'\n\nconst colors = [\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n]\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default <T extends { hovering: boolean }>(\n    marker: (point: PointShape<T>, ctx?: CanvasRenderingContext2D) => void,\n) => (ctx: CanvasRenderingContext2D) => (polygon: PolygonShape<T>, context = ctx) => {\n    //\n    context.beginPath()\n\n    polygon.shape.forEach(ring => {\n        const [[hx, hy], ...t] = ring\n\n        context.moveTo(hx, hy)\n\n        t.forEach(([x, y]) => {\n            context.lineTo(x, y)\n        })\n        context.closePath()\n    })\n\n    context.fillStyle =\n        // @ts-ignore\n        (colors[polygon.meta.id] && colors[polygon.meta.id](polygon.meta.hovering ? 1 : 0.5)) ||\n        `rgba(255, 255, 255, ${polygon.meta.hovering ? 1 : 0.5})`\n    context.strokeStyle =\n        // @ts-ignore\n        (colors[polygon.meta.id] && colors[polygon.meta.id](1)) || `rgba(255, 255, 255, 1)`\n\n    context.lineWidth = 1\n    context.lineJoin = 'round'\n\n    context.fill()\n\n    context.stroke()\n\n    // polygon.shape.forEach(ring =>\n    //     ring.forEach(point =>\n    //         marker({ shape: point, meta: polygon.meta, type: ShapeTypes.Point }, context),\n    //     ),\n    // )\n}\n","import { PointShape, LineShape, ShapeTypes } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: PointShape<any>, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (line: LineShape<any>, context = ctx) => {\n    context.beginPath()\n\n    const [[hx, hy], ...t] = line.shape\n\n    context.moveTo(hx, hy)\n\n    t.forEach(([x, y]) => {\n        context.lineTo(x, y)\n    })\n\n    context.stroke()\n\n    line.shape.forEach(point =>\n        marker({ type: ShapeTypes.Point, shape: point, meta: line.meta }, context),\n    )\n}\n","export default (ctx: CanvasRenderingContext2D) => () => {\n    ctx.fillStyle = '#ffffff'\n    ctx.strokeStyle = '#000000'\n    ctx.lineWidth = 1\n    ctx.shadowBlur = 0\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'\n}\n","import { Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (data: {\n    type: 'P' | 'M' | 'L'\n    point: Point\n}) => {\n    const [x, y] = data.point\n    ctx.fillStyle = 'transparent'\n    ctx.lineWidth = 1\n\n    ctx.beginPath()\n    ctx.arc(x, y, 1, 0, 2 * Math.PI)\n    ctx.stroke()\n    ctx.fill()\n    ctx.closePath()\n\n    ctx.lineWidth = 2\n    ctx.strokeStyle =\n        // if\n        data.type === 'P'\n            ? // then\n              'Yellow'\n            : // else if\n            data.type === 'L'\n            ? // then\n              'Cyan'\n            : // else\n              'Black'\n\n    ctx.beginPath()\n    ctx.arc(x, y, 15, 0, 2 * Math.PI)\n    ctx.stroke()\n    ctx.fill()\n    ctx.closePath()\n}\n","export default (canvas: HTMLCanvasElement) => () => {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx) {\n        ctx.save()\n\n        // Use the identity matrix while clearing the canvas\n        ctx.setTransform(1, 0, 0, 1, 0, 0)\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n        ctx.restore()\n    }\n}\n","import defaultMarker from './marker'\nimport defaultPolygon from './polygon'\nimport defaultLine from './line'\nimport defaultResetStyles from './resetStyles'\nimport defaultCursor from './cursor'\nimport eraser from './eraser'\n\ninterface Api {\n    marker: typeof defaultMarker\n    polygon: typeof defaultPolygon\n    line: typeof defaultLine\n    cursor: typeof defaultCursor\n    resetStyles: typeof defaultResetStyles\n}\n\nexport default (api: Partial<Api> = {}) => (canvas: HTMLCanvasElement) => {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx) {\n        const finalMarker = (api.marker || defaultMarker)(ctx)\n        const finalPolygon = (api.polygon || defaultPolygon)(finalMarker)(ctx)\n        const finalLine = (api.line || defaultLine)(finalMarker)(ctx)\n        const cursor = (api.cursor || defaultCursor)(ctx)\n        const resetStyles = (api.resetStyles || defaultResetStyles)(ctx)\n\n        return {\n            marker: finalMarker,\n            polygon: finalPolygon,\n            line: finalLine,\n            resetStyles,\n            cursor,\n            eraser: eraser(canvas),\n            api: {\n                marker: defaultMarker,\n                polygon: defaultPolygon(finalMarker),\n                line: defaultLine(finalMarker),\n                resetStyles: defaultResetStyles,\n                cursor: defaultCursor,\n                eraser,\n            },\n        }\n    }\n}\n","import { fromEvent, Observable } from 'rxjs'\nimport { map, filter, mapTo } from 'rxjs/operators'\n\nimport { Event, EventType } from './events'\n\nimport { mapProp, first } from './utils'\n\nexport const mapFirst = map(first)\n\n/**\n *\n */\nexport const mapObservableToProp = <K extends string>(k: K) => <T extends { [P in K]: T[K] }>(\n    $: Observable<T>,\n): Observable<T[K]> => $.pipe(map(mapProp(k)))\n\nexport const mapObservableToPropType = mapObservableToProp('type')\n\n/**\n *\n */\nexport const makeFromEventType = (eventTypes$: Observable<Event['type']>) => <T extends EventType>(\n    eventType: T,\n) =>\n    eventTypes$.pipe(\n        filter(\n            (dispatchedEventType): dispatchedEventType is T => eventType === dispatchedEventType,\n        ),\n    )\n\n/**\n *\n */\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress')\n/**\n *\n */\nexport const keyPressCode$ = keyPress$.pipe(map(evt => evt.keyCode))\n\n/**\n *\n */\nexport const ofKeyCode = (keyCode: number | number[]) =>\n    keyPressCode$.pipe(\n        filter(pressedKeyCode =>\n            Array.isArray(keyCode) ? keyCode.includes(pressedKeyCode) : pressedKeyCode === keyCode,\n        ),\n    )\n\n/**\n *\n */\nexport const enterKey$ = ofKeyCode(13)\n\n/**\n *\n */\nexport const cancelKey$ = ofKeyCode(99)\n\nexport const undoKey$ = keyPress$\n    .pipe(filter(evt => evt.ctrlKey && [122, 90, 26].includes(evt.keyCode)))\n    .pipe(mapTo('undo' as const))\n\nexport const redoKey$ = keyPress$\n    .pipe(filter(evt => evt.ctrlKey && [121, 89, 25].includes(evt.keyCode)))\n    .pipe(mapTo('redo' as const))\n","import { State, NoopState, StateType, Point } from '../types'\n\nimport { AddState } from './types'\nimport { AddEventTypes } from './events'\nimport { Event } from '../events'\n\n/**\n * Transitions state to the beginning o the \"Add polygon\" process\n */\nexport const fromNoopToAddPolygon = <T>(state: NoopState): AddState => {\n    return {\n        value: StateType.AddPolygon,\n    }\n}\n\n/**\n * Adds a point to the new poloygon the user is creating.\n */\nexport const addPointToNewPolygon = <T>(state: AddState, point: Point): AddState => {\n    return {\n        value: StateType.AddPolygon,\n    }\n}\n\n/**\n * Transitions state to include the new polygon and return to base state.\n */\nexport const submitNewPolygon = <T>(state: AddState): NoopState => {\n    return {\n        value: StateType.Noop,\n    }\n}\n\n/**\n * Transitions back to base state without a new polygon.\n */\nexport const cancelNewPolygon = <T>(state: AddState): NoopState => {\n    return {\n        value: StateType.Noop,\n    }\n}\n\n/**\n * Handles incoming events and transitions state accordingly.\n */\nexport default <T>(state: State<T>, event: Event): State<T> => {\n    // Transition to \"AddPolygon\" state\n    if (event.type === AddEventTypes.AddPolygon && state.value === StateType.Noop) {\n        return fromNoopToAddPolygon<T>(state)\n    }\n\n    // Add point to new polygon currently being drawn\n    else if (\n        event.type === AddEventTypes.AddPointToNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return addPointToNewPolygon(state, event.payload)\n    }\n\n    // Finish drawing new polygon\n    else if (\n        event.type === AddEventTypes.SubmitNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return submitNewPolygon(state)\n    }\n\n    // Cancel drawing a new polygon\n    else if (\n        event.type === AddEventTypes.CancelNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return cancelNewPolygon(state)\n    }\n\n    return state\n}\n","import { State, Point, Shape, StateType, PointShape, LineShape, PolygonShape } from './types'\nimport { memoize, isPolygonShape, isPointShape, isLineShape, emptyArray, last } from './utils'\nimport { multiLineString as turfMultiLineString } from '@turf/helpers'\n\n/**\n * From `[Polygon, T] -> [Polygon]\n */\nexport const filterPolygonShapes = memoize(<T>(shapes: Shape<T>[]): PolygonShape<T>[] =>\n    shapes.filter(isPolygonShape),\n)\n\n/** TODO */\nexport const filterLineShapes = memoize(<T>(shapes: Shape<T>[]): LineShape<T>[] =>\n    shapes.filter(isLineShape),\n)\n\n/** TODO */\nexport const filterPointShapes = memoize(<T>(shapes: Shape<T>[]): PointShape<T>[] =>\n    shapes.filter(isPointShape),\n)\n\n/**\n * Redduces a list of [[PointShape]] into a list of points\n */\nexport const convertPointShapesToListOfPoints = memoize(<T>(pointShapes: PointShape<T>[]) =>\n    pointShapes.map(pointShape => pointShape.shape),\n)\nexport const convertLineShapesToListOfPoints = memoize(<T>(lineShapes: LineShape<T>[]) =>\n    lineShapes.flatMap(lineShape => lineShape.shape),\n)\nexport const convertPolygonShapesToListOfPoints = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape => polygonShape.shape.flat()),\n)\nexport const convertPolygonShapesToListOfLines = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape =>\n        polygonShape.shape.flatMap(ring => {\n            const [a, b, ...c] = ring\n            return c.reduce(\n                (acc, next) => {\n                    if (acc.length > 0) {\n                        const [, p] = last(acc)\n                        acc.push([p, next])\n                    }\n                    return acc\n                },\n                [[a, b]] as [Point, Point][],\n            )\n        }),\n    ),\n)\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfPoints = memoize(<T>(shapes: Shape<T>[]): Point[] => [\n    ...convertPointShapesToListOfPoints(filterPointShapes(shapes)),\n    ...convertLineShapesToListOfPoints(filterLineShapes(shapes)),\n    ...convertPolygonShapesToListOfPoints(filterPolygonShapes(shapes)),\n])\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfLines = memoize(<T>(shapes: Shape<T>[]): [Point, Point][] =>\n    convertPolygonShapesToListOfLines(filterPolygonShapes(shapes)),\n)\n\nexport const convertListOfLinesToLineString = memoize((lineDb: [Point, Point][]) =>\n    turfMultiLineString(\n        lineDb.flatMap(([a, b]) => {\n            if (a.length === 4 && b.length === 4) {\n                const [, , x1, y1] = a\n                const [, , x2, y2] = b\n\n                return [[[x1, y1], [x2, y2]]]\n            }\n\n            return []\n        }),\n    ),\n)\n","import { Observable, concat, merge, of, combineLatest } from 'rxjs'\nimport { take, tap, filter, scan, mapTo, takeWhile, map } from 'rxjs/operators'\n\nimport { cancelKey$, enterKey$, ofKeyCode, undoKey$, redoKey$ } from '../observables'\nimport { AddEventTypes, submitNewPolygon, cancelNewPolygon, addPolygon } from './events'\nimport { Point } from '../types'\nimport { Event } from '../events'\nimport { isNotOfTypeNbr, initial, head, tail, first, tuple } from '../utils'\n\n/**\n * Creates a program that will add a point to [[AddState]]'s `.newPolygon`\n * on every mosue click until the cancel or submit events are dispatched.\n */\nexport const makeAddPointToPolygon = <T>(\n    nextPoint$: Observable<Point>,\n    dispatch: (event: Event) => void,\n) => {\n    const allNewPoints$ = merge(nextPoint$, undoKey$, redoKey$).pipe(\n        scan(\n            ([currentPoints, redoPoints], event) =>\n                // if\n                Array.isArray(event)\n                    ? // then\n                      tuple([...currentPoints, event], [])\n                    : // else if\n                    event === 'undo' && currentPoints.length > 0\n                    ? // then\n                      tuple(initial(currentPoints), [\n                          currentPoints[currentPoints.length - 1],\n                          ...redoPoints,\n                      ])\n                    : // else if\n                    event === 'redo' && redoPoints.length > 0\n                    ? // then\n                      tuple([...currentPoints, head(redoPoints)], tail(redoPoints))\n                    : // else\n                      tuple(currentPoints, []),\n            tuple<Point[], Point[]>([], []),\n        ),\n        map(first),\n    )\n\n    const pressedEnter$ = enterKey$.pipe(mapTo('submit' as const))\n\n    const pressedCancel$ = cancelKey$.pipe(mapTo('cancel' as const))\n\n    type Emitted = 'submit' | 'cancel' | Point[]\n    type Accumulated = readonly [Emitted, Point[]]\n\n    return merge(pressedEnter$, pressedCancel$, allNewPoints$)\n        .pipe(\n            scan(\n                (acc, next) =>\n                    // if\n                    Array.isArray(next)\n                        ? // then\n                          ([next, next] as const)\n                        : // else\n                          ([next, acc[1]] as const),\n                // Initial scan value\n                [[], []] as Accumulated,\n            ),\n            takeWhile(\n                ([data, points]) =>\n                    // if\n                    data === 'cancel'\n                        ? // then\n                          false\n                        : // else if\n                        data === 'submit' && points.length > 2\n                        ? // then\n                          false\n                        : // else\n                          true,\n                // Inclusive takeWhile\n                true,\n            ),\n        )\n        .pipe(\n            // filter(([submit, cancel]) => submit || cancel),\n            tap(([event, points]) => {\n                if (event === 'submit' && points.length > 2) {\n                    dispatch(submitNewPolygon([points]))\n                } else if (event === 'cancel') {\n                    dispatch(cancelNewPolygon())\n                }\n            }),\n            map(([, points]) => points),\n        )\n}\n\n/**\n * Creates a program for adding new polygons.\n */\nexport default <T>(\n    nextPoint$: Observable<Point>,\n    addPolygonEvent$: Observable<AddEventTypes.AddPolygon>,\n    dispatch: (event: Event) => void,\n): Observable<Point[]> =>\n    concat(\n        merge(\n            concat(\n                // Await pressing key \"a\" or \"A\"\n                ofKeyCode([65, 97]).pipe(take(1)),\n                // Dispatch \"AddPolygon\" event\n                of(addPolygon()).pipe(tap(dispatch)),\n            ).pipe(filter(isNotOfTypeNbr)),\n            addPolygonEvent$,\n        ).pipe(take(1)),\n        makeAddPointToPolygon(nextPoint$, dispatch),\n        // Emit a final empty list of points once we are done.\n        of([] as Point[]),\n    ).pipe(filter((data): data is Point[] => Array.isArray(data)))\n","import _ from 'lodash'\n\nimport {\n    AllGeoJSON,\n    Feature,\n    FeatureCollection,\n    GeoJSONObject,\n    Geometries,\n    GeometryCollection,\n    MultiPolygon,\n    Polygon,\n    Position,\n    Types as GeoJSONTypes,\n} from '@turf/helpers'\n\nimport {\n    PolyLike,\n    PositionLike,\n    QFeature,\n    QFeatureCollection,\n    QMultiPolygon,\n    QPolygon,\n    QPolyLike,\n    QPosition,\n} from './types'\nimport { Point } from '../types'\n\ntype Project = (xy: number[]) => number[]\n\ninterface Collect {\n    coordinates: QPosition[]\n    lines: [QPosition, QPosition][]\n}\n\nconst defaultCollect = (): Collect => ({ coordinates: [], lines: [] })\n\nexport const pointPixelsAreEqual = ([x1, y1]: PositionLike, [x2, y2]: PositionLike): boolean => {\n    console.log(`${x1} === ${x2} && ${y1} === ${y2}`)\n    const eq = _.isEqual([x1, y1], [x2, y2])\n    console.log('Eq: ' + eq)\n    return eq\n}\n\nexport const projectGeometry = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Polygon | MultiPolygon,\n): QPolygon | QMultiPolygon => {\n    switch (geom.type) {\n        case 'MultiPolygon':\n            return projectMultiPolygon(project)(collect)(geom)\n        case 'Polygon':\n            return projectPolygon(project)(collect)(geom)\n        default:\n            return geom\n    }\n}\n\nexport const projectGeoJSON = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: PolyLike,\n): QPolyLike => {\n    switch (geom.type) {\n        case 'FeatureCollection':\n            return projectFeatureCollection(project)(collect)(geom as any)\n        case 'Feature':\n            return projectFeature(project)(collect)(geom)\n        // case 'GeometryCollection':\n        //   return projectGeometryCollection(project)(collect)(geom)\n        default:\n            return projectGeometry(project)(collect)(geom)\n    }\n}\n\nexport const projectFeature = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Feature<Polygon | MultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    geometry: projectGeometry(project)(collect)(geom.geometry),\n})\n\nexport const projectFeatureCollection = (project: Project) => (\n    collect: Collect = defaultCollect(),\n) => (\n    geom: FeatureCollection<Polygon | MultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    features: geom.features.map(projectFeature(project)(collect)),\n})\n\n// export const projectGeometryCollection = (project: Project) => (collect: Collect = defaultCollect()) => (\n//   geom: any\n// ): GeometryCollection => ({\n//   ...geom,\n//   geometries: geom.geometries.map(projectGeometry(project)(collect))\n// })\n\nexport const projectMultiPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: MultiPolygon,\n): QMultiPolygon => ({\n    ...polygon,\n    coordinates: polygon.coordinates.map(poly => poly.map(projectPositions(project)(collect))),\n})\n\nexport const projectPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: Polygon,\n): QPolygon => {\n    return {\n        ...polygon,\n        coordinates: polygon.coordinates.map(projectPositions(project)(collect)),\n    }\n}\n\nexport const projectPositions = (project: Project) => (collect: Collect = defaultCollect()) => (\n    coords: Position[],\n): QPosition[] =>\n    coords.map((coord, index) => {\n        const projected = project(coord)\n\n        const point: QPosition = [projected[0], projected[1], coord[0], coord[1]]\n        collect.coordinates.push(point)\n\n        if (index > 0) {\n            collect.lines.push([collect.coordinates[collect.coordinates.length - 2], point])\n\n            if (index === coords.length - 1) {\n                collect.lines.push([\n                    point,\n                    collect.coordinates[collect.coordinates.length - coords.length],\n                ])\n            }\n        }\n\n        return point\n    })\n\nexport const pointToLineDistance = ([x, y]: number[], [[x1, y1], [x2, y2]]: number[][]) => {\n    const A = x - x1\n    const B = y - y1\n    const C = x2 - x1\n    const D = y2 - y1\n\n    const dot = A * C + B * D\n    const lenSq = C * C + D * D\n    let param = -1\n    if (lenSq !== 0) {\n        // in case of 0 length line\n        param = dot / lenSq\n    }\n\n    let xx: number\n    let yy: number\n\n    if (param < 0) {\n        xx = x1\n        yy = y1\n    } else if (param > 1) {\n        xx = x2\n        yy = y2\n    } else {\n        xx = x1 + param * C\n        yy = y1 + param * D\n    }\n\n    const dx = x - xx\n    const dy = y - yy\n    return [[xx, yy], Math.sqrt(dx * dx + dy * dy)] as [number[], number]\n}\n\n/**\n *\n * @param position\n * @param lines\n */\nexport const findLineSnapPosition = (\n    [x, y, lng, lat]: [number, number, number, number],\n    lines: [[number, number, number, number], [number, number, number, number]][],\n) => {\n    let point: [number, number] | undefined\n    let distance = -1\n    let line: [[number, number, number, number], [number, number, number, number]] | undefined\n\n    lines.find((poly): boolean => {\n        const [[x1, y1, lng1, lat1], [x2, y2, lng2, lat2]] = poly\n        const [xy, dxy] = pointToLineDistance([x, y], [[x1, y1], [x2, y2]])\n\n        if (dxy <= 5) {\n            point = xy as [number, number]\n            distance = dxy\n            line = poly\n\n            return true\n        }\n\n        return false\n    })\n\n    if (distance >= 0 && point != null && line != null) {\n        return { point, distance, line }\n    }\n\n    return undefined\n}\n\nconst fromQPosition2Position = ([, , lng, lat]: QPosition): Position => [lng, lat]\n\nconst fromQPositions2Positions = (qPositions: QPosition[]): Position[] =>\n    qPositions.map(fromQPosition2Position)\n\nconst fromQPositionsSets2PositionsSets = (sets: QPosition[][]): Position[][] =>\n    sets.map(fromQPositions2Positions)\n\nconst fromQPolygon2Polygon = (qPolygon: QPolygon): Polygon => {\n    return {\n        ...qPolygon,\n        coordinates: fromQPositionsSets2PositionsSets(qPolygon.coordinates),\n    }\n}\n\nconst fromQMultiPolygon2MultiPolygon = (qMultiPolygon: QMultiPolygon): MultiPolygon => {\n    return {\n        ...qMultiPolygon,\n        coordinates: qMultiPolygon.coordinates.map(fromQPositionsSets2PositionsSets),\n    }\n}\n\nconst fromQGeometry2Geometry = (geometry: QPolygon | QMultiPolygon) => {\n    if (geometry.type === 'MultiPolygon') {\n        return fromQMultiPolygon2MultiPolygon(geometry)\n    }\n\n    return fromQPolygon2Polygon(geometry)\n}\n\nconst fromQFeature2Feature = (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): Feature<Polygon | MultiPolygon> => {\n    return {\n        ...feature,\n        geometry: fromQGeometry2Geometry(feature.geometry),\n    }\n}\n\nexport const fromQLikeToPolyLike = (qLike: QPolyLike): PolyLike => {\n    if (qLike.type === 'FeatureCollection') {\n        return {\n            ...qLike,\n            features: qLike.features.map(fromQFeature2Feature),\n        }\n    } else if (qLike.type === 'Feature') {\n        return fromQFeature2Feature(qLike)\n    }\n\n    return fromQGeometry2Geometry(qLike)\n}\n\nexport const mapGeometry = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (geometry: QPolygon | QMultiPolygon): QPolygon | QMultiPolygon => {\n    const nextGeometry = f(geometry)\n\n    if (nextGeometry !== geometry) {\n        return nextGeometry\n    }\n\n    return geometry\n}\n\nexport const mapFeature = (f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon) => (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => {\n    const nextGeometry = f(feature.geometry)\n\n    if (nextGeometry !== feature.geometry) {\n        return {\n            ...feature,\n            geometry: nextGeometry,\n        }\n    }\n\n    return feature\n}\n\nexport const mapFeatureCollection = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (\n    featureCollection: QFeatureCollection<QPolygon | QMultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => {\n    const nextFeatures: QFeature<QPolygon | QMultiPolygon>[] = []\n    let didChange = false\n\n    featureCollection.features.forEach(feature => {\n        const nextFeature = mapFeature(f)(feature)\n\n        if (nextFeature !== feature) {\n            didChange = true\n            nextFeatures.push(nextFeature)\n        }\n    })\n\n    if (didChange) {\n        return {\n            ...featureCollection,\n            features: nextFeatures,\n        }\n    }\n\n    return featureCollection\n}\n\nexport const mapPolyLike = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (polyLike: QPolyLike): QPolyLike => {\n    if (polyLike.type === 'Feature') {\n        return mapFeature(f)(polyLike)\n    } else if (polyLike.type === 'FeatureCollection') {\n        return mapFeatureCollection(f)(polyLike)\n    }\n\n    return mapGeometry(f)(polyLike)\n}\n\nexport const injectLineSnapPosition = (\n    ring: QPosition[],\n    line: [QPosition, QPosition],\n    point: QPosition,\n) => {\n    let didInject = false\n\n    const nextRing = ring.reduce(\n        (acc, coord) => {\n            const previous = acc[acc.length - 1]\n\n            if (\n                didInject === false &&\n                previous &&\n                pointPixelsAreEqual(previous, line[0]) &&\n                pointPixelsAreEqual(coord, line[1])\n            ) {\n                didInject = true\n                acc.push(point, coord)\n            } else {\n                acc.push(coord)\n            }\n\n            return acc\n        },\n        [] as QPosition[],\n    )\n\n    return { didInject, ring: nextRing }\n}\n\nexport const mapMouseEventToCoords = (evt: MouseEvent): [number, number] => [\n    evt.offsetX,\n    evt.offsetY,\n]\n","import {\n    ConnectableObservable,\n    fromEvent,\n    Observable,\n    of,\n    OperatorFunction,\n    race,\n    Subject,\n} from 'rxjs'\nimport { filter, map, multicast, publish, switchMapTo, take, tap } from 'rxjs/operators'\n\nimport { Either, left, right } from 'fp-ts/lib/Either'\n\nimport { mapMouseEventToCoords } from './utils'\n\nexport const toMulticast = <T>(\n    observable: Observable<T>,\n    connect = true,\n): ConnectableObservable<T> => {\n    const publishedObservable: ConnectableObservable<T> = observable.pipe(publish()) as any\n\n    if (connect === true) {\n        publishedObservable.connect()\n    }\n\n    return publishedObservable\n}\n\n/**\n *\n * @param event\n */\nexport const createEventObservableCreator = <E = MouseEvent>(event: string) => (\n    mouseCanvas: HTMLCanvasElement,\n) => toMulticast(fromEvent<E>(mouseCanvas, event))\n\n/**\n *\n */\nexport const createMouseMoveObservable = createEventObservableCreator<MouseEvent>('mousemove')\n\n/**\n *\n */\nexport const createMouseDownObservable = createEventObservableCreator<MouseEvent>('mousedown')\n\n/**\n *\n */\nexport const createMouseUpObservable = createEventObservableCreator<MouseEvent>('mouseup')\n\n/**\n *\n */\nexport const createMouseClickObservable = createEventObservableCreator<MouseEvent>('click')\n\nexport const createMouseMovePosObservable = (mouseMove$: Observable<MouseEvent>) =>\n    mouseMove$.pipe(map(mapMouseEventToCoords))\n\nexport const createMouseDownPosObservable = (mouseDown$: Observable<MouseEvent>) =>\n    mouseDown$.pipe(map(mapMouseEventToCoords))\n\nexport const createMouseUpPosObservable = (mouseUp$: Observable<MouseEvent>) =>\n    mouseUp$.pipe(map(mapMouseEventToCoords))\n\nexport const createMouseClickPosObservable = (mouseClick$: Observable<MouseEvent>) =>\n    mouseClick$.pipe(map(mapMouseEventToCoords))\n\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress') // .pipe(tap(console.info))\n\nexport const keyPressCode$ = keyPress$.pipe(map(evt => evt.keyCode))\n\nexport const ofKeyCode = (keyCode: number) =>\n    keyPressCode$.pipe(filter(pressedKeyCode => pressedKeyCode === keyCode))\n\nexport const enterKey$ = ofKeyCode(13)\n\nexport const cancelKey$ = ofKeyCode(99)\n\n/**\n * From one observable to a race between 2 others to a observable of Eihter<L, R>\n * @param observable\n */\nexport const fromObservableToEither =\n    // From observable T\n    <A>(observable: Observable<A>) =>\n        // with observable L\n        <L>(leftObservable: Observable<L>) =>\n            // And observable R\n            <R>(rightObservable: Observable<R>): Observable<Either<L, R>> =>\n                // To observable Either<L, R>\n                observable.pipe(\n                    switchMapTo(\n                        // Race left or right\n                        race(\n                            leftObservable.pipe(map((evt: L): Either<L, R> => left(evt))),\n                            rightObservable.pipe(map((evt: R): Either<L, R> => right(evt))),\n                        ).pipe(take(1)),\n                    ),\n                )\n\nexport const mapRight = <L, R>(observable: Observable<Either<L, R>>) =>\n    observable.pipe(\n        filter(lr => lr.isRight()),\n        map(rightEither => rightEither.value as R),\n    )\n\nexport const mapRightTo = <L, R>(observable: Observable<Either<L, R>>) => (\n    operatorFn: OperatorFunction<R, R>,\n) => mapRight(observable).pipe(operatorFn)\n\nexport const mapLeft = <L, R>(observable: Observable<Either<L, R>>) =>\n    observable.pipe(\n        filter(lr => lr.isLeft()),\n        map(leftEither => leftEither.value as L),\n    )\n\nexport const mapLeftTo = <L, R>(observable: Observable<Either<L, R>>) => (\n    operatorFn: OperatorFunction<L, L>,\n) => mapLeft(observable).pipe(operatorFn)\n\nexport default (mouseCanvas: HTMLCanvasElement, canvas: HTMLCanvasElement) => {\n    const mouseMove$ = createMouseMoveObservable(mouseCanvas)\n    const mouseDown$ = createMouseDownObservable(mouseCanvas)\n    const mouseUp$ = createMouseUpObservable(mouseCanvas)\n    const mouseClick$ = createMouseClickObservable(mouseCanvas)\n\n    const mouseMovePos$ = createMouseMovePosObservable(mouseMove$)\n    const mouseDownPos$ = createMouseDownPosObservable(mouseDown$)\n    const mouseUpPos$ = createMouseUpPosObservable(mouseUp$)\n    const mouseClickPos$ = createMouseClickPosObservable(mouseClick$)\n\n    const mouseMoveEventOrUpPos$ = fromObservableToEither(mouseDown$)(mouseMove$)(mouseUpPos$)\n    const mouseUpEventOrMovePos$ = fromObservableToEither(mouseDown$)(mouseUp$)(mouseMovePos$)\n\n    const mapToUpPosFromEither = mapRightTo(mouseMoveEventOrUpPos$)\n    const mapToMovePosFromUpMoveEither = mapLeftTo(mouseUpEventOrMovePos$)\n\n    return {\n        mouseMove$,\n        mouseDown$,\n        mouseUp$,\n        mouseClick$,\n        mouseMovePos$,\n        mouseDownPos$,\n        mouseUpPos$,\n        mouseClickPos$,\n        keyPress$,\n        enterKey$,\n        mouseMoveEventOrUpPos$,\n        mouseUpEventOrMovePos$,\n        mapToUpPosFromEither,\n        mapToMovePosFromUpMoveEither,\n        toMulticast,\n    }\n}\n","import {\n    fromEvent,\n    merge,\n    Subject,\n    Observable,\n    of,\n    combineLatest,\n    observable,\n    BehaviorSubject,\n} from 'rxjs'\nimport {\n    map,\n    tap,\n    repeat,\n    filter,\n    scan,\n    mapTo,\n    switchMap,\n    startWith,\n    switchMapTo,\n    mergeMap,\n    withLatestFrom,\n} from 'rxjs/operators'\n\nimport KDBush from 'kdbush'\nimport createPolyBush from './rbush'\n\n// @ts-ignore\nimport nearestPointOnLine from '@turf/nearest-point-on-line'\n\nimport { StateType, State, Point, Shape, ShapeTypes, ConvertPoint, Snap, SnapType } from './types'\nimport { mapMouseEventToOffset } from './utils'\nimport pencil_ from './pencils'\nimport { Event } from './events'\nimport transition from './reducers'\nimport { mapFirst, ofKeyCode, makeFromEventType, mapObservableToPropType } from './observables'\nimport {\n    convertShapesToListOfPoints,\n    filterPolygonShapes,\n    convertPolygonShapesToListOfLines,\n    convertShapesToListOfLines,\n    convertListOfLinesToLineString,\n} from './selectors'\n\nimport { AddState } from './add/types'\nimport { addPolygon, AddEventTypes, SubmitNewPolygonEvent } from './add/events'\nimport makeAddPolygonProgram from './add/observables'\nimport { isPolygonShape } from './utils'\nimport { toMulticast } from './legacy/observables'\nimport { findLineSnapPosition } from './legacy/utils'\n\nofKeyCode([120, 88]).subscribe(() => console.clear())\n\nconst translateOffsetOfCanvas = (canvas: HTMLCanvasElement) => ([x, y]: [\n    number,\n    number,\n]): Point => {\n    const [tx = 0, ty = 0] = (\n        canvas.style.transform.match(/translate3d\\((-?\\d+)px[, ]+(-?\\d+)px[, ]+(-?\\d+)/) || []\n    )\n        .map(str => +str)\n        .filter(n => !isNaN(n))\n\n    // @ts-ignore\n    return [x + tx, y + ty] as [number, number]\n}\n\nexport default <T>(convert: ConvertPoint, shapes$: Observable<Shape<T>[]>) => (\n    canvas: HTMLCanvasElement,\n    mouseCanvas: HTMLCanvasElement,\n) => {\n    const ctx = canvas.getContext('2d')\n    const mouseCtx = mouseCanvas.getContext('2d')\n    const pencil = pencil_()(canvas)\n    const mousePencil = pencil_()(mouseCanvas)\n    const translateOffset = translateOffsetOfCanvas(canvas)\n\n    if (mousePencil && pencil && ctx != null && mouseCtx != null) {\n        canvas.style.cursor = 'none'\n        mouseCanvas.style.cursor = 'none'\n\n        /**\n         * Final API for drawing markers, polygons, and lines.\n         */\n\n        /**\n         * K-2 tree used to store all points that are present within\n         * the system and used to find points that are near the mouse\n         * position to snap to.\n         */\n        const pointsDb$ = new BehaviorSubject(\n            // @ts-ignore\n            new KDBush([]) as KDBush.KDBush<Point>,\n        )\n\n        const polyDb$ = new BehaviorSubject(createPolyBush())\n\n        const lineDb$ = new BehaviorSubject([] as [Point, Point][])\n\n        /**\n         * Observable for emitting events\n         */\n        const events$ = new Subject<Event>()\n\n        /**\n         * Observable emits all event types that are dispatched\n         */\n        const eventTypes$ = mapObservableToPropType(events$.asObservable())\n\n        /**\n         * Creates an observable that filters events by type\n         */\n        const fromEventType = makeFromEventType(eventTypes$)\n\n        /**\n         * Dispatches events\n         */\n        const dispatch = (event: Event) => events$.next(event)\n\n        /**\n         * Observable streaming current and previous state\n         */\n        const stateUpdates$ = new Subject<[State<T>, State<T>]>()\n\n        /**\n         * Maps state changes to actual state\n         */\n        // const state$ = stateUpdates$.pipe(mapFirst)\n\n        /**\n         * Finds the nearest point a given point can snap to\n         */\n\n        const mapPointToSnapFn$ = combineLatest(\n            shapes$.pipe(startWith([])),\n            pointsDb$,\n            lineDb$,\n        ).pipe(\n            map(([shapes, pointsDb, lineDb]) => ([x, y, lng, lat]: Point): Snap => {\n                const pointSnap = convertShapesToListOfPoints(shapes)[pointsDb.within(x, y, 10)[0]]\n\n                if (pointSnap) {\n                    return { type: SnapType.Point, point: pointSnap }\n                }\n\n                const lineSnap = findLineSnapPosition([x, y, lng!, lat!], lineDb as any)\n\n                if (lineSnap) {\n                    const multiLineString = convertListOfLinesToLineString(lineDb)\n                    const maybePoint = nearestPointOnLine(multiLineString, [lng, lat])\n\n                    if (maybePoint) {\n                        const [sx, sy] = convert.from(maybePoint.geometry.coordinates)\n                        return {\n                            distance: 4,\n                            line: (lineSnap.line as any) as [Point, Point],\n                            type: SnapType.Line,\n                            point: [sx, sy, ...maybePoint.geometry.coordinates] as any, // [lineSnap.point[0], lineSnap.point[1], lng, lat] as Point,\n                        }\n                    }\n                    // console.log(snap)\n\n                    // const [x, y] = lineSnap.point\n                    // const [lng, lat] = convert.to(lineSnap.point)\n                    // return {\n                    //     distance: 4,\n                    //     line: (lineSnap.line as any) as [Point, Point],\n                    //     type: SnapType.Line,\n                    //     point: [x, y, lng, lat], // [lineSnap.point[0], lineSnap.point[1], lng, lat] as Point,\n                    // }\n                }\n\n                return { type: SnapType.None, point: [x, y, lng, lat] as Point }\n            }),\n        )\n\n        /**\n         *\n         */\n        const updatePointsDb$ = shapes$.pipe(\n            withLatestFrom(polyDb$),\n            tap(([shapes, polyDb]) => {\n                const polygons = filterPolygonShapes(shapes).map(item => item.shape)\n                lineDb$.next(convertShapesToListOfLines(shapes))\n                polyDb.replace(polygons)\n            }),\n            mapFirst,\n            map(convertShapesToListOfPoints),\n            tap(points => {\n                pointsDb$.next(\n                    // @ts-ignore\n                    new KDBush(points),\n                )\n            }),\n        )\n\n        let state: State<T> = {\n            value: StateType.Noop,\n        }\n\n        const setState = (nextState: State<T>, affectsHistory = true) => {\n            const prev = state\n\n            state = nextState\n            stateUpdates$.next([state, prev])\n        }\n\n        const mouseClick$ = fromEvent<MouseEvent>(mouseCanvas, 'click')\n        const mouseClickOffset$ = mouseClick$.pipe(map(e => mapMouseEventToOffset(e)))\n\n        const translatedMouseClick$ = mouseClickOffset$.pipe(map(translateOffset))\n\n        const snappedClick$ = translatedMouseClick$.pipe(\n            withLatestFrom(mapPointToSnapFn$),\n            map(([point, mapPointToSnap]) => mapPointToSnap(point)),\n        )\n\n        const mouseMove$ = fromEvent<MouseEvent>(mouseCanvas, 'mousemove')\n        const mouseMoveOffset$ = mouseMove$.pipe(map(e => mapMouseEventToOffset(e)))\n        const translatedMousemMove$ = mouseMoveOffset$.pipe(map(translateOffset))\n\n        const mousePositionSnapped$ = toMulticast(\n            translatedMousemMove$.pipe(\n                map(point => {\n                    const [px, py] = point\n                    const [lng, lat] = convert.to(point)\n\n                    return [px, py, lng, lat] as Point\n                }),\n                withLatestFrom(mapPointToSnapFn$),\n                map(([point, mapPointToSnap]) => mapPointToSnap(point)),\n            ),\n        )\n\n        const mousePositionSnappedPoint$ = mousePositionSnapped$.pipe(map(({ point }) => point))\n\n        const hoverIndex$ = translatedMousemMove$.pipe(\n            withLatestFrom(polyDb$),\n            map(([point, polyDb]) => polyDb.searchPoint(point).map(item => item.index)),\n            scan((acc, next) => [acc[1], next] as const, [[], []] as readonly [number[], number[]]),\n            filter(([a, b]) => a.length !== b.length || a.some((n, index) => n !== b[index])),\n            map(([, b]) => b),\n        )\n\n        const reduceActions$ = events$.pipe(\n            tap(event => {\n                const nextState = transition(state, event)\n\n                setState(nextState)\n            }),\n        )\n\n        const addPolygonProgram$ = makeAddPolygonProgram(\n            // snappedClick$.pipe(map(({ point }) => point)),\n            mouseClick$.pipe(\n                withLatestFrom(mousePositionSnappedPoint$),\n                map(([, point]) => point),\n            ),\n            fromEventType(AddEventTypes.AddPolygon),\n            dispatch,\n        ).pipe(repeat())\n\n        const draw$ = combineLatest(\n            shapes$.pipe(startWith([] as Shape<T>[])),\n            hoverIndex$.pipe(startWith([] as number[])),\n        ).pipe(\n            tap(data => {\n                const [shapes, hoverIndices] = data\n\n                pencil.resetStyles()\n\n                // Clear the canvas\n                pencil.eraser()\n\n                // Draw existing polygons\n                const polygons = filterPolygonShapes(shapes)\n                polygons.forEach((shape, index) => {\n                    const hovering = hoverIndices.includes(index)\n                    pencil.polygon({ ...shape, meta: { hovering, id: shape.meta } })\n                    pencil.resetStyles()\n                })\n            }),\n        )\n\n        const subscription = merge(\n            reduceActions$,\n            updatePointsDb$,\n            draw$,\n            combineLatest(\n                mousePositionSnapped$,\n                combineLatest(shapes$, addPolygonProgram$.pipe(startWith([] as Point[]))).pipe(\n                    map(([, points]) =>\n                        points.map(point => {\n                            const [, , lng, lat] = point\n                            if (lng != null && lat != null) {\n                                const [x, y] = convert.from([lng, lat])\n\n                                return [x, y, lng, lat] as Point\n                            }\n\n                            return point\n                        }),\n                    ),\n                ),\n            ).pipe(\n                tap(([mousePosition, newPolygon]) => {\n                    mousePencil.eraser()\n\n                    // Draw potential new polygon\n                    // if (state.value === StateType.AddPolygon) {\n                    if (newPolygon.length > 1) {\n                        mousePencil.polygon({\n                            type: ShapeTypes.Polygon,\n                            shape: [[...newPolygon, mousePosition.point]],\n                            // TODO Provide a way to create T for new polygons\n                            meta: { id: -1, hovering: true },\n                        })\n\n                        mousePencil.resetStyles()\n                    } else if (newPolygon.length === 1) {\n                        mousePencil.line({\n                            type: ShapeTypes.Line,\n                            shape: [...newPolygon, mousePosition.point],\n                            meta: (undefined as any) as T,\n                        })\n                        pencil.resetStyles()\n                    }\n\n                    newPolygon.forEach(point =>\n                        mousePencil.marker({\n                            type: ShapeTypes.Point,\n                            shape: point,\n                            meta: {},\n                        }),\n                    )\n\n                    if (mousePosition.type === SnapType.Line) {\n                        mouseCtx.beginPath()\n                        mouseCtx.moveTo(mousePosition.line[0][0], mousePosition.line[0][1])\n                        mouseCtx.lineTo(mousePosition.line[1][0], mousePosition.line[1][1])\n                        mouseCtx.strokeStyle = 'Cyan'\n                        mouseCtx.stroke()\n                        // ctx\n                    }\n                    mousePencil.cursor(mousePosition)\n                }),\n            ),\n        ).subscribe()\n\n        return {\n            done: () => {\n                subscription.unsubscribe()\n            },\n            api: {\n                addPolygon: () => dispatch(addPolygon()),\n                onAdd$: events$.pipe(\n                    filter(\n                        (event): event is SubmitNewPolygonEvent =>\n                            event.type === AddEventTypes.SubmitNewPolygon,\n                    ),\n                ),\n            },\n        }\n    }\n\n    throw new Error('Canvas 2D Rendering Context Not Available')\n}\n","import { State } from './types'\nimport { Event } from './events'\nimport addReducer from './add/reducer'\n\nexport default <T>(state: State<T>, event: Event): State<T> => addReducer(state, event)\n","import { of, Subject, BehaviorSubject } from 'rxjs'\n\n// Plop core\nimport core from '../core'\nimport { Point, ShapeTypes, PolygonShape, Shape, ConvertPoint } from '../core/types'\n\nimport { tap, map } from 'rxjs/operators'\nimport { FeatureCollection, Feature, Polygon, MultiPolygon } from '@turf/helpers'\n\nexport type Geometry =\n    | Feature<Polygon | MultiPolygon>\n    | FeatureCollection<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon\n\nconst isPolygon = (geometry: Polygon | MultiPolygon): geometry is Polygon =>\n    geometry.type === 'Polygon'\n\nconst isMultiPolygon = (geometry: Polygon | MultiPolygon): geometry is MultiPolygon =>\n    geometry.type === 'MultiPolygon'\n\ntype From = ConvertPoint['from']\ntype Ring = Polygon['coordinates'][0]\n\nconst rand = () => Math.floor(Math.random() * 20) + 1\n\nconst ring2points = (from: From) => ([, ...ring]: Ring) => ring.map(([x, y]) => from([x, y]))\n\nconst polygon2shape = (from: From) => <G extends Polygon>(polygon: G): PolygonShape<number> => ({\n    type: ShapeTypes.Polygon,\n    shape: polygon.coordinates.map(ring2points(from)),\n    meta: rand(),\n})\n\nconst multiPolygon2shapes = (from: From) => <G extends MultiPolygon>(\n    multiPolygon: G,\n): PolygonShape<number>[] =>\n    multiPolygon.coordinates.map(polygon => ({\n        type: ShapeTypes.Polygon,\n        shape: polygon.map(ring2points(from)),\n        meta: rand(),\n    }))\n\nconst feature2shapes = (from: From) => <G extends Feature<MultiPolygon | Polygon>>(\n    feature: G,\n): PolygonShape<number>[] =>\n    isPolygon(feature.geometry)\n        ? [polygon2shape(from)(feature.geometry)]\n        : multiPolygon2shapes(from)(feature.geometry)\n\nconst featureCollection2shapes = (from: From) => <\n    G extends FeatureCollection<MultiPolygon | Polygon>\n>(\n    featureCollection: G,\n): PolygonShape<number>[] => featureCollection.features.flatMap(feature2shapes(from))\n\nconst geometry2shapes = (from: From) => (geometry: Geometry) =>\n    geometry.type === 'FeatureCollection'\n        ? featureCollection2shapes(from)(geometry)\n        : geometry.type === 'Feature'\n        ? feature2shapes(from)(geometry)\n        : isMultiPolygon(geometry)\n        ? multiPolygon2shapes(from)(geometry)\n        : [polygon2shape(from)(geometry)]\n\nexport const geometries2shapes = (from: From) => (geometries: Geometry[]) =>\n    geometries.flatMap(geometry2shapes(from))\n\nexport default (convert: ConvertPoint) => (\n    canvas: HTMLCanvasElement,\n    mouseCanvas: HTMLCanvasElement,\n) => (geometries: Geometry[]) => {\n    const geometries$ = new BehaviorSubject(geometries)\n\n    const shapes$ = geometries$.pipe(map(geometries2shapes(convert.from)))\n\n    const plop = core(convert, shapes$)(canvas, mouseCanvas)\n\n    const refresh = () => geometries$.next(geometries$.getValue())\n\n    plop.api.onAdd$\n        .pipe(\n            tap(event => {\n                const coordinates = event.payload[0].map(px => convert.to(px))\n                coordinates.push(coordinates[0])\n                const polygon: Polygon = {\n                    type: 'Polygon',\n                    coordinates: [coordinates],\n                }\n\n                geometries$.next([...geometries$.getValue(), polygon])\n\n                refresh()\n            }),\n        )\n        .subscribe()\n\n    refresh()\n\n    return Object.assign(plop, { refresh })\n}\n","import '../../leaflet/leaflet.css'\n\nimport React from 'react'\nimport { Map, TileLayer, useLeaflet, Pane } from 'react-leaflet'\nimport _ from 'lodash'\nimport { FeatureCollection, Polygon, MultiPolygon } from '@turf/helpers'\n\n// Plop\nimport plopLeaflet from '../../modules/leaflet/src'\n\n// Data\nimport geojson from '../../data/nl.json'\n\nconst Canvas = () => {\n    const context = useLeaflet()\n    const [data, setData] = React.useState<FeatureCollection<Polygon | MultiPolygon>>(\n        geojson as any,\n    )\n\n    React.useEffect(() => {\n        if (context.map != null) {\n            const plop = plopLeaflet(context.map, { pane: context.pane })([data])\n\n            return plop.unsubscribe\n        }\n    }, [\n        context.map,\n        // context.map && context.map.getCenter().lat,\n        // context.map && context.map.getCenter().lng,\n    ])\n\n    return null\n}\n\nconst tileLayer = (\n    <TileLayer\n        url=\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n        attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n    />\n)\n\nexport default () => {\n    const [position] = React.useState([52.1326, 5.2913] as [number, number])\n\n    return (\n        <Map center={position} zoom={8}>\n            {tileLayer}\n            <Pane name=\"plop-canvas\">\n                <Canvas />\n            </Pane>\n        </Map>\n    )\n}\n","import { Map } from 'leaflet'\nimport { createCanvasLayer, fromLngLat, toLngLat } from './utils'\nimport plopGeoJSON from '../../geojson'\nimport { FeatureCollection, Feature, Polygon, MultiPolygon } from '@turf/helpers'\n\nexport type Geometry =\n    | Feature<Polygon | MultiPolygon>\n    | FeatureCollection<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon\n\nexport default (map: Map, options: { pane?: string } = {}) => (geometries: Geometry[]) => {\n    const pane = options.pane || (map.createPane('plop') && 'plop')\n    const canvasLayer = createCanvasLayer(pane)\n    const mouseCanvasLayer = createCanvasLayer(pane)\n\n    canvasLayer.addTo(map)\n    mouseCanvasLayer.addTo(map)\n\n    const elCanvas: HTMLCanvasElement = (canvasLayer as any)._container\n    const elMouseCanvasLayer: HTMLCanvasElement = (mouseCanvasLayer as any)._container\n\n    const plop = plopGeoJSON({\n        from: fromLngLat(map),\n        to: toLngLat(map),\n    })(elCanvas, elMouseCanvasLayer)(geometries)\n\n    map.addEventListener('moveend zoomend', plop.refresh)\n\n    const unsubscribe = () => {\n        map.removeEventListener('moveend zoomend', plop.refresh)\n        map.removeLayer(canvasLayer)\n        map.removeLayer(mouseCanvasLayer)\n        plop.done()\n    }\n\n    return Object.assign(plop, { unsubscribe })\n}\n","import React from 'react'\nimport './App.css'\n\nimport Map from './apps/map'\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"App\">\n            <div className=\"App-header\">\n                <p>\n                    <button\n                        onClick={\n                            // @ts-ignore\n                            () => api.api.addPolygon()\n                        }\n                    >\n                        ADD POLYGON\n                    </button>\n                </p>\n                <ol>\n                    <li>\n                        Press <i>&quot;a&quot;</i> or click the <i>&quot;Add Polygon&quot;</i>{' '}\n                        button to start drawing.\n                    </li>\n                    <li>\n                        Press <i>&quot;Enter&quot;</i> to finish drawing. You can only finish after\n                        at least 3 points are drawn.\n                    </li>\n                    <li>\n                        Press <i>&quot;c&quot;</i> to cancel the operation.\n                    </li>\n                    <li>\n                        Supports:\n                        <ul>\n                            <li>Snapping</li>\n                            <li>Undo & redo with Ctrl-Z/Y while adding points</li>\n                        </ul>\n                    </li>\n                </ol>\n            </div>\n            <div id=\"map\">\n                <Map />\n            </div>\n        </div>\n    )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}