{"version":3,"sources":["modules/core/types.ts","modules/core/utils/mapMouseEventToCoords.ts","modules/core/add/events.ts","modules/core/pencils/marker.ts","modules/core/pencils/polygon.ts","modules/core/pencils/line.ts","modules/core/pencils/resetStyles.ts","modules/core/add/reducer.ts","modules/core/utils/isPolygon.ts","modules/core/utils/index.ts","modules/core/observables.ts","modules/core/selectors.ts","modules/core/utils/isNotNr.ts","modules/core/add/observables.ts","modules/core/index.ts","modules/core/pencils/index.ts","modules/core/reducers.ts","modules/geojson/index.ts","apps/map/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ShapeTypes","StateType","EventTypes","AddEventTypes","evt","offsetX","offsetY","ctx","point","context","beginPath","arc","shape","Math","PI","fillStyle","fill","stroke","closePath","marker","polygon","forEach","ring","hx","hy","t","moveTo","x","y","lineTo","meta","type","Point","line","strokeStyle","lineWidth","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","addPolygon","AddPolygon","state","event","value","Noop","newPolygon","fromNoopToAddPolygon","AddPointToNewPolygon","addPointToNewPolygon","payload","SubmitNewPolygon","points","length","submitNewPolygon","CancelNewPolygon","cancelNewPolygon","emptyArray","memoize","f","previousA","previousB","a","Array","isArray","isPolygonShape","Polygon","isPointShape","isLineShape","Line","mapFirst","map","keyPressCode$","fromEvent","document","pipe","keyCode","tap","k","console","warn","ofKeyCode","filter","pressedKeyCode","includes","enterKey$","cancelKey$","filterPolygonShapes","shapes","filterLineShapes","filterPointShapes","convertPointShapesToListOfPoints","pointShapes","pointShape","convertLineShapesToListOfLines","lineShapes","flatMap","lineShape","convertPolygonShapesToListOfPolygons","polygonShapes","polygonShape","flat","convertShapesToListOfPoints","makeDispatchSubmitNewPolygon","dispatch","of","action","makeDispatchCancelNewPolygon","cancelOrSubmitEvent$","addPolygonState$","merge","concat","take","isNotNr","hasOwnProperty","makeSubmitNewPolygon$","makeCancelNewPolygon","makeAddPointToPolygon","onMouseClick$","takeUntil","makeAddPolygonProgram","addPolygonEvent$","shapes$","canvas","getContext","pencil","api","finalMarker","defaultMarker","defaultPolygon","defaultLine","resetStyles","pencil_","pointsDb","KDBush","events$","Subject","fromEventType","eventTypes$","eventType","dispatchedEventType","makeFromEventType","makeEventTypes","next","stateUpdates$","state$","mapPointToSnap","pointSnap","shapesState","within","updatePointsDb$","mousePosition","hovering","subscribe","history","future","setState","nextState","affectsHistory","prev","push","e","mapMouseEventToCoords","updateStateWithMousePosition$","reduceActions$","addReducer","transition","groupCollapsed","log","groupEnd","draw$","scan","acc","clearRect","width","height","undefined","subscription","pop","repeat","getState","getHistory","done","unsubscribe","Error","convert","core","refresh","from","geojson","features","feature","geometry","coordinates","Object","assign","position","Map","props","center","zoom","TileLayer","url","attribution","Pane","name","children","toLngLat","containerPointToLatLng","lng","lat","fromLngLat","latLngToContainerPoint","Canvas","useLeaflet","React","useEffect","canvasLayer","pane","padding","addTo","window","elCanvas","_container","topolokus","to","onZoomOrMove","addEventListener","removeEventListener","removeLayer","getCenter","App","className","onClick","id","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.07cdf6d5.chunk.js","sourcesContent":["import { AddState } from './add/types'\n\n/** Type alias for pixels */\nexport type Pixel = number\n\n/** Type alias for x- and y coordinates */\nexport type Coordinate = number\n\n/**\n * An (x, y) coordiante. The first 2 number represent the pixel\n * cordiantes while the optional second set of numbers are the\n * origina coordiantes. For example longitude and lattitude values.\n *\n * The system preservers the original coordiantes to prevent having\n * to convert them back and forth if they aren't changed.\n */\nexport type Point = [Pixel, Pixel, Coordinate, Coordinate] | [Pixel, Pixel]\n\n/**\n * A list of 2- or more [[Point]]s\n *\n * I would've preferred to tyep it [Point, Point, ...Point[]]\n */\nexport type Line = Point[]\n\n/**\n * A list of list of points where the first element in the list\n * is clockwise and the rest of the list counter clockwise\n * representing holes.\n *\n * I would've preferred to type it: [Point, Point, Point, ...Point[]][]\n * since each ring should have at least 3 points.\n */\nexport type Polygon = Line[]\n\nexport enum ShapeTypes {\n    Point = 'Point',\n    Polygon = 'Polygon',\n    Line = 'Line',\n}\n\nexport type PointShape<T> = {\n    type: ShapeTypes.Point\n    shape: Point\n    meta: T\n}\n\nexport type PolygonShape<T> = {\n    type: ShapeTypes.Polygon\n    shape: Polygon\n    meta: T\n}\n\nexport type LineShape<T> = {\n    type: ShapeTypes.Line\n    shape: Line\n    meta: T\n}\n\nexport type Shape<T> = PointShape<T> | PolygonShape<T> | LineShape<T>\n\nexport enum StateType {\n    Noop = 'Noop',\n    AddPolygon = 'AddPolygon',\n}\n\n// State\nexport interface SharedState<T> {\n    readonly mousePosition: [Pixel, Pixel]\n    readonly hovering: boolean\n}\n\nexport interface NoopState {\n    readonly value: StateType.Noop\n}\n\nexport type PossibleStates = NoopState | AddState\nexport type State<T> = SharedState<T> & PossibleStates\n\n// Actions\nexport enum EventTypes {\n    SelectPolygon = 'SelectPolygon',\n    EditPolygon = 'EditPolygon',\n    RemovePolygon = 'RemovePolygon',\n}\n","export default (evt: MouseEvent): [number, number] => [evt.offsetX, evt.offsetY]\n","import { Point } from '../types'\n\n/**\n * Event type descriptors for the \"Add Polygon\" process\n */\nexport enum AddEventTypes {\n    AddPolygon = 'AddPolygon',\n    AddPointToNewPolygon = 'AddPointToNewPolygon',\n    SubmitNewPolygon = 'SubmitNewPolygon',\n    CancelNewPolygon = 'CancelNewPolygon',\n}\n\n/**\n * Event dispatched when the user wants to add a new polygon.\n */\nexport type AddPolygonEvent = {\n    type: AddEventTypes.AddPolygon\n}\n\n/**\n * Event dispatched when the user clicks on the canvas to add a new point to the polygon they are creating.\n */\nexport type AddPointToNewPolygonEvent = {\n    type: AddEventTypes.AddPointToNewPolygon\n    payload: Point\n}\n\n/**\n * Event dispatched when the user has finished creating a new polygon.\n */\nexport type SubmitNewPolygonEvent = {\n    type: AddEventTypes.SubmitNewPolygon\n}\n\n/**\n * Event dispatched when the user wants to cancel creating a new polygon.\n */\nexport type CancelNewPolygonEvent = {\n    type: AddEventTypes.CancelNewPolygon\n}\n\n/**\n * All possible events for the \"Add poloygon\" process\n */\nexport type AddEvent =\n    | AddPolygonEvent\n    | AddPointToNewPolygonEvent\n    | SubmitNewPolygonEvent\n    | CancelNewPolygonEvent\n\n/**\n * Event creator instructing the program the user wants to create a new polygon.\n */\nexport const addPolygon = (): AddPolygonEvent => ({ type: AddEventTypes.AddPolygon })\n\n/**\n * Event creator instructing the program to add a new point to the new polygon.\n */\nexport const addPointToNewPolygon = (point: Point): AddPointToNewPolygonEvent => ({\n    type: AddEventTypes.AddPointToNewPolygon,\n    payload: point,\n})\n\n/**\n * Event creator instructing the program the user has finished creating a new polygon.\n */\nexport const submitNewPolygon = (): SubmitNewPolygonEvent => ({\n    type: AddEventTypes.SubmitNewPolygon,\n})\n\n/**\n * Event creator instructing the program the user wants to cancel creating a new polygon.\n */\nexport const cancelNewPolygon = (): CancelNewPolygonEvent => ({\n    type: AddEventTypes.CancelNewPolygon,\n})\n","import { PointShape } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (point: PointShape<any>, context = ctx) => {\n    context.beginPath()\n    context.arc(point.shape[0], point.shape[1], 5, 0, 2 * Math.PI)\n    context.fillStyle = '#fff'\n    context.fill()\n    context.stroke()\n    context.closePath()\n}\n","import { PointShape, PolygonShape, ShapeTypes } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default <T>(marker: (point: PointShape<T>, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (polygon: PolygonShape<T>, context = ctx) => {\n    context.beginPath()\n\n    polygon.shape.forEach(ring => {\n        const [[hx, hy], ...t] = ring\n\n        context.moveTo(hx, hy)\n\n        t.forEach(([x, y]) => {\n            context.lineTo(x, y)\n        })\n        context.closePath()\n    })\n\n    context.fillStyle = 'Cyan'\n\n    context.fill()\n\n    context.stroke()\n\n    polygon.shape.forEach(ring =>\n        ring.forEach(point =>\n            marker({ shape: point, meta: polygon.meta, type: ShapeTypes.Point }, context),\n        ),\n    )\n}\n","import { PointShape, LineShape, ShapeTypes } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: PointShape<any>, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (line: LineShape<any>, context = ctx) => {\n    context.beginPath()\n\n    const [[hx, hy], ...t] = line.shape\n\n    context.moveTo(hx, hy)\n\n    t.forEach(([x, y]) => {\n        context.lineTo(x, y)\n    })\n\n    context.stroke()\n\n    line.shape.forEach(point =>\n        marker({ type: ShapeTypes.Point, shape: point, meta: line.meta }, context),\n    )\n}\n","export default (ctx: CanvasRenderingContext2D) => {\n    ctx.fillStyle = '#ffffff'\n    ctx.strokeStyle = '#000000'\n    ctx.lineWidth = 1\n    ctx.shadowBlur = 0\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'\n}\n","import { State, NoopState, StateType, Point, SharedState } from '../types'\n\nimport { AddState } from './types'\nimport { AddEventTypes } from './events'\nimport { Event } from '../events'\n\nimport isPolygon from '../utils/isPolygon'\n\n/**\n * Transitions state to the beginning o the \"Add polygon\" process\n */\nexport const fromNoopToAddPolygon = <T>(\n    state: SharedState<T> & NoopState,\n): SharedState<T> & AddState => {\n    return {\n        ...state,\n        value: StateType.AddPolygon,\n        newPolygon: [],\n    }\n}\n\n/**\n * Adds a point to the new poloygon the user is creating.\n */\nexport const addPointToNewPolygon = <T>(\n    state: SharedState<T> & AddState,\n    point: Point,\n): SharedState<T> & AddState => {\n    return {\n        ...state,\n        value: StateType.AddPolygon,\n        newPolygon: [...state.newPolygon, point],\n    }\n}\n\n/**\n * Transitions state to include the new polygon and return to base state.\n */\nexport const submitNewPolygon = <T>(\n    state: SharedState<T> & AddState,\n    // polygon: Polygon,\n): SharedState<T> & NoopState => {\n    return {\n        ...state,\n        value: StateType.Noop,\n        // polygons: [...state.polygons, polygon],\n    }\n}\n\n/**\n * Transitions back to base state without a new polygon.\n */\nexport const cancelNewPolygon = <T>(\n    state: SharedState<T> & AddState,\n): SharedState<T> & NoopState => {\n    return {\n        ...state,\n        value: StateType.Noop,\n    }\n}\n\n/**\n * Handles incoming events and transitions state accordingly.\n */\nexport default <T>(state: State<T>, event: Event): State<T> => {\n    // Transition to \"AddPolygon\" state\n    if (event.type === AddEventTypes.AddPolygon && state.value === StateType.Noop) {\n        return fromNoopToAddPolygon<T>(state)\n    }\n\n    // Add point to new polygon currently being drawn\n    else if (\n        event.type === AddEventTypes.AddPointToNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return addPointToNewPolygon(state, event.payload)\n    }\n\n    // Finish drawing new polygon\n    else if (\n        event.type === AddEventTypes.SubmitNewPolygon &&\n        state.value === StateType.AddPolygon &&\n        isPolygon(state.newPolygon)\n    ) {\n        return submitNewPolygon(state)\n    }\n\n    // Cancel drawing a new polygon\n    else if (\n        event.type === AddEventTypes.CancelNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return cancelNewPolygon(state)\n    }\n\n    return state\n}\n","import { Point, Line } from '../types'\n\nexport default (points?: Point[]): points is Line => points != null && points.length > 2\n","import { Shape, ShapeTypes, LineShape, PointShape, PolygonShape } from '../types'\n\n/** Returns the first element of a tuple */\nexport const first = <A, B>(t: [A, B]): A => t[0]\n\nexport const emptyArray: any[] = []\n\nexport const returnEmptyArray = <T>(value: T): T =>\n    Array.isArray(value) && value.length <= 0 ? (emptyArray as any) : value\n\nexport const memoize = <A, B>(f: (a: A) => B) => {\n    let previousA: A | undefined\n    let previousB: B | undefined\n\n    return (a: A): B => {\n        if (a !== previousA) {\n            previousA = a\n            previousB = f(a)\n        }\n\n        return returnEmptyArray(previousB as B)\n    }\n}\n\nexport const isPolygonShape = <T>(shape: Shape<T>): shape is PolygonShape<T> =>\n    shape.type === ShapeTypes.Polygon\n\nexport const isPointShape = <T>(shape: Shape<T>): shape is PointShape<T> =>\n    shape.type === ShapeTypes.Point\n\nexport const isLineShape = <T>(shape: Shape<T>): shape is LineShape<T> =>\n    shape.type === ShapeTypes.Line\n","import { fromEvent, Observable } from 'rxjs'\nimport { map, filter, tap } from 'rxjs/operators'\n\nimport { Event, EventType } from './events'\n\nimport { first } from './utils'\n\n/** Maps an observable of a tuple to an observable of the first element in the tuple */\nexport const mapFirst = map(first)\n\n/**\n *\n */\nexport const makeEventTypes = (events$: Observable<Event>) => events$.pipe(map(event => event.type))\n\n/**\n *\n */\nexport const makeFromEventType = (eventTypes$: Observable<Event['type']>) => <T extends EventType>(\n    eventType: T,\n) =>\n    eventTypes$.pipe(\n        filter(\n            (dispatchedEventType): dispatchedEventType is T => eventType === dispatchedEventType,\n        ),\n    )\n\n/**\n *\n */\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress') // .pipe(tap(console.info))\n\n/**\n *\n */\nexport const keyPressCode$ = keyPress$.pipe(\n    map(evt => evt.keyCode),\n    tap(k => console.warn(k)),\n)\n\n/**\n *\n */\nexport const ofKeyCode = (keyCode: number | number[]) =>\n    keyPressCode$.pipe(\n        filter(pressedKeyCode =>\n            Array.isArray(keyCode) ? keyCode.includes(pressedKeyCode) : pressedKeyCode === keyCode,\n        ),\n    )\n\n/**\n *\n */\nexport const enterKey$ = ofKeyCode(13)\n\n/**\n *\n */\nexport const cancelKey$ = ofKeyCode(99)\n","import { State, Point, Shape, StateType, PointShape, LineShape, PolygonShape } from './types'\nimport { memoize, isPolygonShape, isPointShape, isLineShape, emptyArray } from './utils'\n\n/**\n * From `[Polygon, T] -> [Polygon]\n */\nexport const filterPolygonShapes = memoize(<T>(shapes: Shape<T>[]): PolygonShape<T>[] =>\n    shapes.filter(isPolygonShape),\n)\n\n/** TODO */\nexport const filterLineShapes = memoize(<T>(shapes: Shape<T>[]): LineShape<T>[] =>\n    shapes.filter(isLineShape),\n)\n\n/** TODO */\nexport const filterPointShapes = memoize(<T>(shapes: Shape<T>[]): PointShape<T>[] =>\n    shapes.filter(isPointShape),\n)\n\n/**\n * Redduces a list of [[PointShape]] into a list of points\n */\nexport const convertPointShapesToListOfPoints = memoize(<T>(pointShapes: PointShape<T>[]) =>\n    pointShapes.map(pointShape => pointShape.shape),\n)\nexport const convertLineShapesToListOfLines = memoize(<T>(lineShapes: LineShape<T>[]) =>\n    lineShapes.flatMap(lineShape => lineShape.shape),\n)\nexport const convertPolygonShapesToListOfPolygons = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape => polygonShape.shape.flat()),\n)\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfPoints = memoize(<T>(shapes: Shape<T>[]): Point[] => [\n    ...convertPointShapesToListOfPoints(filterPointShapes(shapes)),\n    ...convertLineShapesToListOfLines(filterLineShapes(shapes)),\n    ...convertPolygonShapesToListOfPolygons(filterPolygonShapes(shapes)),\n])\n\nexport const newPolygonS = (state: State<any>): Point[] => {\n    if (state.value === StateType.AddPolygon) {\n        return state.newPolygon\n    }\n\n    return emptyArray\n}\n","export default <T>(value: number | T): value is T => typeof value !== 'number'\n","import { Observable, concat, merge, of } from 'rxjs'\nimport { take, tap, takeUntil, filter } from 'rxjs/operators'\n\nimport { AddState } from './types'\nimport { cancelKey$, enterKey$, ofKeyCode, makeFromEventType } from '../observables'\nimport {\n    AddEventTypes,\n    addPointToNewPolygon,\n    submitNewPolygon,\n    cancelNewPolygon,\n    SubmitNewPolygonEvent,\n    addPolygon,\n} from './events'\nimport { Point } from '../types'\nimport { Event } from '../events'\nimport isNotNr from '../utils/isNotNr'\n\n/** Type describing the function that passes an event to the events$ [[Subject]] */\ntype Dispatch = (event: Event) => void\n\n/** Observable for event of type  AddPolygon */\nexport const makeAddPolygonEvent$ = (fromEventType: ReturnType<typeof makeFromEventType>) =>\n    fromEventType(AddEventTypes.AddPolygon)\n\n/** Observable for event of type  AddPointToNewPolygon */\nexport const makeAddPointToNewPolygonEvent$ = (\n    fromEventType: ReturnType<typeof makeFromEventType>,\n) => fromEventType(AddEventTypes.AddPointToNewPolygon)\n\n/** Observable for event of type  SubmitNewPolygon */\nexport const makeSubmitNewPolygonEvent$ = (fromEventType: ReturnType<typeof makeFromEventType>) =>\n    fromEventType(AddEventTypes.SubmitNewPolygon)\n\n/** Observable for event of type  CancelNewPolygon */\nexport const makeCancelNewPolygonEvent$ = (fromEventType: ReturnType<typeof makeFromEventType>) =>\n    fromEventType(AddEventTypes.CancelNewPolygon)\n\n/**\n * Creates an observable of a single dispatch SubmitNewPolygon event.\n */\nconst makeDispatchSubmitNewPolygon = (dispatch: Dispatch) =>\n    of(submitNewPolygon()).pipe(tap(action => dispatch(action)))\n\n/**\n * Creates an observable of a single dispatch CancelNewPolygon event.\n */\nconst makeDispatchCancelNewPolygon = (dispatch: Dispatch) =>\n    of(cancelNewPolygon()).pipe(tap(action => dispatch(action)))\n\n/**\n * Creates an observable that will dispatch the CancelNewPolygon event when\n * the user pressed the key (c) to cancel the \"Add poloygon\" operation.\n */\nconst makeCancelNewPolygon = (addPolygonState$: Observable<AddState>, dispatch: Dispatch) =>\n    concat(cancelKey$.pipe(take(1)), makeDispatchCancelNewPolygon(dispatch)).pipe(\n        // Filter out the key presses and only emit the CancelNewPolygonEvent event.\n        filter(isNotNr),\n    )\n\n/**\n * Given an observable that streams state updates to [[AddState]] this function creates\n * an observable that will dispatch the SubmitNewPolygon event when the user presses\n * the entery key if the number of points in the polygon is larger than 2.\n */\nconst makeSubmitNewPolygon$ = (addPolygonState$: Observable<AddState>, dispatch: Dispatch) =>\n    concat(\n        // Await state changes until the new polygon is enough points\n        // to become a valid polygon.\n        // TODO: When the user undoes adding points and reverts to 2 points\n        addPolygonState$.pipe(\n            filter(state => state.newPolygon.length > 2),\n            take(1),\n        ),\n        enterKey$.pipe(take(1)),\n        makeDispatchSubmitNewPolygon(dispatch),\n    ).pipe(\n        // Filter out the key presses and state changes so that this stream\n        // ends up only emitting the SubmitNewPolygonEvent event.\n        filter(isNotNr),\n        filter(\n            (value): value is SubmitNewPolygonEvent =>\n                isNotNr(value) && value.hasOwnProperty('type'),\n        ),\n    )\n\n/** Observable for event of type CancelNewPolygon or SubmitNewPolygon */\nconst cancelOrSubmitEvent$ = (addPolygonState$: Observable<AddState>, dispatch: Dispatch) =>\n    merge(\n        makeSubmitNewPolygon$(addPolygonState$, dispatch),\n        makeCancelNewPolygon(addPolygonState$, dispatch),\n    )\n\n/**\n * Creates a program that will add a point to [[AddState]]'s `.newPolygon`\n * on every mosue click until the cancel or submit events are dispatched.\n */\nexport const makeAddPointToPolygon = (\n    onMouseClick$: Observable<Point>,\n    addPolygonState$: Observable<AddState>,\n    dispatch: (event: Event) => void,\n) =>\n    onMouseClick$.pipe(\n        tap(point => dispatch(addPointToNewPolygon(point))),\n        takeUntil(cancelOrSubmitEvent$(addPolygonState$, dispatch)),\n    )\n\n/**\n * Creates a program for adding new polygons.\n */\nexport const makeAddPolygonProgram = (\n    onMouseClick$: Observable<Point>,\n    addPolygonState$: Observable<AddState>,\n    addPolygonEvent$: Observable<AddEventTypes.AddPolygon>,\n    dispatch: (event: Event) => void,\n) =>\n    concat(\n        merge(\n            concat(\n                // Await pressing key \"a\" or \"A\"\n                ofKeyCode([65, 97]).pipe(take(1)),\n                // Dispatch \"AddPolygon\" event\n                of(addPolygon()).pipe(tap(dispatch)),\n            ).pipe(filter(isNotNr)),\n            addPolygonEvent$,\n        ).pipe(take(1)),\n        makeAddPointToPolygon(onMouseClick$, addPolygonState$, dispatch),\n    )\n\nexport default makeAddPolygonProgram\n","import { fromEvent, merge, Subject, Observable } from 'rxjs'\nimport { map, tap, repeat, filter, scan } from 'rxjs/operators'\n\nimport KDBush from 'kdbush'\n\nimport { StateType, State, Point, Shape, SharedState, ShapeTypes } from './types'\nimport mapMouseEventToCoords from './utils/mapMouseEventToCoords'\nimport pencil_ from './pencils'\nimport { Event } from './events'\nimport transition from './reducers'\nimport { mapFirst, ofKeyCode, makeFromEventType, makeEventTypes } from './observables'\nimport { convertShapesToListOfPoints } from './selectors'\n\nimport { AddState } from './add/types'\nimport { addPolygon, AddEventTypes } from './add/events'\nimport makeAddPolygonProgram from './add/observables'\nimport { isPolygonShape } from './utils'\n\nexport default <T>(shapes$: Observable<Shape<T>[]>) => (canvas: HTMLCanvasElement) => {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx != null) {\n        /**\n         * Final API for drawing markers, polygons, and lines.\n         */\n        const pencil = pencil_()(ctx)\n\n        /**\n         * K-2 tree used to store all points that are present within\n         * the system and used to find points that are near the mouse\n         * position to snap to.\n         */\n        let pointsDb: KDBush.KDBush<Point> =\n            // @ts-ignore\n            new KDBush([])\n\n        /**\n         * Observable for emitting events\n         */\n        const events$ = new Subject<Event>()\n\n        /**\n         * Observable emits all event types that are dispatched\n         */\n        const eventTypes$ = makeEventTypes(events$)\n\n        /**\n         * Creates an observable that filters events by type\n         */\n        const fromEventType = makeFromEventType(eventTypes$)\n\n        /**\n         * Dispatches events\n         */\n        const dispatch = (event: Event) => events$.next(event)\n\n        /**\n         * Observable streaming current and previous state\n         */\n        const stateUpdates$ = new Subject<[State<T>, State<T>]>()\n\n        /**\n         * Filters state updates by checking if state has actually changed\n         */\n        const stateChanges$ = stateUpdates$.pipe(filter(([c, p]) => c !== p))\n\n        /**\n         * Maps state changes to actual state\n         */\n        const state$ = stateChanges$.pipe(mapFirst)\n\n        /**\n         * Finds the nearest point a given point can snap to\n         */\n        const mapPointToSnap = ([x, y]: [number, number]): [number, number] => {\n            const pointSnap = convertShapesToListOfPoints(shapesState)[pointsDb.within(x, y, 10)[0]]\n\n            return pointSnap ? [pointSnap[0], pointSnap[1]] : [x, y]\n        }\n\n        /**\n         *\n         */\n        const updatePointsDb$ = shapes$.pipe(\n            map(convertShapesToListOfPoints),\n            tap(points => {\n                // @ts-ignore\n                pointsDb = new KDBush(points)\n            }),\n        )\n\n        let state: State<T> = {\n            mousePosition: [0, 0],\n            value: StateType.Noop,\n            hovering: false,\n        }\n\n        let shapesState: Shape<T>[] = []\n        shapes$.subscribe(shapes => (shapesState = shapes))\n\n        const history: State<T>[] = []\n        let future: State<T>[] = []\n\n        const setState = (nextState: State<T>, affectsHistory = true) => {\n            const prev = state\n\n            if (affectsHistory) {\n                history.push(state)\n                future = []\n            }\n\n            state = nextState\n            stateUpdates$.next([state, prev])\n        }\n\n        const undo = () => {\n            const prev = history.pop()\n\n            if (prev) {\n                future.push(state)\n                setState(\n                    {\n                        ...prev,\n                        mousePosition: state.mousePosition,\n                    },\n                    false,\n                )\n            }\n        }\n\n        const redo = () => {\n            const next = future.pop()\n\n            if (next) {\n                history.push(next)\n                setState(\n                    {\n                        ...next,\n                        mousePosition: state.mousePosition,\n                    },\n                    false,\n                )\n            }\n        }\n\n        const onMouseClick$ = fromEvent<MouseEvent>(canvas, 'click').pipe(\n            map(e => mapMouseEventToCoords(e)),\n        )\n\n        const onMouseMoveObservable = fromEvent<MouseEvent>(canvas, 'mousemove').pipe(\n            map(e => mapMouseEventToCoords(e)),\n        )\n\n        const updateStateWithMousePosition$ = onMouseMoveObservable.pipe(\n            map(mapPointToSnap),\n            tap(mousePosition => {\n                setState(\n                    {\n                        ...state,\n                        mousePosition: mousePosition as [number, number],\n                    },\n                    false,\n                )\n            }),\n        )\n\n        // const logStateChange$ = stateUpdates$.pipe(tap(console.log))\n\n        const reduceActions$ = events$.pipe(\n            tap(event => {\n                const nextState = transition(state, event)\n                console.groupCollapsed(event.type)\n                console.log(event)\n                console.log(state)\n                console.groupEnd()\n                setState(nextState)\n            }),\n        )\n\n        const addPolygonState$ = state$.pipe(\n            filter(\n                (state): state is SharedState<T> & AddState => state.value === StateType.AddPolygon,\n            ),\n        )\n\n        const stateAndShapes$ = merge(state$, shapes$).pipe(\n            scan(\n                (acc, next) => {\n                    if (Array.isArray(next)) {\n                        return [acc[0], next] as const\n                    }\n\n                    return [next, acc[1]] as const\n                },\n                [state as State<T>, shapesState] as const,\n            ),\n        )\n\n        const draw$ = stateAndShapes$.pipe(\n            tap(([state, shapes]) => {\n                pencil.resetStyles(ctx)\n\n                // Clear the canvas\n                ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n                // Draw existing polygons in state\n                shapes.forEach(shape => {\n                    if (isPolygonShape(shape)) {\n                        pencil.polygon(shape)\n                        pencil.resetStyles(ctx)\n                    }\n                })\n\n                // Draw potential new polygon\n                if (state.value === StateType.AddPolygon) {\n                    if (state.newPolygon.length > 1) {\n                        pencil.polygon({\n                            type: ShapeTypes.Polygon,\n                            shape: [[...state.newPolygon, state.mousePosition]],\n                            // TODO Provide a way to create T for new polygons\n                            meta: (undefined as any) as T,\n                        })\n                        pencil.resetStyles(ctx)\n                    } else if (state.newPolygon.length === 1) {\n                        pencil.line({\n                            type: ShapeTypes.Line,\n                            shape: [...state.newPolygon, state.mousePosition],\n                            meta: (undefined as any) as T,\n                        })\n                        pencil.resetStyles(ctx)\n                    }\n                }\n            }),\n        )\n\n        const subscription = merge(\n            reduceActions$,\n            updateStateWithMousePosition$,\n            // logStateChange$,\n            updatePointsDb$,\n            ofKeyCode([117, 85]).pipe(tap(undo)),\n            ofKeyCode([114, 82]).pipe(tap(redo)),\n            makeAddPolygonProgram(\n                onMouseClick$.pipe(map(mapPointToSnap)),\n                addPolygonState$,\n                fromEventType(AddEventTypes.AddPolygon),\n                dispatch,\n            ).pipe(repeat()),\n            draw$,\n        ).subscribe()\n\n        return {\n            getState: () => state,\n            getHistory: () => history,\n            // subscribe: (cb: () => void) => {\n            //     stateUpdates$.subscribe(cb)\n            // },\n            done: () => {\n                subscription.unsubscribe()\n            },\n            api: {\n                addPolygon: () => dispatch(addPolygon()),\n            },\n        }\n    }\n\n    throw new Error('Canvas 2D Rendering Context Not Available')\n}\n","import defaultMarker from './marker'\nimport defaultPolygon from './polygon'\nimport defaultLine from './line'\nimport resetStyles from './resetStyles'\n\ninterface Api {\n    marker: typeof defaultMarker\n    polygon: typeof defaultPolygon\n    line: typeof defaultLine\n}\n\nexport default (api: Partial<Api> = {}) => (ctx: CanvasRenderingContext2D) => {\n    const finalMarker = (api.marker || defaultMarker)(ctx)\n    const finalPolygon = (api.polygon || defaultPolygon)(finalMarker)(ctx)\n    const finalLine = (api.line || defaultLine)(finalMarker)(ctx)\n\n    return {\n        marker: finalMarker,\n        polygon: finalPolygon,\n        line: finalLine,\n        resetStyles,\n    }\n}\n","import { State } from './types'\nimport { Event } from './events'\nimport addReducer from './add/reducer'\n\nexport default <T>(state: State<T>, event: Event): State<T> => addReducer(state, event)\n","import core from '../core'\nimport { Point, ShapeTypes, PolygonShape } from '../core/types'\n\nimport { of, Subject } from 'rxjs'\nimport geojson from '../../data/geosample.json'\n\ntype From = (coordinate: number[]) => Point\ntype To = (coordinate: Point) => number[]\n\nconst convertGeoJson = (from: From): PolygonShape<null>[] =>\n    geojson.features.map(feature => {\n        return {\n            type: ShapeTypes.Polygon,\n            shape: feature.geometry.coordinates.map(ring => ring.map(point => from(point))),\n            meta: null,\n        }\n    })\n\nexport default (convert: { from: From; to: To }) => (canvas: HTMLCanvasElement) => {\n    const shapes$ = new Subject<PolygonShape<null>[]>()\n\n    const api = core(shapes$)(canvas)\n\n    const refresh = () => shapes$.next(convertGeoJson(convert.from))\n\n    refresh()\n\n    return Object.assign(api, { refresh })\n}\n","import React from 'react'\nimport { Map as ReactLeafletMap, Popup, TileLayer, useLeaflet, Pane, Circle } from 'react-leaflet'\n\nimport '../../leaflet/leaflet.css'\nimport { canvas, Map as LeafletMap } from 'leaflet'\n\nimport topolokus from '../../modules/geojson'\n\nconst position: [number, number] = [50.251492, -107.428083] // [51.505, -0.09]\n// const position2: [number, number] = [51.885, 5.0509] // [51.505, -0.09]\n\nconst Map: React.FC = (props: { children?: React.ReactNode }) => (\n    <ReactLeafletMap center={position} zoom={18}>\n        <TileLayer\n            url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n            attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n        />\n\n        <Pane name=\"canvas\">\n            {props.children}\n            <div>xyt</div>\n        </Pane>\n    </ReactLeafletMap>\n)\n\nconst createCanvasLayer = (pane?: string) => canvas({ padding: 0, pane })\n\n// type CanvasLayer = undefined | ReturnType<typeof createCanvasLayer>\n\nconst toLngLat = (map: LeafletMap) => ([x, y]: number[]): [number, number] => {\n    const point = map.containerPointToLatLng([x, y])\n    return [point.lng, point.lat]\n}\n\nconst fromLngLat = (map: LeafletMap) => ([lng, lat]: number[]): [number, number] => {\n    const point = map.latLngToContainerPoint([lat, lng])\n    return [point.x, point.y]\n}\n\nconst Canvas = () => {\n    const context = useLeaflet()\n\n    React.useEffect(() => {\n        if (context.map != null) {\n            const map = context.map\n            const canvasLayer = createCanvasLayer(context.pane)\n            // const mouseCanvasLayer = createCanvasLayer(context.pane)\n            canvasLayer.addTo(context.map)\n            // mouseCanvasLayer.addTo(context.map)\n            // const layer = circle(position, { renderer: canvasLayer, radius: 1000 })\n            // layer.addTo(context.map)\n\n            Object.assign(window, { canvasLayer })\n\n            const elCanvas: HTMLCanvasElement = (canvasLayer as any)._container\n            // const elMouseCanvasLayer: HTMLCanvasElement = (mouseCanvasLayer as any)._container\n\n            const api = topolokus({\n                from: fromLngLat(map),\n                to: toLngLat(map),\n            })(elCanvas)\n            const onZoomOrMove = () => {\n                api.refresh()\n            }\n\n            // map.dragging.disable()\n            Object.assign(window, { api })\n\n            map.addEventListener('zoom move', onZoomOrMove)\n\n            return () => {\n                map.removeEventListener('zoom move', onZoomOrMove)\n                map.removeLayer(canvasLayer)\n                // map.removeLayer(mouseCanvasLayer)\n                api.done()\n            }\n        }\n    }, [\n        context.map,\n        context.map && context.map.getCenter().lat,\n        context.map && context.map.getCenter().lng,\n    ])\n\n    return null\n}\n\nexport default () => {\n    return (\n        <Map>\n            <Canvas />\n        </Map>\n    )\n}\n","import React from 'react'\nimport './App.css'\n\nimport Map from './apps/map'\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"App\">\n            <div className=\"App-header\">\n                <p>\n                    <button\n                        onClick={\n                            // @ts-ignore\n                            () => api.api.addPolygon()\n                        }\n                    >\n                        ADD POLYGON\n                    </button>\n                </p>\n                <ol>\n                    <li>\n                        Press <i>&quot;a&quot;</i> or click the <i>&quot;Add Polygon&quot;</i>{' '}\n                        button to start drawing.\n                    </li>\n                    <li>\n                        Press <i>&quot;Enter&quot;</i> to finish drawing. You can only finish after\n                        at least 3 points are drawn.\n                    </li>\n                    <li>\n                        Press <i>&quot;c&quot;</i> to cancel the operation.\n                    </li>\n                    <li>Snapping is supported</li>\n                </ol>\n            </div>\n            <div id=\"map\">\n                <Map />\n            </div>\n        </div>\n    )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}