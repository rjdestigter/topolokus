{"version":3,"sources":["logo.svg","modules/core/types.ts","modules/core/utils/mapMouseEventToCoords.ts","modules/core/add/events.ts","modules/core/draw/marker.ts","modules/core/draw/polygon.ts","modules/core/draw/line.ts","modules/core/draw/resetStyles.ts","modules/core/draw/index.ts","modules/core/add/reducer.ts","modules/core/utils/isPolygon.ts","modules/core/reducers.ts","modules/core/observables.ts","modules/core/utils/isNotNr.ts","modules/core/utils/is.ts","modules/core/utils/getterOf.ts","modules/core/add/observables.ts","modules/core/index.ts","apps/map/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","StateType","EventTypes","AddEventTypes","evt","offsetX","offsetY","ctx","x","y","context","beginPath","arc","Math","PI","fillStyle","fill","stroke","closePath","marker","polygon","hx","hy","t","moveTo","forEach","lineTo","point","points","strokeStyle","lineWidth","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","api","finalMarker","defaultMarker","defaultPolygon","line","defaultLine","resetStyles","addPolygon","type","AddPolygon","state","event","value","Noop","newPolygon","fromNoopToAddPolygon","AddPointToNewPolygon","addPointToNewPolygon","payload","SubmitNewPolygon","length","polygons","submitNewPolygon","CancelNewPolygon","cancelNewPolygon","addReducer","stateUpdates$","Subject","events$","eventTypes$","pipe","map","fromEventType","eventType","filter","dispatchedEventType","keyPressCode$","fromEvent","document","keyCode","ofKeyCode","pressedKeyCode","enterKey$","cancelKey$","compare","prop","obj","addPolygonEvent$","makeDispatchSubmitNewPolygon","dispatch","of","tap","action","makeDispatchCancelNewPolygon","cancelOrSubmitEvent$","addPolygonState$","merge","concat","take","isNotNr","hasOwnProperty","getterOf","is","makeSubmitNewPolygon$","makeCancelNewPolygon","makeAddPointToPolygon","onMouseClick$","takeUntil","makeAddPolygonProgram","withCanvas","canvas","getContext","pencil","pencil_","next","mousePosition","hovering","history","setState","nextState","push","e","mapMouseEventToCoords","updateStateWithMousePosition$","reduceActions$","transition","console","groupCollapsed","log","groupEnd","draw$","clearRect","width","height","subscription","repeat","subscribe","getState","getHistory","cb","done","unsubscribe","complete","Error","position","position2","Map","props","center","zoom","TileLayer","url","attribution","Circle","radius","Popup","Pane","name","children","Canvas","useLeaflet","React","useEffect","canvasLayer","pane","padding","addTo","Object","assign","window","_container","onZoomOrMove","dragging","disable","addEventListener","removeEventListener","removeLayer","getCenter","lat","lng","App","className","src","logo","alt","id","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1ef59223.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import { AddState } from './add/types'\n\n// Aliases\nexport type Pixel = number\nexport type Coord = number\n\nexport type Point = [Pixel, Pixel, Coord, Coord] | [Pixel, Pixel]\nexport type Line = Point[]\nexport type Polygon = Point[]\n\nexport enum StateType {\n    Noop = 'Noop',\n    AddPolygon = 'AddPolygon',\n}\n\n// State\nexport interface SharedState {\n    polygons: Polygon[]\n    mousePosition: [Pixel, Pixel]\n    hovering: boolean\n}\n\nexport interface NoopState extends SharedState {\n    value: StateType.Noop\n}\n\nexport type State = NoopState | AddState\n\n// Actions\nexport enum EventTypes {\n    SelectPolygon = 'SelectPolygon',\n    EditPolygon = 'EditPolygon',\n    RemovePolygon = 'RemovePolygon',\n}\n","export default (evt: MouseEvent): [number, number] => [evt.offsetX, evt.offsetY]\n","import { Point } from '../types'\n\n/**\n * Event type descriptors for the \"Add Polygon\" process\n */\nexport enum AddEventTypes {\n    AddPolygon = 'AddPolygon',\n    AddPointToNewPolygon = 'AddPointToNewPolygon',\n    SubmitNewPolygon = 'SubmitNewPolygon',\n    CancelNewPolygon = 'CancelNewPolygon',\n}\n\n/**\n * Event dispatched when the user wants to add a new polygon.\n */\nexport type AddPolygonEvent = {\n    type: AddEventTypes.AddPolygon\n}\n\n/**\n * Event dispatched when the user clicks on the canvas to add a new point to the polygon they are creating.\n */\nexport type AddPointToNewPolygonEvent = {\n    type: AddEventTypes.AddPointToNewPolygon\n    payload: Point\n}\n\n/**\n * Event dispatched when the user has finished creating a new polygon.\n */\nexport type SubmitNewPolygonEvent = {\n    type: AddEventTypes.SubmitNewPolygon\n}\n\n/**\n * Event dispatched when the user wants to cancel creating a new polygon.\n */\nexport type CancelNewPolygonEvent = {\n    type: AddEventTypes.CancelNewPolygon\n}\n\n/**\n * All possible events for the \"Add poloygon\" process\n */\nexport type AddEvent =\n    | AddPolygonEvent\n    | AddPointToNewPolygonEvent\n    | SubmitNewPolygonEvent\n    | CancelNewPolygonEvent\n\n/**\n * Event creator instructing the program the user wants to create a new polygon.\n */\nexport const addPolygon = (): AddPolygonEvent => ({ type: AddEventTypes.AddPolygon })\n\n/**\n * Event creator instructing the program to add a new point to the new polygon.\n */\nexport const addPointToNewPolygon = (point: Point): AddPointToNewPolygonEvent => ({\n    type: AddEventTypes.AddPointToNewPolygon,\n    payload: point,\n})\n\n/**\n * Event creator instructing the program the user has finished creating a new polygon.\n */\nexport const submitNewPolygon = (): SubmitNewPolygonEvent => ({\n    type: AddEventTypes.SubmitNewPolygon,\n})\n\n/**\n * Event creator instructing the program the user wants to cancel creating a new polygon.\n */\nexport const cancelNewPolygon = (): CancelNewPolygonEvent => ({\n    type: AddEventTypes.CancelNewPolygon,\n})\n","import { Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => ([x, y]: Point, context = ctx) => {\n    context.beginPath()\n    context.arc(x, y, 5, 0, 2 * Math.PI)\n    context.fillStyle = '#fff'\n    context.fill()\n    context.stroke()\n    context.closePath()\n}\n","import { Polygon, Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: Point, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (polygon: Polygon, context = ctx) => {\n    context.beginPath()\n\n    const [[hx, hy], ...t] = polygon\n\n    context.moveTo(hx, hy)\n\n    t.forEach(([x, y]) => {\n        context.lineTo(x, y)\n    })\n\n    context.fillStyle = 'Cyan'\n\n    context.fill()\n\n    context.closePath()\n\n    context.stroke()\n\n    polygon.forEach(point => marker(point, context))\n}\n","import { Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: Point, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (points: Point[], context = ctx) => {\n    context.beginPath()\n\n    const [[hx, hy], ...t] = points\n\n    context.moveTo(hx, hy)\n\n    t.forEach(([x, y]) => {\n        context.lineTo(x, y)\n    })\n\n    context.stroke()\n\n    points.forEach(point => marker(point, context))\n}\n","export default (ctx: CanvasRenderingContext2D) => {\n    ctx.fillStyle = '#ffffff'\n    ctx.strokeStyle = '#000000'\n    ctx.lineWidth = 1\n    ctx.shadowBlur = 0\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'\n}\n","import defaultMarker from './marker'\nimport defaultPolygon from './polygon'\nimport defaultLine from './line'\nimport resetStyles from './resetStyles'\n\ninterface Api {\n    marker: typeof defaultMarker\n    polygon: typeof defaultPolygon\n    line: typeof defaultLine\n}\n\nexport default (api: Partial<Api> = {}) => (ctx: CanvasRenderingContext2D) => {\n    const finalMarker = (api.marker || defaultMarker)(ctx)\n    const finalPolygon = (api.polygon || defaultPolygon)(finalMarker)(ctx)\n    const finalLine = (api.line || defaultLine)(finalMarker)(ctx)\n\n    return {\n        marker: finalMarker,\n        polygon: finalPolygon,\n        line: finalLine,\n        resetStyles,\n    }\n}\n","import { State, NoopState, StateType, Polygon, Point } from '../types'\n\nimport { AddState } from './types'\nimport { AddEventTypes } from './events'\nimport { Event } from '../events'\n\nimport isPolygon from '../utils/isPolygon'\n\n/**\n * Transitions state to the beginning o the \"Add polygon\" process\n */\nexport const fromNoopToAddPolygon = (state: NoopState): AddState => {\n    return {\n        ...state,\n        value: StateType.AddPolygon,\n        newPolygon: [],\n    }\n}\n\n/**\n * Adds a point to the new poloygon the user is creating.\n */\nexport const addPointToNewPolygon = (state: AddState, point: Point): AddState => {\n    return {\n        ...state,\n        value: StateType.AddPolygon,\n        newPolygon: [...state.newPolygon, point],\n    }\n}\n\n/**\n * Transitions state to include the new polygon and return to base state.\n */\nexport const submitNewPolygon = (state: AddState, polygon: Polygon): NoopState => {\n    return {\n        ...state,\n        value: StateType.Noop,\n        polygons: [...state.polygons, polygon],\n    }\n}\n\n/**\n * Transitions back to base state without a new polygon.\n */\nexport const cancelNewPolygon = (state: AddState): NoopState => {\n    return {\n        ...state,\n        value: StateType.Noop,\n    }\n}\n\n/**\n * Handles incoming events and transitions state accordingly.\n */\nexport default (state: State, event: Event): State => {\n    // Transition to \"AddPolygon\" state\n    if (event.type === AddEventTypes.AddPolygon && state.value === StateType.Noop) {\n        return fromNoopToAddPolygon(state)\n    }\n\n    // Add point to new polygon currently being drawn\n    else if (\n        event.type === AddEventTypes.AddPointToNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return addPointToNewPolygon(state, event.payload)\n    }\n\n    // Finish drawing new polygon\n    else if (\n        event.type === AddEventTypes.SubmitNewPolygon &&\n        state.value === StateType.AddPolygon &&\n        isPolygon(state.newPolygon)\n    ) {\n        return submitNewPolygon(state, state.newPolygon)\n    }\n\n    // Cancel drawing a new polygon\n    else if (\n        event.type === AddEventTypes.CancelNewPolygon &&\n        state.value === StateType.AddPolygon\n    ) {\n        return cancelNewPolygon(state)\n    }\n\n    return state\n}\n","import { Point, Polygon } from '../types'\n\nexport default (points?: Point[]): points is Polygon => points != null && points.length > 2\n","import { State } from './types'\nimport { Event } from './events'\nimport addReducer from './add/reducer'\n\nexport default (state: State, event: Event): State => addReducer(state, event)\n","import { Subject, fromEvent } from 'rxjs'\nimport { map, filter } from 'rxjs/operators'\n\nimport { State } from './types'\nimport { Event, EventType } from './events'\n\n/**\n *\n */\nexport const stateUpdates$ = new Subject<State>()\n\n/**\n *\n */\nexport const events$ = new Subject<Event>()\n\n/**\n *\n */\nexport const eventTypes$ = events$.pipe(map(event => event.type))\n\n/**\n *\n */\nexport const fromEventType = <T extends EventType>(eventType: T) =>\n    eventTypes$.pipe(\n        filter(\n            (dispatchedEventType): dispatchedEventType is T => eventType === dispatchedEventType,\n        ),\n    )\n\n/**\n *\n */\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress') // .pipe(tap(console.info))\n\n/**\n *\n */\nexport const keyPressCode$ = keyPress$.pipe(map(evt => evt.keyCode))\n\n/**\n *\n */\nexport const ofKeyCode = (keyCode: number) =>\n    keyPressCode$.pipe(filter(pressedKeyCode => pressedKeyCode === keyCode))\n\n/**\n *\n */\nexport const enterKey$ = ofKeyCode(13)\n\n/**\n *\n */\nexport const cancelKey$ = ofKeyCode(99)\n","export default <T>(value: number | T): value is T => typeof value !== 'number'\n","export default <A, B extends A>(value: A) => (compare: B) => value === compare\n","export default <K extends string>(prop: K) => <U, T extends { [P in K]: U }>(obj: T) => obj[prop]\n","import { Observable, concat, merge, of } from 'rxjs'\nimport { take, tap, takeUntil, filter, map } from 'rxjs/operators'\n\nimport { AddState } from './types'\nimport { fromEventType, cancelKey$, enterKey$ } from '../observables'\nimport {\n    AddEventTypes,\n    addPointToNewPolygon,\n    submitNewPolygon,\n    cancelNewPolygon,\n    CancelNewPolygonEvent,\n    SubmitNewPolygonEvent,\n} from './events'\nimport { Point } from '../types'\nimport { Event } from '../events'\nimport isNotNr from '../utils/isNotNr'\nimport is from '../utils/is'\nimport getterOf from '../utils/getterOf'\n\n/** Type describing the function that passes an event to the events$ [[Subject]] */\ntype Dispatch = (event: Event) => void\n\n/** Observable for event of type  AddPolygon */\nexport const addPolygonEvent$ = fromEventType(AddEventTypes.AddPolygon)\n\n/** Observable for event of type  AddPointToNewPolygon */\nexport const addPointToNewPolygonEvent$ = fromEventType(AddEventTypes.AddPointToNewPolygon)\n\n/** Observable for event of type  SubmitNewPolygon */\nexport const submitNewPolygonEvent$ = fromEventType(AddEventTypes.SubmitNewPolygon)\n\n/** Observable for event of type  CancelNewPolygon */\nexport const cancelNewPolygonEvent$ = fromEventType(AddEventTypes.CancelNewPolygon)\n\n/**\n *\n * @param dispatch\n */\nconst makeDispatchSubmitNewPolygon = (dispatch: Dispatch) =>\n    of(submitNewPolygon()).pipe(tap(action => dispatch(action)))\n\n/**\n *\n * @param dispatch\n */\nconst makeDispatchCancelNewPolygon = (dispatch: Dispatch) =>\n    of(cancelNewPolygon()).pipe(tap(action => dispatch(action)))\n\n/**\n *\n * @param dispatch\n */\nconst makeCancelNewPolygon = (addPolygonState$: Observable<AddState>, dispatch: Dispatch) =>\n    concat(\n        addPolygonState$.pipe(take(1)),\n        cancelKey$.pipe(take(1)),\n        makeDispatchCancelNewPolygon(dispatch),\n    ).pipe(\n        filter(isNotNr),\n        filter((value): value is CancelNewPolygonEvent => value.hasOwnProperty('type')),\n        map(getterOf('type')),\n        filter(is(AddEventTypes.CancelNewPolygon)),\n    )\n\n/**\n *\n * @param dispatch\n */\nconst makeSubmitNewPolygon$ = (addPolygonState$: Observable<AddState>, dispatch: Dispatch) =>\n    concat(\n        addPolygonState$.pipe(\n            filter(state => state.newPolygon.length > 2),\n            take(1),\n        ),\n        enterKey$.pipe(take(1)),\n        makeDispatchSubmitNewPolygon(dispatch),\n    ).pipe(\n        filter(isNotNr),\n        filter((value): value is SubmitNewPolygonEvent => value.hasOwnProperty('type')),\n        map(getterOf('type')),\n        filter(is(AddEventTypes.SubmitNewPolygon)),\n    )\n\n/** Observable for event of type CancelNewPolygon or SubmitNewPolygon */\nconst cancelOrSubmitEvent$ = (addPolygonState$: Observable<AddState>, dispatch: Dispatch) =>\n    merge(\n        makeSubmitNewPolygon$(addPolygonState$, dispatch),\n        makeCancelNewPolygon(addPolygonState$, dispatch),\n    )\n\n/**\n *\n * @param onMouseClick$\n * @param dispatch\n */\nexport const makeAddPointToPolygon = (\n    onMouseClick$: Observable<Point>,\n    addPolygonState$: Observable<AddState>,\n    dispatch: (event: Event) => void,\n) =>\n    onMouseClick$.pipe(\n        tap(point => dispatch(addPointToNewPolygon(point))),\n        takeUntil(cancelOrSubmitEvent$(addPolygonState$, dispatch)),\n    )\n\n/**\n *\n * @param onMouseClick$\n * @param dispatch\n */\nexport const makeAddPolygonProgram = (\n    onMouseClick$: Observable<Point>,\n    addPolygonState$: Observable<AddState>,\n    dispatch: (event: Event) => void,\n) =>\n    concat(\n        addPolygonEvent$.pipe(take(1)),\n        makeAddPointToPolygon(onMouseClick$, addPolygonState$, dispatch),\n    )\n\nexport default makeAddPolygonProgram\n","import { fromEvent, merge } from 'rxjs'\nimport { map, tap, repeat, filter } from 'rxjs/operators'\n\nimport { StateType, State } from './types'\nimport mapMouseEventToCoords from './utils/mapMouseEventToCoords'\nimport pencil_ from './draw'\nimport { Event } from './events'\nimport transition from './reducers'\nimport { stateUpdates$, events$ } from './observables'\n\nimport { AddState } from './add/types'\nimport { addPolygon } from './add/events'\nimport makeAddPolygonProgram from './add/observables'\n\nexport function withCanvas(canvas: HTMLCanvasElement) {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx != null) {\n        const pencil = pencil_()(ctx)\n\n        const dispatch = (event: Event) => events$.next(event)\n\n        let state: State = {\n            mousePosition: [0, 0],\n            value: StateType.Noop,\n            polygons: [],\n            hovering: false,\n        }\n\n        const history: State[] = []\n\n        const setState = (nextState: State) => {\n            history.push(state)\n            state = nextState\n            stateUpdates$.next(state)\n        }\n\n        const onMouseClick$ = fromEvent<MouseEvent>(canvas, 'click').pipe(\n            map(e => mapMouseEventToCoords(e)),\n        )\n\n        const onMouseMoveObservable = fromEvent<MouseEvent>(canvas, 'mousemove').pipe(\n            map(e => mapMouseEventToCoords(e)),\n        )\n\n        const updateStateWithMousePosition$ = onMouseMoveObservable.pipe(\n            tap(evt => {\n                setState({\n                    ...state,\n                    mousePosition: evt,\n                })\n            }),\n        )\n\n        // const logStateChange$ = stateUpdates$.pipe(tap(console.log))\n\n        const reduceActions$ = events$.pipe(\n            tap(event => {\n                const nextState = transition(state, event)\n                console.groupCollapsed(event.type)\n                console.log(event)\n                console.log(state)\n                console.groupEnd()\n                setState(nextState)\n            }),\n        )\n\n        const addPolygonState$ = stateUpdates$.pipe(\n            filter((state): state is AddState => state.value === StateType.AddPolygon),\n        )\n\n        const draw$ = stateUpdates$.pipe(\n            tap(state => {\n                pencil.resetStyles(ctx)\n\n                // Clear the canvas\n                ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n                // Draw existing polygons in state\n                state.polygons.forEach(polygon => {\n                    pencil.polygon(polygon)\n                    pencil.resetStyles(ctx)\n                })\n\n                // Draw potential new polygon\n                if (state.value === StateType.AddPolygon) {\n                    if (state.newPolygon.length > 1) {\n                        pencil.polygon([...state.newPolygon, state.mousePosition])\n                        pencil.resetStyles(ctx)\n                    } else if (state.newPolygon.length === 1) {\n                        pencil.line([...state.newPolygon, state.mousePosition])\n                        pencil.resetStyles(ctx)\n                    }\n                }\n            }),\n        )\n\n        const subscription = merge(\n            reduceActions$,\n            updateStateWithMousePosition$,\n            // logStateChange$,\n            makeAddPolygonProgram(onMouseClick$, addPolygonState$, dispatch).pipe(repeat()),\n            draw$,\n        ).subscribe()\n\n        return {\n            getState: () => state,\n            getHistory: () => history,\n            subscribe: (cb: () => void) => {\n                stateUpdates$.subscribe(cb)\n            },\n            done: () => {\n                subscription.unsubscribe()\n                stateUpdates$.complete()\n            },\n            api: {\n                addPolygon: () => dispatch(addPolygon()),\n            },\n        }\n    }\n\n    throw new Error('Canvas 2D Rendering Context Not Available')\n}\n","import React from 'react'\nimport { Map as ReactLeafletMap, Popup, TileLayer, useLeaflet, Pane, Circle } from 'react-leaflet'\n\nimport '../../leaflet/leaflet.css'\nimport { canvas } from 'leaflet'\n\nimport { withCanvas } from '../../modules/core'\n\nconst position: [number, number] = [51.9085, 5.0509] // [51.505, -0.09]\nconst position2: [number, number] = [51.885, 5.0509] // [51.505, -0.09]\n\nconst Map: React.FC = (props: { children?: React.ReactNode }) => (\n    <ReactLeafletMap center={position} zoom={13}>\n        <TileLayer\n            url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n            attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n        />\n        <Circle center={position2} radius={1000}>\n            <Popup>\n                A pretty CSS3 popup.\n                <br />\n                Easily customizable.\n            </Popup>\n        </Circle>\n        <Pane name=\"canvas\">\n            {props.children}\n            <div>xyt</div>\n        </Pane>\n    </ReactLeafletMap>\n)\n\nconst createCanvasLayer = (pane?: string) => canvas({ padding: 0, pane })\n\n// type CanvasLayer = undefined | ReturnType<typeof createCanvasLayer>\n\n/* const toLngLat = (map: LeafletMap) => ([x, y]: number[]): number[] => {\n    const point = map.containerPointToLatLng([x, y])\n    return [point.lng, point.lat]\n}\n\nconst fromLngLat = (map: LeafletMap) => ([lng, lat]: number[]): number[] => {\n    const point = map.latLngToContainerPoint([lat, lng])\n    return [point.x, point.y]\n}\n */\nconst Canvas = () => {\n    const context = useLeaflet()\n\n    React.useEffect(() => {\n        if (context.map != null) {\n            const map = context.map\n            const canvasLayer = createCanvasLayer(context.pane)\n            // const mouseCanvasLayer = createCanvasLayer(context.pane)\n            canvasLayer.addTo(context.map)\n            // mouseCanvasLayer.addTo(context.map)\n            // const layer = circle(position, { renderer: canvasLayer, radius: 1000 })\n            // layer.addTo(context.map)\n\n            Object.assign(window, { canvasLayer })\n\n            const elCanvas: HTMLCanvasElement = (canvasLayer as any)._container\n            // const elMouseCanvasLayer: HTMLCanvasElement = (mouseCanvasLayer as any)._container\n\n            const api = withCanvas(elCanvas)\n            const onZoomOrMove = () => {}\n\n            map.dragging.disable()\n            Object.assign(window, { api })\n\n            map.addEventListener('zoom move', onZoomOrMove)\n\n            return () => {\n                map.removeEventListener('zoom move', onZoomOrMove)\n                map.removeLayer(canvasLayer)\n                // map.removeLayer(mouseCanvasLayer)\n                api.done()\n            }\n        }\n    }, [\n        context.map,\n        context.map && context.map.getCenter().lat,\n        context.map && context.map.getCenter().lng,\n    ])\n\n    return null\n}\n\nexport default () => {\n    return (\n        <Map>\n            <Canvas />\n        </Map>\n    )\n}\n","import React from 'react'\nimport logo from './logo.svg'\nimport './App.css'\n\nimport Map from './apps/map'\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\" />\n            </header>\n            <div id=\"map\">\n                <Map />\n            </div>\n        </div>\n    )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}