{"version":3,"sources":["modules/core/types.ts","modules/leaflet/src/utils.ts","modules/core/utils/assert.ts","modules/core/utils/array.ts","modules/core/utils/tuple.ts","modules/core/utils/function.ts","modules/core/utils/transform.ts","modules/core/observables.ts","modules/core/add/events.ts","modules/core/utils/console.ts","modules/core/rbush.ts","modules/core/pencils/marker.ts","modules/core/pencils/polygon.ts","modules/core/pencils/line.ts","modules/core/pencils/resetStyles.ts","modules/core/pencils/cursor.ts","modules/core/pencils/eraser.ts","modules/core/pencils/index.ts","modules/core/selectors.ts","modules/core/add/observables.ts","modules/core/add/pencil.ts","modules/core/legacy/utils.ts","modules/core/index.ts","modules/geojson/index.ts","apps/map/index.tsx","modules/leaflet/src/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["ShapeTypes","StateType","EventTypes","SnapType","translateOffsetOfCanvas","canvas","x","y","style","transform","match","map","str","filter","n","isNaN","tx","toLngLat","lng","lat","point","layerPointToLatLng","fromLngLat","latLngToLayerPoint","createCanvasLayer","pane","padding","isInBBox","bbox","minX","minY","maxX","maxY","isPolygonShape","shape","type","Polygon","isPointShape","Point","isLineShape","Line","emptyArray","tuple","a","b","first","second","memoize","f","previousA","previousB","value","Array","isArray","length","polygon2bbox","polygon","reduce","acc","Infinity","inRing","ring","ignoreBoundary","isInside","slice","i","j","xi","yi","xj","yj","k","AddEventTypes","mapMouseEventToOffset","evt","offsetX","offsetY","make","log","$","pipe","tap","stream","call","console","warn","RBush","error","info","RbushClass","polygonToItem","index","Object","assign","insertPolygons","tree","state","polygons","items","count","load","searchByBoundingBox","boundingBox","search","searchByPoint","item","options","insidePoly","inHole","booleanPointInPolygon","window","insert","searchPoint","replace","clear","initialPolygons","ctx","context","beginPath","arc","Math","PI","fillStyle","fill","stroke","closePath","colors","marker","forEach","hx","hy","t","moveTo","lineTo","meta","id","hovering","strokeStyle","lineWidth","lineJoin","line","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","data","getContext","save","setTransform","clearRect","width","height","restore","createPencil","api","finalMarker","defaultMarker","finalPolygon","defaultPolygon","finalLine","defaultLine","cursor","defaultCursor","resetStyles","defaultResetStyles","eraser","mapFirst","mapObservableToPropType","prop","obj","makeFromEventType","eventTypes$","eventType","dispatchedEventType","keyPress$","fromEvent","document","keyPressCode$","keyCode","ofKeyCode","pressedKeyCode","includes","enterKey$","cancelKey$","undoKey$","ctrlKey","mapTo","redoKey$","filterPolygonShapes","shapes","filterLineShapes","filterPointShapes","convertPointShapesToListOfPoints","pointShapes","pointShape","convertLineShapesToListOfPoints","lineShapes","flatMap","lineShape","convertPolygonShapesToListOfPoints","polygonShapes","polygonShape","flat","convertPolygonShapesToListOfLines","next","xs","reverse","last","p","push","convertShapesToListOfPoints","convertShapesToListOfLines","convertListOfLinesToLineString","lineDb","turfMultiLineString","x1","y1","addPolygon","AddPolygon","pencil","from","shapes$","mouseMove$","mouseClick$","dispatchEvent","fromEventType","mouseCtx","addPencil","mousePosition","undefined","click$","move$","allNewPoints$","merge","scan","event","currentPoints","redoPoints","clone","splice","initial","tail","pressedEnter$","SubmitNewPolygon","pressedCancel$","CancelNewPolygon","dispatchSubmitOrCancelOnKeyPress$","ignoreElements","submit$","withLatestFrom","cancel$","submitOrCancel$","race","take","takeWhile","mergeMap","points","of","payload","findLineSnapPosition","lines","distance","find","poly","x2","y2","xx","yy","C","D","lenSq","param","dx","dy","sqrt","pointToLineDistance","xy","dxy","subscribe","convert","mouseCanvas","config","mousePencil","toPoint","to","pointsDb$","BehaviorSubject","KDBush","polyDb$","createPolyBush","lineDb$","events$","Subject","asObservable","dispatch","mapPointToSnapFn$","combineLatest","startWith","pointsDb","pointSnap","within","lineSnap","multiLineString","maybePoint","nearestPointOnLine","geometry","coordinates","sx","sy","None","shareReplay","updatePointsDb$","polyDb","mouseClickOffset$","e","mapOffset","mouseMoveOffset$","translatedMousemMove$","mousePositionSnapped$","px","py","mapPointToSnap","hoverIndex$","some","add$","makeAddPolygonProgram","snap","draw$","hoverIndices","clear$","addShortCutKey$","noop$","core$","switchMap","concat","plop$","share","done","add","Error","rand","floor","random","ring2points","polygon2shape","multiPolygon2shapes","multiPolygon","feature2shapes","feature","geometry2shapes","featureCollection","features","featureCollection2shapes","isMultiPolygon","geometries2shapes","geometries","geometries$","plop","core","getValue","refresh","Canvas","useLeaflet","React","useState","geojson","useEffect","createPane","canvasLayer","mouseCanvasLayer","addTo","elCanvas","_container","elMouseCanvasLayer","translateOffset","plopGeoJSON","addEventListener","unsubscribe","removeEventListener","removeLayer","plopLeaflet","tileLayer","TileLayer","url","attribution","position","Map","center","zoom","Pane","name","App","className","onClick","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cbc0ff88.chunk.js","sourcesContent":["import { AddState } from './add/types'\n\n/** Type alias for pixels */\nexport type Pixel = number\n\n/** Type alias for x- and y coordinates */\nexport type Coordinate = number\n\n/**\n * An (x, y) coordiante. The first 2 number represent the pixel\n * cordiantes while the optional second set of numbers are the\n * origina coordiantes. For example longitude and lattitude values.\n *\n * The system preservers the original coordiantes to prevent having\n * to convert them back and forth if they aren't changed.\n */\nexport type Point = [Pixel, Pixel, Coordinate, Coordinate]\n\n/**\n * A list of 2- or more [[Point]]s\n *\n * I would've preferred to tyep it [Point, Point, ...Point[]]\n */\nexport type Line = Point[]\n\n/**\n * A list of list of points where the first element in the list\n * is clockwise and the rest of the list counter clockwise\n * representing holes.\n *\n * I would've preferred to type it: [Point, Point, Point, ...Point[]][]\n * since each ring should have at least 3 points.\n */\nexport type Polygon = Line[]\n\nexport enum ShapeTypes {\n    Point = 'Point',\n    Polygon = 'Polygon',\n    Line = 'Line',\n}\n\nexport type PointShape<T> = {\n    type: ShapeTypes.Point\n    shape: Point\n    meta: T\n}\n\nexport type PolygonShape<T> = {\n    type: ShapeTypes.Polygon\n    shape: Polygon\n    meta: T\n}\n\nexport type LineShape<T> = {\n    type: ShapeTypes.Line\n    shape: Line\n    meta: T\n}\n\nexport type Shape<T> = PointShape<T> | PolygonShape<T> | LineShape<T>\n\nexport enum StateType {\n    Noop = 'Noop',\n    AddPolygon = 'AddPolygon',\n}\n\n// State\nexport interface NoopState {\n    readonly value: StateType.Noop\n}\n\nexport type PossibleStates = NoopState | AddState\nexport type State<T> = PossibleStates\n\n// Actions\nexport enum EventTypes {\n    SelectPolygon = 'SelectPolygon',\n    EditPolygon = 'EditPolygon',\n    RemovePolygon = 'RemovePolygon',\n}\n\nexport type FromPoint = (coordinate: number[]) => Point\nexport type ToPoint = (coordinate: Point | [number, number]) => number[]\nexport type ConvertPoint = { from: FromPoint; to: ToPoint }\n\nexport enum SnapType {\n    Point = 'P',\n    Line = 'L',\n    None = 'M',\n}\n\nexport type SnapPoint = { type: SnapType.Point; point: Point }\nexport type SnapLine = { type: SnapType.Line; point: Point; line: [Point, Point]; distance: number }\nexport type SnapNone = { type: SnapType.None; point: Point }\nexport type Snap = SnapPoint | SnapLine | SnapNone\n","import { Map, canvas } from 'leaflet'\n\nimport { Point } from '../../core/types'\n\n/**\n * ```hs\n * translateOffsetOfCanvas :: HTMLCanvasElement -> (number, number) -> (number, number)\n * ```\n * @param canvas The canvas to adjust the coordinate of\n * @returns Coordinates of a canvas adjusted in relation to it's transformation.\n */\nexport const translateOffsetOfCanvas = (canvas: HTMLCanvasElement) => ([x, y]: [number, number]): [\n    number,\n    number,\n] => {\n    const [tx = 0, ty = 0] = (\n        canvas.style.transform.match(/translate3d\\((-?\\d+)px[, ]+(-?\\d+)px[, ]+(-?\\d+)/) || []\n    )\n        .map(str => +str)\n        .filter(n => !isNaN(n))\n\n    return [x + tx, y + ty] as [number, number]\n}\n\n/**\n * toLngLat :: L.Map -> Point -> (numbr, number)\n * @param canvas\n */\nexport const toLngLat = (map: Map) => ([x, y, lng, lat]: Point | [number, number]): [\n    number,\n    number,\n] => {\n    const point = map.layerPointToLatLng([x, y])\n    return [lng || point.lng, lat || point.lat]\n}\n\n/**\n * fromLngLat :: L.Map -> (number, number) -> Point\n * @param canvas\n */\nexport const fromLngLat = (map: Map) => ([lng, lat]: number[]): Point => {\n    const point = map.latLngToLayerPoint([lat, lng + 0])\n    return [point.x, point.y, lng, lat]\n}\n\n/**\n * createCanvasLayer :: String -> L.Canvas\n * @param canvas\n */\nexport const createCanvasLayer = (pane?: string) => canvas({ padding: 0, pane })\n","import { Point, ShapeTypes, Shape, PointShape, PolygonShape, LineShape, Line } from '../types'\n\nexport const hasProp = <K extends string>(prop: K) => <U, T extends { [P in K]: U }>(obj: T) =>\n    obj[prop]\n\ntype BBox = {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n}\n\nexport const isInBBox = (point: Point, bbox: BBox) =>\n    bbox.minX <= point[0] && bbox.minY <= point[1] && bbox.maxX >= point[0] && bbox.maxY >= point[1]\n\n/** Asserts if the given shape is of type [[PolygonShape]] */\nexport const isPolygonShape = <T>(shape: Shape<T>): shape is PolygonShape<T> =>\n    shape.type === ShapeTypes.Polygon\n\n/** Asserts if the given shape is of type [[PointShape]] */\nexport const isPointShape = <T>(shape: Shape<T>): shape is PointShape<T> =>\n    shape.type === ShapeTypes.Point\n\n/** Asserts if the given shape is of type [[LineShape]] */\nexport const isLineShape = <T>(shape: Shape<T>): shape is LineShape<T> =>\n    shape.type === ShapeTypes.Line\n\nexport const isEqual = <A, B extends A>(value: A) => (compare: B) => value === compare\n\nexport const isNotOfTypeNbr = <T>(value: number | T): value is T => typeof value !== 'number'\n\nexport const isPolygon = (points?: Point[]): points is Line => points != null && points.length > 2\n","export const emptyArray: any[] = []\n\n/** Return everything but the last element in an array. */\nexport const initial = <T>(xs: T[]) => {\n    const clone = [...xs]\n    clone.splice(xs.length - 1, 1)\n    return clone\n}\n\n/** Return everything but the first element in array. */\nexport const tail = <T>(xs: T[]) => {\n    const [_, ...t] = xs\n    return t\n}\n\n/** Retrun the first element in an array. */\nexport const head = <T>(xs: T[]) => {\n    const [h] = xs\n    return h\n}\n\n/** Time */\nexport const last = <T>(xs: T[]) => {\n    const [l] = [...xs].reverse()\n    return l\n}\n\nexport const returnEmptyArray = <T>(value: T): T =>\n    Array.isArray(value) && value.length <= 0 ? (emptyArray as any) : value\n","/** Converts value a and b into a tuple */\nexport const tuple = <A, B>(a: A, b: B): [A, B] => [a, b]\n\n/** Returns the first element of a tuple */\nexport const first = <A>([a]: [A, any]): A => a\n\n/** Returns the second element of a tuple */\nexport const second = <B>([, b]: [any, B]): B => b\n\n/** Flipts the tuple */\nexport const flipTuple = <A, B>([a, b]: [A, B]) => tuple(b, a)\n","import { returnEmptyArray } from './array'\n\nexport const memoize = <A, B>(f: (a: A) => B) => {\n    let previousA: A | undefined\n    let previousB: B | undefined\n\n    return (a: A): B => {\n        if (a !== previousA) {\n            previousA = a\n            previousB = f(a)\n        }\n\n        return returnEmptyArray(previousB as B)\n    }\n}\n\n/**\n * ```hs\n * compose :: (b -> c) -> (a -> b) -> c\n * ```\n * Read as \"f\" after \"g\"\n * @typeparam A The first function argument taken.\n * @typeparam B The result type of function `g` and argument for function `f`\n * @typeparam C The result type of function `f`\n * @params f The function to pass the result of function `g` to\n * @params g Function that computes the first result `B`\n * @returns A function that takes `A` and returns `C` by applying output of `g` to `f`\n *\n * Function composition. f after g. g andThen f\n */\nexport const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (a: A) => f(g(a))\n\n/**\n * ```hs\n * flip :: (a -> b -> c) -> (b -> a -> c)\n * ```\n * @param f\n */\nexport const flip = <A, B, C>(f: (a: A, b: B) => C) => (b: B, a: A) => f(a, b)\n\n/**\n * TODO\n * @param f\n */\nexport const curry = <A, B, C>(f: (a: A, b: B) => C) => (a: A) => (b: B) => f(a, b)\n","import { Polygon, Point, Line } from '../types'\nimport { isInBBox } from './assert'\n\nexport const polygon2bbox = (polygon: Polygon) =>\n    polygon[0].reduce(\n        (acc, [x, y]) => {\n            if (x < acc.minX) acc.minX = x\n            if (y < acc.minY) acc.minY = y\n            if (acc.maxX === Infinity || x > acc.maxX) acc.maxX = x\n            if (acc.maxY === Infinity || y > acc.maxY) acc.maxY = y\n            return acc\n        },\n        {\n            minX: Infinity,\n            minY: Infinity,\n            maxX: Infinity,\n            maxY: Infinity,\n        },\n    )\n\n/**\n *\n */\nexport function booleanPointInPolygon(\n    point: Point,\n    polygon: Polygon,\n    options: {\n        ignoreBoundary?: boolean\n    } = {},\n) {\n    const bbox = polygon2bbox(polygon)\n\n    // Quick elimination if point is not inside bbox\n    if (isInBBox(point, bbox) === false) {\n        return false\n    }\n\n    let insidePoly = false\n\n    if (inRing(point, polygon[0], options.ignoreBoundary)) {\n        let inHole = false\n        let k = 1\n        // check for the point in any of the holes\n        while (k < polygon.length && !inHole) {\n            if (inRing(point, polygon[k], !options.ignoreBoundary)) {\n                inHole = true\n            }\n            k++\n        }\n        if (!inHole) {\n            insidePoly = true\n        }\n    }\n\n    return insidePoly\n}\n\nfunction inRing(point: Point, ring: Line, ignoreBoundary?: boolean) {\n    let isInside = false\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1)\n    }\n\n    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        const xi = ring[i][0]\n        const yi = ring[i][1]\n        const xj = ring[j][0]\n        const yj = ring[j][1]\n        const onBoundary =\n            point[1] * (xi - xj) + yi * (xj - point[0]) + yj * (point[0] - xi) === 0 &&\n            (xi - point[0]) * (xj - point[0]) <= 0 &&\n            (yi - point[1]) * (yj - point[1]) <= 0\n        if (onBoundary) {\n            return !ignoreBoundary\n        }\n        const intersect =\n            yi > point[1] !== yj > point[1] &&\n            point[0] < ((xj - xi) * (point[1] - yi)) / (yj - yi) + xi\n        if (intersect) {\n            isInside = !isInside\n        }\n    }\n\n    return isInside\n}\n\nexport const mapMouseEventToOffset = (evt: MouseEvent): [number, number] => [\n    evt.offsetX,\n    evt.offsetY,\n]\n\nexport const mapProp = <K extends string>(prop: K) => <T extends { [P in K]: T[K] }>(obj: T) =>\n    obj[prop]\n","import { fromEvent, Observable } from 'rxjs'\nimport { map, filter, mapTo } from 'rxjs/operators'\n\nimport { Event, EventType } from './events'\n\nimport { mapProp, first } from './utils'\n\nexport const mapFirst = map(first)\n\n/**\n *\n */\nexport const mapObservableToProp = <K extends string>(k: K) => <T extends { [P in K]: T[K] }>(\n    $: Observable<T>,\n): Observable<T[K]> => $.pipe(map(mapProp(k)))\n\nexport const mapObservableToPropType = mapObservableToProp('type')\n\ntype EventTypes = Event['type']\n/**\n *\n */\nexport const makeFromEventType = <E extends EventTypes>(eventTypes$: Observable<E>) => <\n    T extends E\n>(\n    eventType: T,\n) =>\n    eventTypes$.pipe(\n        filter(\n            (dispatchedEventType): dispatchedEventType is T => eventType === dispatchedEventType,\n        ),\n    )\n\n/**\n *\n */\nexport const keyPress$ = fromEvent<KeyboardEvent>(document, 'keypress')\n/**\n *\n */\nexport const keyPressCode$ = keyPress$.pipe(map(evt => evt.keyCode))\n\n/**\n *\n */\nexport const ofKeyCode = (keyCode: number | number[]) =>\n    keyPressCode$.pipe(\n        filter(pressedKeyCode =>\n            Array.isArray(keyCode) ? keyCode.includes(pressedKeyCode) : pressedKeyCode === keyCode,\n        ),\n    )\n\n/**\n *\n */\nexport const enterKey$ = ofKeyCode(13)\n\n/**\n *\n */\nexport const cancelKey$ = ofKeyCode(99)\n\nexport const undoKey$ = keyPress$\n    .pipe(filter(evt => evt.ctrlKey && [122, 90, 26].includes(evt.keyCode)))\n    .pipe(mapTo('undo' as const))\n\nexport const redoKey$ = keyPress$\n    .pipe(filter(evt => evt.ctrlKey && [121, 89, 25].includes(evt.keyCode)))\n    .pipe(mapTo('redo' as const))\n","import { Point, Polygon } from '../types'\n\n/**\n * Event type descriptors for the \"Add Polygon\" process\n */\nexport enum AddEventTypes {\n    AddPolygon = 'AddPolygon',\n    SubmitNewPolygon = 'SubmitNewPolygon',\n    CancelNewPolygon = 'CancelNewPolygon',\n}\n\n/**\n * Event dispatched when the user wants to add a new polygon.\n */\nexport type AddPolygonEvent = {\n    type: AddEventTypes.AddPolygon\n}\n\n/**\n * Event dispatched when the user has finished creating a new polygon.\n */\nexport type SubmitNewPolygonEvent = {\n    type: AddEventTypes.SubmitNewPolygon\n}\n\n/**\n * Event dispatched when the user wants to cancel creating a new polygon.\n */\nexport type CancelNewPolygonEvent = {\n    type: AddEventTypes.CancelNewPolygon\n}\n\n/**\n * All possible events for the \"Add poloygon\" process\n */\nexport type AddEvent = AddPolygonEvent | SubmitNewPolygonEvent | CancelNewPolygonEvent\n\n/**\n * Event creator instructing the program the user wants to create a new polygon.\n */\nexport const addPolygon = (): AddPolygonEvent => ({ type: AddEventTypes.AddPolygon })\n\n/**\n * Event creator instructing the program the user has finished creating a new polygon.\n */\nexport const submitNewPolygon = (): SubmitNewPolygonEvent => ({\n    type: AddEventTypes.SubmitNewPolygon,\n})\n\n/**\n * Event creator instructing the program the user wants to cancel creating a new polygon.\n */\nexport const cancelNewPolygon = (): CancelNewPolygonEvent => ({\n    type: AddEventTypes.CancelNewPolygon,\n})\n","import { Observable } from 'rxjs'\nimport { tap } from 'rxjs/operators'\n\nconst make = (log: (...args: any[]) => void) => <T>($: Observable<T>) =>\n    $.pipe(\n        tap(stream => {\n            log.call(console, stream)\n        }),\n    )\n\nexport const warn = make(console.warn)\nexport const error = make(console.error)\nexport const log = make(console.log)\nexport const info = make(console.info)\n","import * as _ from 'lodash'\n\n// @ts-ignore\nimport RbushClass from 'rbush/index'\n\nimport { Polygon, Point } from './types'\n\nimport { polygon2bbox, booleanPointInPolygon } from './utils'\n\ntype RBush<T = {}> = new (...args: any) => rbush.RBush<T>\n\nconst RBush: RBush = RbushClass\n\nconst polygonToItem = (polygon: Polygon, index: number) =>\n    Object.assign(polygon2bbox(polygon), { polygon, index })\n\ntype Item = ReturnType<typeof polygonToItem>\ntype Tree = rbush.RBush<Item>\n\nconst insertPolygons = (tree: Tree, state: { count: number }) => (polygons: Polygon[]) => {\n    const items = polygons.map((polygon, index) => {\n        return polygonToItem(polygon, index + state.count + 1)\n    })\n    state.count += polygons.length\n    tree.load(items)\n}\n\nconst insertPolgyon = (tree: rbush.RBush<Item>, state: { count: number }) => (polygon: Polygon) => {\n    state.count += 1\n    tree.insert(polygonToItem(polygon, state.count))\n}\n\nconst searchByBoundingBox = (tree: Tree) => (boundingBox: rbush.BBox) => tree.search(boundingBox) // .map(item => item.polygon)\n\nconst searchByPoint = (tree: Tree) => {\n    const search = searchByBoundingBox(tree)\n\n    return ([x, y, a, b]: Point) => {\n        const items = search({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y,\n        })\n\n        return items.filter(item => booleanPointInPolygon([x, y, a, b], item.polygon))\n    }\n}\n\nexport default (...initialPolygons: Polygon[]) => {\n    const tree: rbush.RBush<Item> = new RBush() as any\n    Object.assign(window, { tree })\n    const state = { count: -1 }\n\n    const insert = insertPolygons(tree, state)\n    const search = searchByBoundingBox(tree)\n    const searchPoint = searchByPoint(tree)\n\n    const replace = (polygons: Polygon[]) => {\n        state.count = -1\n        tree.clear()\n        insert(polygons)\n    }\n    insert(initialPolygons)\n\n    return {\n        insert,\n        search,\n        searchPoint,\n        replace,\n    }\n}\n","import { PointShape } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (point: PointShape<any>, context = ctx) => {\n    context.beginPath()\n    context.arc(point.shape[0], point.shape[1], 5, 0, 2 * Math.PI)\n    context.fillStyle = '#fff'\n    context.fill()\n    context.stroke()\n    context.closePath()\n}\n","import { PointShape, PolygonShape, ShapeTypes } from '../types'\n\nconst colors = [\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n    (n = 1) => `rgba(255,0,0,${n})`,\n    (n = 1) => `rgba(0,255,0,${n})`,\n    (n = 1) => `rgba(0,0,255,${n})`,\n    (n = 1) => `rgba(255,255,0,${n})`,\n    (n = 1) => `rgba(0,255,255,${n})`,\n    (n = 1) => `rgba(255,0,255,${n})`,\n    (n = 1) => `rgba(255,127,80,${n})`,\n    (n = 1) => `rgba(255,20,147,${n})`,\n]\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default <T extends { hovering: boolean }>(\n    marker: (point: PointShape<T>, ctx?: CanvasRenderingContext2D) => void,\n) => (ctx: CanvasRenderingContext2D) => (polygon: PolygonShape<T>, context = ctx) => {\n    //\n    context.beginPath()\n\n    polygon.shape.forEach(ring => {\n        const [[hx, hy], ...t] = ring\n\n        context.moveTo(hx, hy)\n\n        t.forEach(([x, y]) => {\n            context.lineTo(x, y)\n        })\n        context.closePath()\n    })\n\n    context.fillStyle =\n        // @ts-ignore\n        (colors[polygon.meta.id] && colors[polygon.meta.id](polygon.meta.hovering ? 1 : 0.5)) ||\n        `rgba(255, 255, 255, ${polygon.meta.hovering ? 1 : 0.5})`\n    context.strokeStyle =\n        // @ts-ignore\n        (colors[polygon.meta.id] && colors[polygon.meta.id](1)) || `rgba(255, 255, 255, 1)`\n\n    context.lineWidth = 1\n    context.lineJoin = 'round'\n\n    context.fill()\n\n    context.stroke()\n\n    // polygon.shape.forEach(ring =>\n    //     ring.forEach(point =>\n    //         marker({ shape: point, meta: polygon.meta, type: ShapeTypes.Point }, context),\n    //     ),\n    // )\n}\n","import { PointShape, LineShape, ShapeTypes } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (marker: (point: PointShape<any>, ctx?: CanvasRenderingContext2D) => void) => (\n    ctx: CanvasRenderingContext2D,\n) => (line: LineShape<any>, context = ctx) => {\n    context.beginPath()\n\n    const [[hx, hy], ...t] = line.shape\n\n    context.moveTo(hx, hy)\n\n    t.forEach(([x, y]) => {\n        context.lineTo(x, y)\n    })\n\n    context.stroke()\n\n    line.shape.forEach(point =>\n        marker({ type: ShapeTypes.Point, shape: point, meta: line.meta }, context),\n    )\n}\n","export default (ctx: CanvasRenderingContext2D) => () => {\n    ctx.fillStyle = '#ffffff'\n    ctx.strokeStyle = '#000000'\n    ctx.lineWidth = 1\n    ctx.shadowBlur = 0\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'\n}\n","import { Point } from '../types'\n\n/**\n * Draw the position of the mouse as circle on canvas\n */\nexport default (ctx: CanvasRenderingContext2D) => (data: {\n    type: 'P' | 'M' | 'L'\n    point: Point\n}) => {\n    const [x, y] = data.point\n    ctx.fillStyle = 'transparent'\n    ctx.lineWidth = 1\n\n    ctx.beginPath()\n    ctx.arc(x, y, 1, 0, 2 * Math.PI)\n    ctx.stroke()\n    ctx.fill()\n    ctx.closePath()\n\n    ctx.lineWidth = 2\n    ctx.strokeStyle =\n        // if\n        data.type === 'P'\n            ? // then\n              'Yellow'\n            : // else if\n            data.type === 'L'\n            ? // then\n              'Cyan'\n            : // else\n              'Black'\n\n    ctx.beginPath()\n    ctx.arc(x, y, 15, 0, 2 * Math.PI)\n    ctx.stroke()\n    ctx.fill()\n    ctx.closePath()\n}\n","export default (canvas: HTMLCanvasElement) => () => {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx) {\n        ctx.save()\n\n        // Use the identity matrix while clearing the canvas\n        ctx.setTransform(1, 0, 0, 1, 0, 0)\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n        ctx.restore()\n    }\n}\n","import defaultMarker from './marker'\nimport defaultPolygon from './polygon'\nimport defaultLine from './line'\nimport defaultResetStyles from './resetStyles'\nimport defaultCursor from './cursor'\nimport eraser from './eraser'\n\ninterface Api {\n    marker: typeof defaultMarker\n    polygon: typeof defaultPolygon\n    line: typeof defaultLine\n    cursor: typeof defaultCursor\n    resetStyles: typeof defaultResetStyles\n}\n\nexport const createPencil = (api: Partial<Api> = {}) => (canvas: HTMLCanvasElement) => {\n    const ctx = canvas.getContext('2d')\n\n    if (ctx) {\n        const finalMarker = (api.marker || defaultMarker)(ctx)\n        const finalPolygon = (api.polygon || defaultPolygon)(finalMarker)(ctx)\n        const finalLine = (api.line || defaultLine)(finalMarker)(ctx)\n        const cursor = (api.cursor || defaultCursor)(ctx)\n        const resetStyles = (api.resetStyles || defaultResetStyles)(ctx)\n\n        return {\n            marker: finalMarker,\n            polygon: finalPolygon,\n            line: finalLine,\n            resetStyles,\n            cursor,\n            eraser: eraser(canvas),\n            api: {\n                marker: defaultMarker,\n                polygon: defaultPolygon(finalMarker),\n                line: defaultLine(finalMarker),\n                resetStyles: defaultResetStyles,\n                cursor: defaultCursor,\n                eraser,\n            },\n        }\n    }\n\n    throw '1'\n}\n\nexport type Pencil = ReturnType<ReturnType<typeof createPencil>>\n\nexport default createPencil\n","import { State, Point, Shape, StateType, PointShape, LineShape, PolygonShape } from './types'\nimport { memoize, isPolygonShape, isPointShape, isLineShape, emptyArray, last } from './utils'\nimport { multiLineString as turfMultiLineString } from '@turf/helpers'\n\n/**\n * From `[Polygon, T] -> [Polygon]\n */\nexport const filterPolygonShapes = memoize(<T>(shapes: Shape<T>[]): PolygonShape<T>[] =>\n    shapes.filter(isPolygonShape),\n)\n\n/** TODO */\nexport const filterLineShapes = memoize(<T>(shapes: Shape<T>[]): LineShape<T>[] =>\n    shapes.filter(isLineShape),\n)\n\n/** TODO */\nexport const filterPointShapes = memoize(<T>(shapes: Shape<T>[]): PointShape<T>[] =>\n    shapes.filter(isPointShape),\n)\n\n/**\n * Redduces a list of [[PointShape]] into a list of points\n */\nexport const convertPointShapesToListOfPoints = memoize(<T>(pointShapes: PointShape<T>[]) =>\n    pointShapes.map(pointShape => pointShape.shape),\n)\nexport const convertLineShapesToListOfPoints = memoize(<T>(lineShapes: LineShape<T>[]) =>\n    lineShapes.flatMap(lineShape => lineShape.shape),\n)\nexport const convertPolygonShapesToListOfPoints = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape => polygonShape.shape.flat()),\n)\nexport const convertPolygonShapesToListOfLines = memoize(<T>(polygonShapes: PolygonShape<T>[]) =>\n    polygonShapes.flatMap(polygonShape =>\n        polygonShape.shape.flatMap(ring => {\n            const [a, b, ...c] = ring\n            return c.reduce(\n                (acc, next) => {\n                    if (acc.length > 0) {\n                        const [, p] = last(acc)\n                        acc.push([p, next])\n                    }\n                    return acc\n                },\n                [[a, b]] as [Point, Point][],\n            )\n        }),\n    ),\n)\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfPoints = memoize(<T>(shapes: Shape<T>[]): Point[] => [\n    ...convertPointShapesToListOfPoints(filterPointShapes(shapes)),\n    ...convertLineShapesToListOfPoints(filterLineShapes(shapes)),\n    ...convertPolygonShapesToListOfPoints(filterPolygonShapes(shapes)),\n])\n\n/**\n * Redduces a list of polygons into a list of points\n */\nexport const convertShapesToListOfLines = memoize(<T>(shapes: Shape<T>[]): [Point, Point][] =>\n    convertPolygonShapesToListOfLines(filterPolygonShapes(shapes)),\n)\n\nexport const convertListOfLinesToLineString = memoize((lineDb: [Point, Point][]) =>\n    turfMultiLineString(\n        lineDb.flatMap(([a, b]) => {\n            if (a.length === 4 && b.length === 4) {\n                const [, , x1, y1] = a\n                const [, , x2, y2] = b\n\n                return [[[x1, y1], [x2, y2]]]\n            }\n\n            return []\n        }),\n    ),\n)\n","import { Observable, concat, merge, of, race, combineLatest, Subject } from 'rxjs'\nimport {\n    take,\n    tap,\n    filter,\n    scan,\n    mapTo,\n    takeWhile,\n    map,\n    ignoreElements,\n    withLatestFrom,\n    last,\n    mergeMap,\n} from 'rxjs/operators'\n\nimport { cancelKey$, enterKey$, undoKey$, redoKey$ } from '../observables'\nimport { AddEventTypes, AddEvent } from './events'\nimport { Point, Snap, FromPoint, Shape } from '../types'\nimport { Event } from '../events'\nimport { initial, head, tail, first, tuple, second } from '../utils'\nimport { Pencil } from '../pencils'\n\nimport createPencil from './pencil'\nimport { create } from 'domain'\n\n/**\n * Creates a program for adding new polygons.\n */\nexport default <T>({\n    pencil,\n    from,\n    shapes$,\n    mouseMove$,\n    mouseClick$,\n    dispatchEvent,\n    fromEventType,\n    mouseCtx,\n}: {\n    pencil: Pencil\n    mouseCtx: CanvasRenderingContext2D\n    from: FromPoint\n    shapes$: Observable<Shape<T>[]>\n    mouseMove$: Observable<Snap>\n    mouseClick$: Observable<Point>\n    dispatchEvent: <E extends Event>($: Observable<E>) => Observable<Event>\n    fromEventType: <E extends AddEvent['type']>(eventType: E) => Observable<E>\n}) => {\n    const addPencil = createPencil(pencil)(mouseCtx)\n\n    const click$ = mouseClick$.pipe(\n        map(point => ({\n            type: 'click' as const,\n            point,\n        })),\n    )\n    const move$ = mouseMove$.pipe(\n        map(point => ({\n            type: 'move' as const,\n            point,\n        })),\n    )\n\n    const allNewPoints$ = merge(\n        click$,\n        move$,\n        undoKey$.pipe(map(type => ({ type }))),\n        redoKey$.pipe(map(type => ({ type }))),\n        shapes$.pipe(mapTo({ type: 'shapes' as const })),\n    ).pipe(\n        scan(\n            ([currentPoints, redoPoints], event) =>\n                // if\n                event.type === 'click'\n                    ? // then\n                      tuple([...currentPoints, event.point], [])\n                    : // else if\n                    event.type === 'undo' && currentPoints.length > 0\n                    ? // then\n                      tuple(initial(currentPoints), [\n                          currentPoints[currentPoints.length - 1],\n                          ...redoPoints,\n                      ])\n                    : // else if\n                    event.type === 'redo' && redoPoints.length > 0\n                    ? // then\n                      tuple([...currentPoints, head(redoPoints)], tail(redoPoints))\n                    : // else if\n                    event.type === 'shapes'\n                    ? // then\n                      tuple(currentPoints.map(([, , lng, lat]) => from([lng, lat])), [])\n                    : // else\n                      tuple(currentPoints, []),\n            tuple<Point[], Point[]>([], []),\n        ),\n        map(first),\n    )\n\n    const pressedEnter$ = enterKey$.pipe(\n        mapTo({ type: AddEventTypes.SubmitNewPolygon as const }),\n        dispatchEvent,\n    )\n\n    const pressedCancel$ = cancelKey$.pipe(\n        mapTo({ type: AddEventTypes.CancelNewPolygon as const }),\n        dispatchEvent,\n    )\n\n    const dispatchSubmitOrCancelOnKeyPress$ = merge(pressedCancel$, pressedEnter$).pipe(\n        ignoreElements(),\n    )\n\n    const submit$ = fromEventType(AddEventTypes.SubmitNewPolygon).pipe(\n        withLatestFrom(allNewPoints$),\n        filter(stream => second(stream).length > 2),\n        map(first),\n    )\n\n    const cancel$ = fromEventType(AddEventTypes.CancelNewPolygon)\n\n    const submitOrCancel$ = race(submit$, cancel$).pipe(take(1))\n\n    const points$ = merge(\n        dispatchSubmitOrCancelOnKeyPress$,\n        merge(submitOrCancel$, allNewPoints$),\n    ).pipe(\n        withLatestFrom(mouseMove$),\n        tap(([stream, mousePosition]) => {\n            Array.isArray(stream) && addPencil(mousePosition, stream)\n        }),\n        map(first),\n        scan(\n            (acc, next) => (Array.isArray(next) ? tuple(next, acc[1]) : tuple(acc[0], next)),\n            tuple([] as Point[], AddEventTypes.AddPolygon) as [Point[], AddEventTypes],\n        ),\n        takeWhile(([, event]) => event === AddEventTypes.AddPolygon, true),\n        last(),\n        mergeMap(([points, outcome]) =>\n            outcome === AddEventTypes.SubmitNewPolygon\n                ? of({ type: AddEventTypes.SubmitNewPolygon as const, payload: points })\n                : of(void 0).pipe(ignoreElements()),\n        ),\n    )\n\n    return points$\n}\n","import { Pencil } from '../pencils'\nimport { Point, ShapeTypes, Snap, SnapType } from '../types'\n\nexport default (pencil: Pencil) => (ctx: CanvasRenderingContext2D) => (\n    mousePosition: Snap,\n    polygon: Point[],\n) => {\n    pencil.eraser()\n\n    // Draw potential new polygon\n    // if (state.value === StateType.AddPolygon) {\n    if (polygon.length > 1) {\n        pencil.polygon({\n            type: ShapeTypes.Polygon,\n            shape: [[...polygon, mousePosition.point]],\n            // TODO Provide a way to create T for new polygons\n            meta: { id: -1, hovering: true },\n        })\n\n        pencil.resetStyles()\n    } else if (polygon.length === 1) {\n        pencil.line({\n            type: ShapeTypes.Line,\n            shape: [...polygon, mousePosition.point],\n            meta: undefined as any,\n        })\n        pencil.resetStyles()\n    }\n\n    polygon.forEach(point =>\n        pencil.marker({\n            type: ShapeTypes.Point,\n            shape: point,\n            meta: {},\n        }),\n    )\n\n    if (mousePosition.type === SnapType.Line) {\n        ctx.beginPath()\n        ctx.moveTo(mousePosition.line[0][0], mousePosition.line[0][1])\n        ctx.lineTo(mousePosition.line[1][0], mousePosition.line[1][1])\n        ctx.strokeStyle = 'Cyan'\n        ctx.stroke()\n        // ctx\n    }\n\n    pencil.cursor(mousePosition)\n}\n","import _ from 'lodash'\n\nimport {\n    AllGeoJSON,\n    Feature,\n    FeatureCollection,\n    GeoJSONObject,\n    Geometries,\n    GeometryCollection,\n    MultiPolygon,\n    Polygon,\n    Position,\n    Types as GeoJSONTypes,\n} from '@turf/helpers'\n\nimport {\n    PolyLike,\n    PositionLike,\n    QFeature,\n    QFeatureCollection,\n    QMultiPolygon,\n    QPolygon,\n    QPolyLike,\n    QPosition,\n} from './types'\nimport { Point } from '../types'\n\ntype Project = (xy: number[]) => number[]\n\ninterface Collect {\n    coordinates: QPosition[]\n    lines: [QPosition, QPosition][]\n}\n\nconst defaultCollect = (): Collect => ({ coordinates: [], lines: [] })\n\nexport const pointPixelsAreEqual = ([x1, y1]: PositionLike, [x2, y2]: PositionLike): boolean => {\n    console.log(`${x1} === ${x2} && ${y1} === ${y2}`)\n    const eq = _.isEqual([x1, y1], [x2, y2])\n    console.log('Eq: ' + eq)\n    return eq\n}\n\nexport const projectGeometry = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Polygon | MultiPolygon,\n): QPolygon | QMultiPolygon => {\n    switch (geom.type) {\n        case 'MultiPolygon':\n            return projectMultiPolygon(project)(collect)(geom)\n        case 'Polygon':\n            return projectPolygon(project)(collect)(geom)\n        default:\n            return geom\n    }\n}\n\nexport const projectGeoJSON = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: PolyLike,\n): QPolyLike => {\n    switch (geom.type) {\n        case 'FeatureCollection':\n            return projectFeatureCollection(project)(collect)(geom as any)\n        case 'Feature':\n            return projectFeature(project)(collect)(geom)\n        // case 'GeometryCollection':\n        //   return projectGeometryCollection(project)(collect)(geom)\n        default:\n            return projectGeometry(project)(collect)(geom)\n    }\n}\n\nexport const projectFeature = (project: Project) => (collect: Collect = defaultCollect()) => (\n    geom: Feature<Polygon | MultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    geometry: projectGeometry(project)(collect)(geom.geometry),\n})\n\nexport const projectFeatureCollection = (project: Project) => (\n    collect: Collect = defaultCollect(),\n) => (\n    geom: FeatureCollection<Polygon | MultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => ({\n    ...geom,\n    features: geom.features.map(projectFeature(project)(collect)),\n})\n\n// export const projectGeometryCollection = (project: Project) => (collect: Collect = defaultCollect()) => (\n//   geom: any\n// ): GeometryCollection => ({\n//   ...geom,\n//   geometries: geom.geometries.map(projectGeometry(project)(collect))\n// })\n\nexport const projectMultiPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: MultiPolygon,\n): QMultiPolygon => ({\n    ...polygon,\n    coordinates: polygon.coordinates.map(poly => poly.map(projectPositions(project)(collect))),\n})\n\nexport const projectPolygon = (project: Project) => (collect: Collect = defaultCollect()) => (\n    polygon: Polygon,\n): QPolygon => {\n    return {\n        ...polygon,\n        coordinates: polygon.coordinates.map(projectPositions(project)(collect)),\n    }\n}\n\nexport const projectPositions = (project: Project) => (collect: Collect = defaultCollect()) => (\n    coords: Position[],\n): QPosition[] =>\n    coords.map((coord, index) => {\n        const projected = project(coord)\n\n        const point: QPosition = [projected[0], projected[1], coord[0], coord[1]]\n        collect.coordinates.push(point)\n\n        if (index > 0) {\n            collect.lines.push([collect.coordinates[collect.coordinates.length - 2], point])\n\n            if (index === coords.length - 1) {\n                collect.lines.push([\n                    point,\n                    collect.coordinates[collect.coordinates.length - coords.length],\n                ])\n            }\n        }\n\n        return point\n    })\n\nexport const pointToLineDistance = ([x, y]: number[], [[x1, y1], [x2, y2]]: number[][]) => {\n    const A = x - x1\n    const B = y - y1\n    const C = x2 - x1\n    const D = y2 - y1\n\n    const dot = A * C + B * D\n    const lenSq = C * C + D * D\n    let param = -1\n    if (lenSq !== 0) {\n        // in case of 0 length line\n        param = dot / lenSq\n    }\n\n    let xx: number\n    let yy: number\n\n    if (param < 0) {\n        xx = x1\n        yy = y1\n    } else if (param > 1) {\n        xx = x2\n        yy = y2\n    } else {\n        xx = x1 + param * C\n        yy = y1 + param * D\n    }\n\n    const dx = x - xx\n    const dy = y - yy\n    return [[xx, yy], Math.sqrt(dx * dx + dy * dy)] as [number[], number]\n}\n\n/**\n *\n * @param position\n * @param lines\n */\nexport const findLineSnapPosition = (\n    [x, y, lng, lat]: [number, number, number, number],\n    lines: [[number, number, number, number], [number, number, number, number]][],\n) => {\n    let point: [number, number] | undefined\n    let distance = -1\n    let line: [[number, number, number, number], [number, number, number, number]] | undefined\n\n    lines.find((poly): boolean => {\n        const [[x1, y1, lng1, lat1], [x2, y2, lng2, lat2]] = poly\n        const [xy, dxy] = pointToLineDistance([x, y], [[x1, y1], [x2, y2]])\n\n        if (dxy <= 5) {\n            point = xy as [number, number]\n            distance = dxy\n            line = poly\n\n            return true\n        }\n\n        return false\n    })\n\n    if (distance >= 0 && point != null && line != null) {\n        return { point, distance, line }\n    }\n\n    return undefined\n}\n\nconst fromQPosition2Position = ([, , lng, lat]: QPosition): Position => [lng, lat]\n\nconst fromQPositions2Positions = (qPositions: QPosition[]): Position[] =>\n    qPositions.map(fromQPosition2Position)\n\nconst fromQPositionsSets2PositionsSets = (sets: QPosition[][]): Position[][] =>\n    sets.map(fromQPositions2Positions)\n\nconst fromQPolygon2Polygon = (qPolygon: QPolygon): Polygon => {\n    return {\n        ...qPolygon,\n        coordinates: fromQPositionsSets2PositionsSets(qPolygon.coordinates),\n    }\n}\n\nconst fromQMultiPolygon2MultiPolygon = (qMultiPolygon: QMultiPolygon): MultiPolygon => {\n    return {\n        ...qMultiPolygon,\n        coordinates: qMultiPolygon.coordinates.map(fromQPositionsSets2PositionsSets),\n    }\n}\n\nconst fromQGeometry2Geometry = (geometry: QPolygon | QMultiPolygon) => {\n    if (geometry.type === 'MultiPolygon') {\n        return fromQMultiPolygon2MultiPolygon(geometry)\n    }\n\n    return fromQPolygon2Polygon(geometry)\n}\n\nconst fromQFeature2Feature = (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): Feature<Polygon | MultiPolygon> => {\n    return {\n        ...feature,\n        geometry: fromQGeometry2Geometry(feature.geometry),\n    }\n}\n\nexport const fromQLikeToPolyLike = (qLike: QPolyLike): PolyLike => {\n    if (qLike.type === 'FeatureCollection') {\n        return {\n            ...qLike,\n            features: qLike.features.map(fromQFeature2Feature),\n        }\n    } else if (qLike.type === 'Feature') {\n        return fromQFeature2Feature(qLike)\n    }\n\n    return fromQGeometry2Geometry(qLike)\n}\n\nexport const mapGeometry = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (geometry: QPolygon | QMultiPolygon): QPolygon | QMultiPolygon => {\n    const nextGeometry = f(geometry)\n\n    if (nextGeometry !== geometry) {\n        return nextGeometry\n    }\n\n    return geometry\n}\n\nexport const mapFeature = (f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon) => (\n    feature: QFeature<QPolygon | QMultiPolygon>,\n): QFeature<QPolygon | QMultiPolygon> => {\n    const nextGeometry = f(feature.geometry)\n\n    if (nextGeometry !== feature.geometry) {\n        return {\n            ...feature,\n            geometry: nextGeometry,\n        }\n    }\n\n    return feature\n}\n\nexport const mapFeatureCollection = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (\n    featureCollection: QFeatureCollection<QPolygon | QMultiPolygon>,\n): QFeatureCollection<QPolygon | QMultiPolygon> => {\n    const nextFeatures: QFeature<QPolygon | QMultiPolygon>[] = []\n    let didChange = false\n\n    featureCollection.features.forEach(feature => {\n        const nextFeature = mapFeature(f)(feature)\n\n        if (nextFeature !== feature) {\n            didChange = true\n            nextFeatures.push(nextFeature)\n        }\n    })\n\n    if (didChange) {\n        return {\n            ...featureCollection,\n            features: nextFeatures,\n        }\n    }\n\n    return featureCollection\n}\n\nexport const mapPolyLike = (\n    f: (geometry: QPolygon | QMultiPolygon) => QPolygon | QMultiPolygon,\n) => (polyLike: QPolyLike): QPolyLike => {\n    if (polyLike.type === 'Feature') {\n        return mapFeature(f)(polyLike)\n    } else if (polyLike.type === 'FeatureCollection') {\n        return mapFeatureCollection(f)(polyLike)\n    }\n\n    return mapGeometry(f)(polyLike)\n}\n\nexport const injectLineSnapPosition = (\n    ring: QPosition[],\n    line: [QPosition, QPosition],\n    point: QPosition,\n) => {\n    let didInject = false\n\n    const nextRing = ring.reduce(\n        (acc, coord) => {\n            const previous = acc[acc.length - 1]\n\n            if (\n                didInject === false &&\n                previous &&\n                pointPixelsAreEqual(previous, line[0]) &&\n                pointPixelsAreEqual(coord, line[1])\n            ) {\n                didInject = true\n                acc.push(point, coord)\n            } else {\n                acc.push(coord)\n            }\n\n            return acc\n        },\n        [] as QPosition[],\n    )\n\n    return { didInject, ring: nextRing }\n}\n\nexport const mapMouseEventToCoords = (evt: MouseEvent): [number, number] => [\n    evt.offsetX,\n    evt.offsetY,\n]\n","import {\n    fromEvent,\n    merge,\n    Subject,\n    Observable,\n    of,\n    combineLatest,\n    observable,\n    BehaviorSubject,\n    concat,\n    race,\n    empty,\n} from 'rxjs'\nimport {\n    map,\n    tap,\n    repeat,\n    filter,\n    scan,\n    mapTo,\n    switchMap,\n    startWith,\n    switchMapTo,\n    mergeMap,\n    withLatestFrom,\n    share,\n    ignoreElements,\n    last,\n    takeUntil,\n    endWith,\n    take,\n    mergeMapTo,\n    mergeAll,\n    delay,\n    publishBehavior,\n    refCount,\n    publishReplay,\n    shareReplay,\n} from 'rxjs/operators'\n\nimport KDBush from 'kdbush'\nimport createPolyBush from './rbush'\n\n// @ts-ignore\nimport nearestPointOnLine from '@turf/nearest-point-on-line'\n\nimport { StateType, State, Point, Shape, ShapeTypes, ConvertPoint, Snap, SnapType } from './types'\nimport { mapMouseEventToOffset, second, first } from './utils'\nimport createPencil from './pencils'\nimport { Event } from './events'\nimport { mapFirst, ofKeyCode, makeFromEventType, mapObservableToPropType } from './observables'\nimport {\n    convertShapesToListOfPoints,\n    filterPolygonShapes,\n    convertPolygonShapesToListOfLines,\n    convertShapesToListOfLines,\n    convertListOfLinesToLineString,\n} from './selectors'\n\nimport { AddState } from './add/types'\nimport { addPolygon, AddEventTypes, SubmitNewPolygonEvent } from './add/events'\nimport makeAddPolygonProgram from './add/observables'\nimport { isPolygonShape, warn } from './utils'\nimport { toMulticast } from './legacy/observables'\nimport { findLineSnapPosition } from './legacy/utils'\n\nofKeyCode([120, 88]).subscribe(() => console.clear())\n\nexport default <T>(convert: ConvertPoint, shapes$: Observable<Shape<T>[]>) => (\n    canvas: HTMLCanvasElement,\n    mouseCanvas: HTMLCanvasElement,\n    config: {\n        mapOffset?: (xy: [number, number]) => [number, number]\n    } = {},\n) => {\n    const ctx = canvas.getContext('2d')\n    const mouseCtx = mouseCanvas.getContext('2d')\n    const pencil = createPencil()(canvas)\n    const mousePencil = createPencil()(mouseCanvas)\n\n    /**\n     *\n     * @param param0\n     */\n    const toPoint = ([x, y]: [number, number]): Point => {\n        const [lng, lat] = convert.to([x, y])\n        return [x, y, lng, lat]\n    }\n\n    if (mousePencil && pencil && ctx != null && mouseCtx != null) {\n        canvas.style.cursor = 'none'\n        mouseCanvas.style.cursor = 'none'\n\n        /**\n         * Final API for drawing markers, polygons, and lines.\n         */\n\n        /**\n         * K-2 tree used to store all points that are present within\n         * the system and used to find points that are near the mouse\n         * position to snap to.\n         */\n        const pointsDb$ = new BehaviorSubject(\n            // @ts-ignore\n            new KDBush([]) as KDBush.KDBush<Point>,\n        )\n\n        const polyDb$ = new BehaviorSubject(createPolyBush())\n\n        const lineDb$ = new BehaviorSubject([] as [Point, Point][])\n\n        /**\n         * Observable for emitting events\n         */\n        const events$ = new Subject<Event>()\n\n        /**\n         * Observable emits all event types that are dispatched\n         */\n        const eventTypes$ = mapObservableToPropType(events$.asObservable())\n\n        /**\n         * Creates an observable that filters events by type\n         */\n        const fromEventType = makeFromEventType(eventTypes$)\n\n        /**\n         * Dispatches events\n         */\n        const dispatch = (event: Event) => {\n            events$.next(event)\n        }\n\n        const dispatchEvent = <E extends Event>($: Observable<E>) => $.pipe(tap(dispatch))\n        /**\n         * Observable streaming current and previous state\n         */\n        // const stateUpdates$ = new Subject<[State<T>, State<T>]>()\n\n        /**\n         * Maps state changes to actual state\n         */\n        // const state$ = stateUpdates$.pipe(mapFirst)\n\n        /**\n         * Finds the nearest point a given point can snap to\n         */\n\n        const mapPointToSnapFn$ = combineLatest(\n            shapes$.pipe(startWith([])),\n            pointsDb$,\n            lineDb$,\n        ).pipe(\n            map(([shapes, pointsDb, lineDb]) => {\n                return ([x, y, lng, lat]: Point): Snap => {\n                    const pointSnap = convertShapesToListOfPoints(shapes)[\n                        pointsDb.within(x, y, 10)[0]\n                    ]\n\n                    if (pointSnap) {\n                        return { type: SnapType.Point, point: pointSnap }\n                    }\n\n                    const lineSnap = findLineSnapPosition([x, y, lng!, lat!], lineDb as any)\n\n                    if (lineSnap) {\n                        const multiLineString = convertListOfLinesToLineString(lineDb)\n                        const maybePoint = nearestPointOnLine(multiLineString, [lng, lat])\n\n                        if (maybePoint) {\n                            const [sx, sy] = convert.from(maybePoint.geometry.coordinates)\n                            return {\n                                distance: 4,\n                                line: (lineSnap.line as any) as [Point, Point],\n                                type: SnapType.Line,\n                                point: [sx, sy, ...maybePoint.geometry.coordinates] as any, // [lineSnap.point[0], lineSnap.point[1], lng, lat] as Point,\n                            }\n                        }\n                    }\n\n                    return { type: SnapType.None, point: [x, y, lng, lat] as Point }\n                }\n            }),\n            shareReplay(1),\n        )\n\n        /**\n         *\n         */\n        const updatePointsDb$ = shapes$.pipe(\n            withLatestFrom(polyDb$),\n            tap(([shapes, polyDb]) => {\n                const polygons = filterPolygonShapes(shapes).map(item => item.shape)\n                lineDb$.next(convertShapesToListOfLines(shapes))\n                polyDb.replace(polygons)\n            }),\n            mapFirst,\n            map(convertShapesToListOfPoints),\n            tap(points => {\n                pointsDb$.next(\n                    // @ts-ignore\n                    new KDBush(points),\n                )\n            }),\n        )\n\n        const mouseClick$ = fromEvent<MouseEvent>(mouseCanvas, 'click')\n        const mouseClickOffset$ = mouseClick$.pipe(map(e => mapMouseEventToOffset(e)))\n\n        const translatedMouseClick$ = config.mapOffset\n            ? mouseClickOffset$.pipe(map(config.mapOffset))\n            : mouseClickOffset$\n\n        // const snappedClick$ = translatedMouseClick$.pipe(\n        //     withLatestFrom(mapPointToSnapFn$),\n        //     map(([point, mapPointToSnap]) => mapPointToSnap(point)),\n        // )\n\n        const mouseMove$ = fromEvent<MouseEvent>(mouseCanvas, 'mousemove')\n        const mouseMoveOffset$ = mouseMove$.pipe(map(e => mapMouseEventToOffset(e)))\n        const translatedMousemMove$ = config.mapOffset\n            ? mouseMoveOffset$.pipe(map(config.mapOffset))\n            : mouseMoveOffset$.pipe()\n\n        const mousePositionSnapped$ = translatedMousemMove$.pipe(\n            map(point => {\n                const [px, py] = point\n                const [lng, lat] = convert.to(point)\n\n                return [px, py, lng, lat] as Point\n            }),\n            withLatestFrom(mapPointToSnapFn$),\n            map(([point, mapPointToSnap]) => mapPointToSnap(point)),\n            // shareReplay(1),\n            // publishBehavior({ type: 'M', point: [0, 0, 0, 0] } as Snap),\n            // refCount(),\n            // share(),\n            // shareReplay(1),\n            shareReplay(1),\n        )\n        // .pipe(shareReplay(1))\n\n        // const mousePositionSnappedPoint$ = mousePositionSnapped$.pipe(map(({ point }) => point))\n\n        const hoverIndex$ = translatedMousemMove$.pipe(\n            map(toPoint),\n            withLatestFrom(polyDb$),\n            map(([point, polyDb]) => polyDb.searchPoint(point).map(item => item.index)),\n            scan((acc, next) => [acc[1], next] as const, [[], []] as readonly [number[], number[]]),\n            filter(([a, b]) => a.length !== b.length || a.some((n, index) => n !== b[index])),\n            map(([, b]) => b),\n        )\n\n        const add$ = makeAddPolygonProgram({\n            pencil: mousePencil,\n            mouseCtx,\n            from: convert.from,\n            shapes$,\n            mouseMove$: mousePositionSnapped$,\n            mouseClick$: mouseClick$.pipe(\n                withLatestFrom(mousePositionSnapped$),\n                map(second),\n                map(snap => snap.point),\n            ),\n            dispatchEvent,\n            fromEventType,\n        })\n\n        const draw$ = combineLatest(\n            shapes$.pipe(startWith([] as Shape<T>[])),\n            hoverIndex$.pipe(startWith([] as number[])),\n        ).pipe(\n            tap(data => {\n                const [shapes, hoverIndices] = data\n\n                pencil.resetStyles()\n\n                // Clear the canvas\n                pencil.eraser()\n\n                // Draw existing polygons\n                const polygons = filterPolygonShapes(shapes)\n                polygons.forEach((shape, index) => {\n                    const hovering = hoverIndices.includes(index)\n                    pencil.polygon({ ...shape, meta: { hovering, id: shape.meta } })\n                    pencil.resetStyles()\n                })\n            }),\n        )\n\n        const clear$ = mousePositionSnapped$.pipe(\n            tap(snap => {\n                mousePencil.eraser()\n                mousePencil.cursor(snap)\n            }),\n            ignoreElements(),\n        )\n\n        const addShortCutKey$ = ofKeyCode([65, 97]).pipe(\n            mapTo({ type: AddEventTypes.AddPolygon }),\n            dispatchEvent,\n            ignoreElements(),\n        )\n\n        const noop$ = of({ type: 'Noop' as const }).pipe(\n            dispatchEvent,\n            ignoreElements(),\n        )\n\n        const core$ = merge(\n            addShortCutKey$,\n            of(void 0),\n            fromEventType('Noop'),\n            fromEventType(AddEventTypes.AddPolygon),\n        ).pipe(\n            warn,\n            switchMap(event => {\n                switch (event) {\n                    case AddEventTypes.AddPolygon: {\n                        return concat(add$, noop$)\n                    }\n                    default: {\n                        return clear$\n                    }\n                }\n            }),\n            // share(),\n        )\n\n        const plop$ = merge(\n            merge(updatePointsDb$, draw$ /* drawNewPolygon$, */).pipe(ignoreElements()),\n            core$,\n            // cursor$,\n        ).pipe(share())\n\n        // const subscription = plop$.subscribe()\n\n        return {\n            done: () => {\n                // subscription.unsubscribe()\n            },\n            subscribe: ((...args: any[]) => plop$.subscribe(...args)) as typeof plop$.subscribe,\n            api: {\n                add: () => dispatch(addPolygon()),\n            },\n        }\n    }\n\n    throw new Error('Canvas 2D Rendering Context Not Available')\n}\n","import { of, Subject, BehaviorSubject } from 'rxjs'\n\n// Plop core\nimport core from '../core'\nimport { Point, ShapeTypes, PolygonShape, Shape, ConvertPoint } from '../core/types'\n\nimport { tap, map } from 'rxjs/operators'\nimport { FeatureCollection, Feature, Polygon, MultiPolygon } from '@turf/helpers'\n\nexport type Geometry =\n    | Feature<Polygon | MultiPolygon>\n    | FeatureCollection<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon\n\nconst isPolygon = (geometry: Polygon | MultiPolygon): geometry is Polygon =>\n    geometry.type === 'Polygon'\n\nconst isMultiPolygon = (geometry: Polygon | MultiPolygon): geometry is MultiPolygon =>\n    geometry.type === 'MultiPolygon'\n\ntype From = ConvertPoint['from']\ntype Ring = Polygon['coordinates'][0]\n\nconst rand = () => Math.floor(Math.random() * 20) + 1\n\nconst ring2points = (from: From) => ([, ...ring]: Ring) => ring.map(([x, y]) => from([x, y]))\n\nconst polygon2shape = (from: From) => <G extends Polygon>(polygon: G): PolygonShape<number> => ({\n    type: ShapeTypes.Polygon,\n    shape: polygon.coordinates.map(ring2points(from)),\n    meta: rand(),\n})\n\nconst multiPolygon2shapes = (from: From) => <G extends MultiPolygon>(\n    multiPolygon: G,\n): PolygonShape<number>[] =>\n    multiPolygon.coordinates.map(polygon => ({\n        type: ShapeTypes.Polygon,\n        shape: polygon.map(ring2points(from)),\n        meta: rand(),\n    }))\n\nconst feature2shapes = (from: From) => <G extends Feature<MultiPolygon | Polygon>>(\n    feature: G,\n): PolygonShape<number>[] =>\n    isPolygon(feature.geometry)\n        ? [polygon2shape(from)(feature.geometry)]\n        : multiPolygon2shapes(from)(feature.geometry)\n\nconst featureCollection2shapes = (from: From) => <\n    G extends FeatureCollection<MultiPolygon | Polygon>\n>(\n    featureCollection: G,\n): PolygonShape<number>[] => featureCollection.features.flatMap(feature2shapes(from))\n\nconst geometry2shapes = (from: From) => (geometry: Geometry) =>\n    geometry.type === 'FeatureCollection'\n        ? featureCollection2shapes(from)(geometry)\n        : geometry.type === 'Feature'\n        ? feature2shapes(from)(geometry)\n        : isMultiPolygon(geometry)\n        ? multiPolygon2shapes(from)(geometry)\n        : [polygon2shape(from)(geometry)]\n\nexport const geometries2shapes = (from: From) => (geometries: Geometry[]) =>\n    geometries.flatMap(geometry2shapes(from))\n\nexport default (convert: ConvertPoint) => (\n    canvas: HTMLCanvasElement,\n    mouseCanvas: HTMLCanvasElement,\n    config: {\n        mapOffset?: (xy: [number, number]) => [number, number]\n    } = {},\n) => (geometries: Geometry[]) => {\n    const geometries$ = new BehaviorSubject(geometries)\n\n    const shapes$ = geometries$.pipe(map(geometries2shapes(convert.from)))\n\n    const plop = core(convert, shapes$)(canvas, mouseCanvas, config)\n\n    const refresh = () => geometries$.next(geometries$.getValue())\n\n    plop.subscribe(event => {\n        const coordinates = event.payload.map(convert.to)\n        coordinates.push(coordinates[0])\n        const polygon: Polygon = {\n            type: 'Polygon',\n            coordinates: [coordinates],\n        }\n        geometries$.next([...geometries$.getValue(), polygon])\n    })\n\n    return Object.assign(plop, { refresh })\n}\n","import '../../leaflet/leaflet.css'\n\nimport React from 'react'\nimport { Map, TileLayer, useLeaflet, Pane } from 'react-leaflet'\nimport _ from 'lodash'\nimport { FeatureCollection, Polygon, MultiPolygon } from '@turf/helpers'\n\n// Plop\nimport plopLeaflet from '../../modules/leaflet/src'\n\n// Data\nimport geojson from '../../data/nl.json'\n\nconst Canvas = () => {\n    const context = useLeaflet()\n    const [data, setData] = React.useState<FeatureCollection<Polygon | MultiPolygon>>(\n        geojson as any,\n    )\n\n    React.useEffect(() => {\n        if (context.map != null) {\n            const plop = plopLeaflet(context.map, { pane: context.pane })([data])\n\n            // plop.observables.\n\n            return plop.unsubscribe\n        }\n    }, [\n        context.map,\n        // context.map && context.map.getCenter().lat,\n        // context.map && context.map.getCenter().lng,\n    ])\n\n    return null\n}\n\nconst tileLayer = (\n    <TileLayer\n        url=\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n        attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n    />\n)\n\nexport default () => {\n    const [position] = React.useState([52.1326, 5.2913] as [number, number])\n\n    return (\n        <Map center={position} zoom={8}>\n            {tileLayer}\n            <Pane name=\"plop-canvas\">\n                <Canvas />\n            </Pane>\n        </Map>\n    )\n}\n","import { Map } from 'leaflet'\nimport { createCanvasLayer, fromLngLat, toLngLat, translateOffsetOfCanvas } from './utils'\nimport plopGeoJSON from '../../geojson'\nimport { FeatureCollection, Feature, Polygon, MultiPolygon } from '@turf/helpers'\n\nexport type Geometry =\n    | Feature<Polygon | MultiPolygon>\n    | FeatureCollection<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon\n\nexport default (map: Map, options: { pane?: string } = {}) => (geometries: Geometry[]) => {\n    const pane = options.pane || (map.createPane('plop') && 'plop')\n    const canvasLayer = createCanvasLayer(pane)\n    const mouseCanvasLayer = createCanvasLayer(pane)\n\n    canvasLayer.addTo(map)\n    mouseCanvasLayer.addTo(map)\n\n    const elCanvas: HTMLCanvasElement = (canvasLayer as any)._container\n    const elMouseCanvasLayer: HTMLCanvasElement = (mouseCanvasLayer as any)._container\n    const translateOffset = translateOffsetOfCanvas(elCanvas)\n\n    const plop = plopGeoJSON({\n        from: fromLngLat(map),\n        to: toLngLat(map),\n    })(elCanvas, elMouseCanvasLayer, {\n        mapOffset: translateOffset,\n    })(geometries)\n\n    map.addEventListener('moveend zoomend', plop.refresh)\n\n    const unsubscribe = () => {\n        map.removeEventListener('moveend zoomend', plop.refresh)\n        map.removeLayer(canvasLayer)\n        map.removeLayer(mouseCanvasLayer)\n        plop.done()\n    }\n\n    return Object.assign(plop, { unsubscribe })\n}\n","import React from 'react'\nimport './App.css'\n\nimport Map from './apps/map'\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"App\">\n            <div className=\"App-header\">\n                <p>\n                    <button\n                        onClick={\n                            // @ts-ignore\n                            () => api.api.addPolygon()\n                        }\n                    >\n                        ADD POLYGON\n                    </button>\n                </p>\n                <ol>\n                    <li>\n                        Press <i>&quot;a&quot;</i> or click the <i>&quot;Add Polygon&quot;</i>{' '}\n                        button to start drawing.\n                    </li>\n                    <li>\n                        Press <i>&quot;Enter&quot;</i> to finish drawing. You can only finish after\n                        at least 3 points are drawn.\n                    </li>\n                    <li>\n                        Press <i>&quot;c&quot;</i> to cancel the operation.\n                    </li>\n                    <li>\n                        Supports:\n                        <ul>\n                            <li>Snapping</li>\n                            <li>Undo & redo with Ctrl-Z/Y while adding points</li>\n                        </ul>\n                    </li>\n                </ol>\n            </div>\n            <div id=\"map\">\n                <Map />\n            </div>\n        </div>\n    )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}